# learn.regex.md

*For myself and for you*

## 前言

Regular Expression 久仰大名，以前也一直有过类似的需求，然而之前或者用其他工具实现了，或者暴力解决了 😅

不过辣个咸鱼没点理想呢？加上 [notepad++][] 事件，坚定了我学习Vim的决心，学 Vim 当然也要学习 regex 了，当然 regex 的应用远远不止在 Vim 当中。

此笔记参考了：[runoob-tutorial][] 

出于行文简洁的考虑，摘抄的内容不会全部一一声明，  但我会把链接都放上来，各位谅解 🤝

[runoob-tutorial]: https://www.runoob.com/regexp/regexp-tutorial.html
[notepad++]: https://www.jianshu.com/p/1adced676d79


## 简介

refer: [runoob brief introduction][] 

[runoob brief introduction]: https://www.runoob.com/regexp/regexp-intro.html

许多程序设计语言都支持利用正则表达式进行字符串操作.

除非你以前使用过正则表达式，否则你可能不熟悉一些术语。
但是，毫无疑问，你已经使用过不涉及脚本的某些正则表达式概念。
例如，你很可能使用 `?` 和 `*` 通配符来查找硬盘上的文件。
`?` 通配符匹配文件名中的 `0 `个或 `1` 个字符，而 `*` 通配符匹配零个或多个字符。

尽管这种搜索方法很有用，但它还是有限的。通过理解 `*` 通配符的工作原理，
引入了正则表达式所依赖的概念，但正则表达式功能更强大，而且更加灵活。

#### 发展历史

正则表达式的"祖先"可以一直上溯至对人类神经系统如何工作的早期研究。Warren McCulloch 和 Walter Pitts 这两位神经生理学家研究出一种数学方式来描述这些神经网络。

1956 年, 一位叫 Stephen Kleene 的数学家在 McCulloch 和 Pitts 早期工作的基础上，发表了一篇标题为"神经网事件的表示法"的论文，引入了正则表达式的概念。正则表达式就是用来描述他称为"正则集的代数"的表达式，因此采用"正则表达式"这个术语。

随后，发现可以将这一工作应用于使用 Ken Thompson 的计算搜索算法的一些早期研究，Ken Thompson 是 Unix 的主要发明人。正则表达式的第一个实用应用程序就是 Unix 中的 qed 编辑器。

如他们所说，剩下的就是众所周知的历史了。从那时起直至现在正则表达式都是基于文本的编辑器和搜索工具中的一个重要部分。

## 正则表达式 - 语法

refer:[runoob syntax][]  [runoob metachar][] 

[runoob syntax]: https://www.runoob.com/regexp/regexp-syntax.html
[runoob metachar]: https://www.runoob.com/regexp/regexp-metachar.html

正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），
可以用来检查一个串是否含有某种子串、
将匹配的子串替换或者从某个串中取出符合某个条件的子串等。

依在下愚见：称之为模式的东西，必然是具有重复的结构，限定在某些已命名概念的范围中。
因为无限不循环小数之类的东西显然没什么模式，或者说是平庸的模式。

所以一个描述对象模式的语言，应该由以下几大块构成：
类（class）：描述模式对象的分类，给对象进行 general 的子集划分。
重复（repetition）：用来描述 已分类/已命名 对象的重复结构。
逻辑（Logical conjunction）：对 类 进行组合，构建更加复杂的结构。

我们预期会看到 regex 是如何实现这些基本的功能的，
理所当然会出现很多新的称呼方式。

## 元字符 与 普通字符

字符有不同的分类方法，除了 regex 本身的 元字符与普通字符分类，
还有计算机领域 general 的 打印字符 和 不可打印字符分类

{All 字符} == {元字符} + {普通字符}
{All 字符} == {打印字符} + {不可打印字符}

###  普通字符

普通字符包括 **没有** 显式指定为 **元字符** 的所有 **可打印字符** 和 **不可打印字符** 。
这包括所有 **大小写字母** 、所有 **数字** 、所有 **标点符号** 和一些 **其他符号** 。

{普通字符} == {大小写字母} +{数字}+{标点符号}+{其他符号}


### 特殊字符

所谓特殊字符，就是一些有特殊含义的字符。

许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符"转义"，即，将反斜杠字符\ 放在它们前面。下表列出了正则表达式中的特殊字符：

|   特别字符  |  描述   |
| ---- | ---- |
|   $  |   匹配输入字符串的结尾位置   |
| \(\) |   标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用   |
|   \*   |   匹配前面的子表达式零次或多次   |
|   \+   |  匹配前面的子表达式一次或多次    |
|   \.   |   匹配除换行符 \\n 之外的任何单字符   |
|  \[    |   标记一个中括号表达式的开始   |
|   ?   |  匹配前面的子表达式零次或一次，或指明一个非贪婪限定符    |
|   \\   | 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符 |
|  ^    |   匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合   |
|  \{    |   标记限定符表达式的开始|
|  \|    |   指明两项之间的一个选择   |


### 非打印字符

非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列：


|  字符    |  描述    |
| ---- | ---- |
|  \cx    | 匹配由x指明的控制字符。     |
|  \f  |   匹配一个换页符。   |
| \n | 匹配一个换行符。 |
| \r | 匹配一个回车符。 |
| \s | 匹配任何空白字符，包括空格、制表符、换页符等等。注意 Unicode 正则表达式会匹配全角空格符。 |
| \S | 匹配任何非空白字符。 |
| \t |    	匹配一个制表符。   |
|   \v   |   匹配一个垂直制表符。   |

详情参见 [runoob metachar][]

### 限定符

即上文提到的用来表示**重复模式**的语法，在 regex 中被称为**限定符** 

限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。
有 `*` 或 `+`或 `?` 或 `{n}` 或 `{n,}` 或 `{n,m}` 共6种


|  字符    |  描述    |
| ---- | ---- |
|  \*    | 匹配前面的子表达式零次或多次     |
|  \+  |   匹配前面的子表达式一次或多次  |
| ? | n 是一个非负整数。匹配确定的 n 次 |
| {n} | 匹配一个回车符。 |
| {n,} | n 是一个非负整数。至少匹配n 次 |
| {n,m} | m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次 |

详情参见 [runoob metachar][]

## 贪婪 and 非贪婪

这个语法用来描述**自同构**现象

1. 非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。 例如，对于字符串 `oooo`，`o+?` 将匹配单个 `o`，而 `o+` 将匹配所有 `o`。

`*`、`+` 限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配。

例如，你可能搜索 HTML 文档，以查找在 `h1` 标签内的内容。HTML 代码如下：

```html
<h1>RUNOOB-菜鸟教程</h1>
```

贪婪：下面的表达式匹配整个`<h1>RUNOOB-菜鸟教程</h1>`

	/<.*>/

非贪婪：下面的非贪婪表达式只匹配`<h1>`。

	/<.*?>/

也可以使用以下正则表达式来匹配 `h1` 标签，表达式则是

	/<\w+?>/

通过在 `*`、`+` 或 `?` 限定符之后放置 `?`，该表达式从"贪婪"表达式转换为"非贪婪"表达式或者最小匹配。


### 定位符

它们是特殊的一个 **class**，用来描述字符串或单词的**边界**。

`^` 和 `$` 分别指字符串的开始与结束，
` \b ` 描述单词的前或后边界，` \B ` 表示非单词边界。

定位符使你能够将正则表达式固定到行首或行尾。
它们还可以用来构造这样的正则表达式：
出现在一个单词内、在一个单词的开头或者一个单词的结尾。

正则表达式的定位符有：

| 字符 | 描述                                 |
| ---- | -------------------------------- |
| ^    | 匹配输入字符串开始的位置             |
| $    | 匹配输入字符串结尾的位置             |
| \\b   | 匹配一个单词边界，即字与空格间的位置 |
| \\B   | 非单词边界匹配                       |

#### 注意

1. 不能将限定符与定位符一起使用。由于在紧靠换行或者单词边界的前面或后面不能有一个以上位置，因此不允许诸如 `^*` 之类的表达式。
2. 若要匹配一行文本开始处的文本，请在正则表达式的开始使用 `^` 字符。不要将 `^` 的这种用法与中括号表达式内的用法混淆。
3. 若要匹配一行文本的结束处的文本，请在正则表达式的结束处使用 `$` 字符

####  example

搜索章节标题

下面的正则表达式匹配一个章节标题，该标题只包含两个尾随数字，并且出现在行首：

	/^Chapter [1-9][0-9]{0,1}/

真正的章节标题不仅出现行的开始处，而且它还是该行中仅有的文本。
它即出现在行首又出现在同一行的结尾。
下面的表达式能确保指定的匹配只匹配章节而不匹配交叉引用。
通过创建只匹配**一行文本的开始和结尾**的正则表达式，就可做到这一点。

	/^Chapter [1-9][0-9]{0,1}$/

匹配单词边界稍有不同，但向正则表达式添加了很重要的能力。
单词边界是单词和空格之间的位置。非单词边界是任何其他位置。
下面的表达式匹配单词 `Chapter` 的开头三个字符，因为这三个字符出现在单词边界后面：

	/\bCha/

` \b ` 字符的位置是非常重要的。
如果它位于正则表达式中 要匹配的字符串的开始，它匹配单词的开始处。
如果它位于正则表达式中 字符串的结尾，它匹配单词的结尾处。
例如，下面的表达式匹配单词 `Chapter` 中的字符串 `ter`，因为它出现在单词结尾边界的前面：

	/ter\b/

下面的表达式匹配 `Chapter` 中的字符串 `apt`，但不匹配 `aptitude` 中的字符串 `apt`：

	/\Bapt/

字符串 `apt` 出现在单词 `Chapter` 中的非单词边界处，但出现在单词 `aptitude` 中的单词边界处。
对于 ` \B `非单词边界运算符，位置并不重要，因为匹配不关心究竟是单词的开头还是结尾。

### 选择

相当于数学逻辑关系中的`And` 或者 `Or`

用圆括号将所有选择项括起来，相邻的选择项之间用` | `分隔。
但用圆括号会有一个副作用，使相关的匹配会被缓存，此时可用` ?: `放在第一个选项前来消除这种副作用。

其中 ` ?: ` 是非捕获元之一，
还有两个非捕获元是 `?=` 和 `?!`，这两个还有更多的含义。
前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串。
后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。


### example

`industr(?:y|ies)` 相当于 `industry|industries`


## 各种预查


| 语法         | 中文名       | 英文名                       |
| ------------ | ------------ | -------------------------- |
| (?=pattern)  | 正向肯定预查 | look ahead positive assert   |
| (?!pattern)  | 正向否定预查 | look ahead  negative assert  |
| (?<=pattern) | 反向肯定预查 | look behind  positive assert |
| (?<!pattern) | 反向否定预查 | look behind  negative assert |


### 正向肯定预查

	(?=pattern)

在任何匹配`pattern`的字符串开始处匹配查找字符串。
这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用

例如，`Windows(?=95|98|NT|2000)` 能匹配 `Windows2000` 中的 `Windows`，
但不能匹配 `Windows3.1` 中的 `Windows`。
预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。

相当于一个有位置逻辑的 `And`

注意： 在这里， `Windows(?=95|98|NT|2000)`中的`|`实际上相当于数学中的 `or`

### 正向否定预查

	(?!pattern)

在任何不匹配`pattern`的字符串开始处匹配查找字符串。
这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。

例如`Windows(?!95|98|NT|2000)`能匹配`Windows3.1`中的`Windows`，
但不能匹配`Windows2000`中的`Windows`。
预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。

注意： 在这里， `Windows(?!95|98|NT|2000)`中的`|`实际上相当于数学中的 `And`而不是`or`，与上文相比不同。即同一个`|`符号在**肯定预查**和**否定预查**中的数学意义**不同**

### 反向肯定预查

	(?<=pattern)

与正向肯定预查类似，只是方向相反。

例如，` (?<=95|98|NT|2000)Windows ` 能匹配 ` 2000Windows `中的` Windows `，
但不能匹配 ` 3.1Windows ` 中的 ` Windows `。

### 反向否定预查

	(?<!pattern)

反向否定预查，与正向否定预查类似，只是方向相反。
例如` (?<!95|98|NT|2000)Windows `能匹配` 3.1Windows `中的` Windows `，但不能匹配` 2000Windows `中的` Windows `。


## 反向引用

对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，
所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。
缓冲区编号从 `1` 开始，最多可存储 `99` 个捕获的子表达式。
每个缓冲区都可以使用 ` \n ` 访问，其中 ` n ` 为一个标识特定缓冲区的 **一位或两位十进制数**。

可以使用非捕获元字符 ` ?: `、` ?= ` 或 ` ?! ` 来重写捕获，忽略对相关匹配的保存。

### example 

相同的相邻单词

反向引用的最简单的、最有用的应用之一，
是提供查找文本中两个相同的相邻单词的匹配项的能力。

以下面的句子为例：

	Is is the cost of of gasoline going up up?


上面的句子很显然有多个重复的单词。
下面的正则表达式使用单个子表达式来定位这个句子：

	/
	\b([a-z]+) \1\b
	/ig;
	%%
	result: Is is,of of,up up 


说明：

1. 捕获的表达式，正如 `[a-z]+` 指定的，包括一个或多个字母。
2. 正则表达式的第二部分是对以前捕获的子匹配项的引用，即，单词的第二个匹配项正好由括号表达式匹配。\1 指定第一个子匹配项。
3. 单词边界元字符确保只检测整个单词。否则，诸如 `is issued` 或 `this is` 之类的词组将不能正确地被此表达式排除。
4. 正则表达式后面的全局标记 `g` 指定将该表达式应用到输入字符串中能够查找到的尽可能多的匹配。
5. 表达式的结尾处的不区分大小写 `i` 标记指定不区分大小写。
6. 多行标记指定换行符的两边可能出现潜在的匹配。


### example 

URI  分解

反向引用还可以将通用资源指示符 (URI) 分解为其组件。
假定你想将下面的 URI 分解为协议（ftp、http 等等）、域地址和页/路径：

	http://www.runoob.com:80/html/html-tutorial.html

下面的正则表达式提供该功能：

	/
	(\w+):\/\/
	([^/:]+)
	(:\d*)?
	([^# ]*)
	/;


1. 第一个括号子表达式捕获 Web 地址的协议部分。该子表达式匹配在冒号和两个正斜杠前面的任何单词。
2. 第二个括号子表达式捕获地址的域地址部分。子表达式匹配 `:` 和` / ` 之后的一个或多个字符。
3. 第三个括号子表达式捕获端口号（如果指定了的话）。该子表达式匹配冒号后面的零个或多个数字。只能重复一次该子表达式。(当`?`紧跟在任何一个其他限制符后面时，匹配模式是非贪婪的)
4. 最后，第四个括号子表达式捕获 Web 地址指定的路径和 `/` 或页信息。该子表达式能匹配不包括 # 或空格字符的任何字符序列。

将正则表达式应用到上面的 URI，各子匹配项包含下面的内容：

第一个括号子表达式包含 `http`
第二个括号子表达式包含 `www.runoob.com`
第三个括号子表达式包含 `:80`
第四个括号子表达式包含 ` /html/html-tutorial.html `


## 所有元字符


| 字符         | 描述                          |
| --------- | ----------------------- |
| \\           | 转义符号                        |
| ^            | 匹配输入字符串的开始位置            |
| $            | 匹配输入字符串的结束位置   	|
| \*		   | 匹配前面的子表达式零次或多次		|
| \+            | 匹配前面的子表达式一次或多次    |
| ?            | 匹配前面的子表达式零次或一次   |
| {n}          | n 是一个非负整数，匹配确定的 n 次    |
| {n,}         | n 是一个非负整数。至少匹配n 次，>=  |
| {n,m}        | m 和 n 均为非负整数，其中n <= m， 最少匹配 n 次且最多匹配 m 次 |
| ?            | 当该字符紧跟在任何一个其他限制符 (\*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的 |
| \.            | 匹配除换行符（\n、\r）之外的任何单个字符  |
| (pattern)    | 匹配 pattern 并获取这一匹配       |
| (?:pattern)  | 匹配 pattern 但不获取匹配结果       |
| (?=pattern)  | 正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串 |
| (?!pattern)  | 正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串 |
| (?<=pattern) | 反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。 |
| (?<!pattern) | 反向否定预查，与正向否定预查类似，只是方向相反。             |
|     x\|y     | 匹配 x 或 y。 |
| \[xyz\] | 字符集合。匹配所包含的任意一个字符 |
| \[^xyz\] | 负值字符集合。匹配未包含的任意字符 |
| \[a-z\] | 字符范围。匹配指定范围内的任意字符 |
| [^a-z] | 负值字符范围。匹配任何不在指定范围内的任意字符 |
| \\b | 匹配一个单词边界，也就是指单词和空格间的位置。 |
| \\B | 匹配非单词边界 |
| \\cx | 匹配由 x 指明的控制字符 |
| \\d | 匹配一个数字字符。等价于 \[0-9\] |
| \\D | 匹配一个非数字字符。等价于 \[^0-9\] |
| \\f | 匹配一个换页符。 |
| \\n | 匹配一个换行符 |
| \\r | 匹配一个回车符 |
| \\s | 匹配任何空白字符，包括空格、制表符、换页符等等 |
| \\S | 匹配任何非空白字符 |
| \\t | 匹配一个制表符 |
| \\v | 匹配一个垂直制表符|
| \\w |  匹配字母、数字、下划线|
| \\W | 匹配非字母、数字、下划线。 |
| \\xn | 匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长 |
| \\num |  匹配 num，其中 num 是一个正整数。对所获取的匹配的引用 |
| \\n | 标识一个八进制转义值或一个向后引用 |
| \\nm | 标识一个八进制转义值或一个向后引用 |
| \\nml | 如果 n 为八进制数字 \(0-3\)，且 m 和 l 均为八进制数字 \(0-7\)，则匹配八进制转义值 nml |
| \\un | 匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符 |



详情参见 [runoob syntax][]
