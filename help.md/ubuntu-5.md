# ubuntu-5

## 第十一章:进程

通常,现在的操作系统都支持多任务,意味着操作系统(给用户)造成了一种假象,(让用户觉得) 它同时能够做多件事情,事实上,它是快速地轮换执行这些任务的.

Linux 内核通过使用**进程**,来管理多任务.通过进程,Linux 安排不同的程序等待使用 CPU.
有时候,计算机变得呆滞,运行缓慢,或者一个应用程序停止响应.
在这一章中,我们将看一些可用的命令行工具,这些工具帮助我们查看程序的执行状态,以及怎样终止行为不当的进程.

这一章将介绍以下命令:

+ `ps` – 报告当前进程快照
+ `top` – 显示任务
+ `jobs` – 列出活跃的任务
+ `bg` – 把一个任务放到后台执行
+ `fg` – 把一个任务放到前台执行
+ `kill` – 给一个进程发送信号
+ `killall` – 杀死指定名字的进程
+ `shutdown` – 关机或重启系统

### 进程是怎样工作的

当系统启动的时候,内核先把一些它自己的程序初始化为进程,然后运行一个叫做 `init` 的程序.

`init`, 依次地,再运行一系列的称为 `init` 脚本的 `shell` 脚本(位于`/etc`),它们可以启动所有的系统服务.

其中许多系统服务以守护(daemon)程序的形式实现,守护程序仅在后台运行,没有任何用户接口.
这样,即使我们没有登录系统,至少系统也在忙于执行一些例行事务.

一个程序可以发动另一个程序,这个事实在进程方案中,表述为一个父进程创建了一个子进程.

内核维护每个进程的信息,以此来保持事情有序.
例如,系统分配给每个进程一个数字,这个数字叫做 进程 `ID`或 `PID`.`PID` 号按升序分配,`init` 进程的 `PID` 总是1.
内核也对分配给每个进程的内存进行跟踪. 像文件一样,进程也有所有者和用户 `ID`,有效用户 `ID`,等等.

### 查看进程

查看进程,最常使用的命令(有几个命令)是` ps`.`ps` 程序有许多选项,它最简单地使用形式是这样的:

```bash
ps
```

正如我们所看到的, 默认情况下,ps 不会显示很多进程信息,只是列出与当前终端会话相关的进程.

为了得到更多信息, 我们需要加上一些选项,但是在这样做之前,我们先看一下 `ps` 命令运行结果的其它字段.

TTY 是 `Teletype` 的简写,是指进程的控制终端.这里,`Unix` 展示它的年龄.`TIME` 字段表示 进程所消耗的 `CPU` 时间数量.

如果给 `ps` 命令加上选项,我们可以得到更多关于系统运行状态的信息:

```bash
ps x
```

加上 `x` 选项(注意没有开头的 `-` 字符),告诉 `ps` 命令,展示所有进程,不管它们由什么 终端(如果有的话)控制.
在 `TTY` 一栏中出现的 `?` ,表示没有控制终端.使用这个 `x` 选项,可以 看到我们所拥有的每个进程的信息.

因为系统中正运行着许多进程,所以 `ps` 命令的输出结果很长.把 `ps` 的输出结果管道到less 命令经常很有帮助.
一些选项组合也会产生很长的输出结果,所以最大化 终端仿真器窗口,也是一个好主意.

输出结果中,新添加了一栏,标题为 `STAT` .`STAT` 是 `state` 的简写,它揭示了进程当前状态:

****
状态 意义

+ `R` :  运行.这意味着,进程正在运行或准备运行.
+ `S` :  正在睡眠. 进程没有运行,而是,正在等待一个事件, 比如说,一个按键或者网络数据包.
+ `D` :  不可中断睡眠.进程正在等待` I/O`,比方说,一个磁盘驱动器的` I/O`.
+ `T` :  已停止. 已经指示进程停止运行.稍后介绍更多.
+ `Z` :  一个死进程或`僵尸`进程.这是一个已经终止的子进程,但是它的父进程还没有清空它. (父进程没有把子进程从进程表中删除)
+ `<` : 一个高优先级进程.这可能会授予一个进程更多重要的资源,给它更多的CPU 时间. 进程的这种属性叫做niceness.
具有高优先级的进程据说是不好的(less nice), 因为它占用了比较多的 CPU 时间,这样就给其它进程留下很少时间.
+ `N` :低优先级进程. 一个低优先级进程(一个`好`进程)只有当其它高优先级进程执行之后,才会得到处理器时间.

进程状态信息之后,可能还跟随其他的字符.这表示各种外来进程的特性.详细信息请看 `ps` 手册页.

另一个流行的选项组合是 `aux`(不带开头的`-`字符).这会给我们更多信息:

```bash
ps aux
```

这个选项组合,能够显示属于每个用户的进程信息.使用这个选项,可以唤醒 `BSD 风格` 的输出结果.

Linux 版本的 `ps` 命令,可以模拟几个不同 Unix 版本中的 `ps` 程序的行为.
通过这些选项,我们得到 这些额外的列.

***
标题 意思

+ `USER` 用户 `ID`. 进程的所有者.
+ `%CPU` 以百分比表示的 CPU 使用率
+ `%MEM` 以百分比表示的内存使用率
+ `VSZ` 虚拟内存大小
+ `RSS` 进程占用的物理内存的大小,以千字节为单位.
+ `START` 进程运行的起始时间.若超过`24`小时,则用天表示.

### 用 `top` 命令动态查看进程

虽然 `ps` 命令能够展示许多计算机运行状态的信息,但是它只是提供,`ps` 命令执行时刻的机器状态快照.
为了看到更多动态的信息,我们使用 `top` 命令:

```bash
top
```

`top` 程序连续显示系统进程更新的信息(默认情况下,每三分钟更新一次),`top`这个名字来源于这个事实,`top` 程序是用来查看系统中`顶端`进程的.
`top` 显示结果由两部分组成: 最上面是系统概要,下面是进程列表,以 `CPU` 的使用率排序.

其中系统概要包含许多有用信息.下表是对系统概要的说明:

***
行号 字段 意义

1. `top` 程序名. `14:59:20` 当前时间. `up 6:30` 这是正常运行时间.
它是计算机从上次启动到现在所运行的时间. 在这个例子里,系统已经运行了六个半小时.
`2 users` 有两个用户登录系统.
`load average`: 加载平均值是指,等待运行的进程数目,也就是说,处于运行状态的进程个数, 这些进程共享`CPU`.
展示了三个数值,每个数值对应不同的时间周期.第一个是最后`60`秒的平均值, 下一个是前`5`分钟的平均值,
最后一个是前15分钟的平均值.若平均值低于`1.0`,则指示计算机 工作不忙碌.
2. `Tasks`: 总结了进程数目和各种进程状态.
3. `Cpu(s)`: 这一行描述了` CPU` 正在执行的进程的特性.
`0.7%us`: `0.7%` of the CPU is being used for user processes. 这意味着进程在内核之外.
`1.0%sy`: `1.0%`的 `CPU` 时间被用于 系统(内核)进程.
`0.0%ni` : `0.0%`的 `CPU` 时间被用于`nice`(低优先级)进程.
`98.3%id`: `98.3%`的 `CPU` 时间是空闲的.
`0.0%wa` : `0.0%`的 `CPU` 时间来等待 `I/O`.
4. `Mem`: 展示物理内存的使用情况.
5. `Swap`: 展示交换分区(虚拟内存)的使用情况.

top 程序接受一系列从键盘输入的命令.两个最有趣的命令是 `h` 和 `q`.
`h`:显示程序的帮助屏幕,`q`: 退出 `top` 程序.

两个主要的桌面环境都提供了图形化应用程序,来显示与 `top` 程序相似的信息 (和 `Windows` 中的任务管理器差不多),
但是我觉得 `top` 程序要好于图形化的版本, 因为它运行速度快,并且消费很少的系统资源.
毕竟,我们的系统监测程序不能成为 系统怠工的源泉,而这是我们试图追踪的信息.

### 控制进程

现在我们可以看到和监测进程,然后得到一些对它们的控制权.
为了我们的实验,我们将使用 一个叫做 `xlogo` 的小程序,作为我们的实验品.

这个 `xlogo` 程序是 `X` 窗口系统 (底层引擎使图形界面显示在屏幕上)提供的实例程序,这个实例简单地显示一个大小可调的包含 X 标志的窗口.

首先,我们需要知道测试的主题:

```bash
xlogo
```

命令执行之后,一个包含 `X` 标志的小窗口应该出现在屏幕的某个位置上.在一些系统中,`xlogo` 命令 会打印一条警告信息,但是不用理会它.
小贴士:如果你的系统不包含 xlogo 程序,试着用 `gedit` 或者 `kwrite` 来代替.

通过调整它的窗口大小,我们能够证明 `xlogo` 程序正在运行.如果这个标志以新的尺寸被重画, 则这个程序正在运行.

注意,为什么我们的 `shell` 提示符还没有返回?这是因为 `shell` 正在等待这个程序结束, 就像到目前为止我们用过的其它所有程序一样.如果我们关闭 `xlogo` 窗口,`shell` 提示符就返回了.

#### 中断一个进程

我们再运行 `xlogo` 程序一次,观察一下发生了什么事.首先,执行 `xlogo` 命令,并且 证实这个程序正在运行.
下一步,回到终端窗口,按下 `Ctrl-c`.

在一个终端中,输入 `Ctrl-c`,中断一个程序.这意味着,我们礼貌地要求终止这个程序. 输入 `Ctrl-c` 之后, `xlogo` 窗口关闭,`shell` 提示符返回.通过这个技巧,许多(但不是全部)命令行程序可以被中断.

#### 把一个进程放置到后台(执行)

比方说,我们想让 `shell` 提示符返回,却不想终止 `xlogo` 程序.为达到这个目的,我们把 这个程序放到后台执行.

把终端看作是一个有前台(表层放置可见的事物,像 `shell` 提示符) 和后台(表层之下放置隐藏的事物)(的设备).
启动一个程序,让它立即在后台 运行,我们在程序命令之后,加上`&`字符:

```bash
xlogo &
[1] 28236
```

执行命令之后,这个 `xlogo` 窗口出现,并且 `shell` 提示符返回,同时打印一些有趣的数字.
这条信息是 `shell` 特性的一部分,叫做工作控制.
通过这条信息,`shell` 告诉我们,已经启动了 工作号为`1`(`[1]`),`PID` 为`28236`的程序.
如果我们运行 `ps` 命令,可以看到我们的进程.

shell 功能--工作控制,这个 可以列出从终端中启动的任务.执行 `jobs` 命令,我们可以看到这个输出列表:

```bash
jobs
[1]+ Running
xlogo &
```

结果显示我们有一个任务,编号为`1`,它正在运行,并且这个任务的命令是 `xlogo &`.

#### 进程返回到前台

一个在后台运行的进程对一切来自键盘的输入都免疫,也不能用 `Ctrl-c` 来中断它.
使用 `fg` 命令,让一个进程返回前台执行:

```bash
jobs
[1]+ Running
xlogo &
fg %1
xlogo
```

`fg` 命令之后,跟随着一个百分号和工作序号(叫做 `jobspec`).如果我们只有一个后台任务,那么 `jobspec` 是可有可无的.
输入 `Ctrl-c` 来终止 `xlogo` 程序.

#### 停止一个进程

有时候,我们想要停止一个进程,而没有终止它.这样会把一个前台进程移到后台等待.
输入`Ctrl-z`,可以停止一个前台进程.让我们试一下.在命令提示符下,执行 `xlogo` 命令, 然后输入 `Ctrl-z`:

```bash
xlogo
[1]+ Stopped xlogo
```

停止 `xlogo` 程序之后,通过调整 `xlogo` 的窗口大小,我们可以证实这个程序已经停止了.
它看起来像死掉了一样.使用 `fg` 命令,可以恢复程序到前台运行,或者用 `bg` 命令把程序移到后台.

```bash
bg %1
[1]+ xlogo &
```

和 `fg` 命令一样,如果只有一个任务的话, `jobspec` 参数是可选的.
因为把一个进程从前台移到后台很方便,如果我们从命令行启动一个图形界面的程序,但是忘记把它放到后台执行,即没有在命令后加上字符`&`,(也不用担心).

为什么要从命令行启动一个图形界面程序呢?有两个原因.
第一个,你想要启动的程序,可能 没有在窗口管理器的菜单中列出来(比方说 `xlogo`).
第二个,从命令行启动一个程序, 你能够看到一些错误信息,如果从窗口系统中运行程序的话,这些信息是不可见的.
有时候, 一个程序不能从图形界面菜单中启动.这时候,应该从命令行中启动它.我们可能会看到 错误信息,这些信息揭示了问题所在.
一些图形界面程序还有许多有意思并且有用的命令行选项.

#### Signals

`kill` 命令被用来`杀死`程序.这样我们就可以终止需要杀死的程序.这里有一个实例:

```bash
xlogo &
:[1] 28401
kill 28401
:[1]+ Terminated
xlogo
```

首先,我们在后台启动 `xlogo` `程序.shell` 打印出 `jobspec` 和这个后台进程的 `PID`.
下一步,我们使用 `kill` 命令,并且指定我们想要终止的进程 `PID`.也可以用 `jobspec`(例如,`%1`)来代替 `PID`.

虽然这个命令很直接了当,但不仅仅这些.这个 `kill` 命令不是确切地`杀死`程序,而是给程序 发送信号.
信号是操作系统与程序之间进行通信,所采用的几种方式中的一种.

我们已经看到 信号,在使用 `Ctrl-c` 和 `Ctrl-z` 的过程中.当终端接受了其中一个按键组合后,它会给在前端运行 的程序发送一个信号.
在使用 `Ctrl-c` 的情况下,会发送一个叫做 `INT`(中断)的信号;当使用 `Ctrl-z` 时,则发送一个叫做 `TSTP`(终端停止)的信号.程序,反过来,倾听信号的到来,当程序 接到信号之后,则做出响应.

一个程序能够倾听和响应信号,这个事实允许一个程序做些事情, 比如,当程序接到一个终止信号时,它可以保存所做的工作.

#### 通过 `kill` 命令给进程发送信号

`kill` 命令被用来给程序发送信号.它最常见的语法形式看起来像这样:

```bash
kill [-signal] PID...
```

如果在命令行中没有指定信号,那么默认情况下,发送 `TERM`(终止)信号.`kill` 命令被经常 用来发送以下命令:

****
常用信号
| 编号 | 名字 | 含义 |

+ `1` `HUP` `挂起` : 这是美好往昔的痕迹,那时候终端机通过电话线和调制解调器连接到 远端的计算机.这个信号
被用来告诉程序,控制的终端机已经`挂起`. 通过关闭一个终端会话,可以说明这个信号的作用.发送这个信号到终端机上的前台程序,程序会终止.
许多守护进程也使用这个信号,来重新初始化.这意味着,当发送这个信号到一个守护进程后, 这个进程会重新启动,并且重新读取它的配置文件.`Apache` 网络服务器守护进程就是一个例子.

+ `2` `INT` `中断`:实现和 `Ctrl-c` 一样的功能,由终端发送.通常,它会终止一个程序.
+ `9` `KILL` `杀死` : 这个信号很特别.鉴于进程可能会选择不同的方式来处理信号,其中也包含忽略信号.
`Kill`并不发送`9`信号到目标进程.而是内核立即终止 这个进程.
当一个进程以这种方式终止的时候,它没有机会去做些`清理`工作,或者是保存劳动成果.
因为这个原因,把 `KILL` 信号看作杀手锏,当其它终止信号失败后,再使用它.
+ `15` `TERM` `终止`: 这是 `kill` 命令发送的默认信号.如果程序仍然`活着`,可以接受信号,那么 这个信号终止程序.
+ `18` `CONT` `继续`: 在停止一段时间后,进程恢复运行.
+ `19` `STOP` `停止`: 这个信号导致进程停止运行,而没有终止.类似`KILL` 信号,它不被发送到目标进程,因此它不能被忽略.

让我们实验一下 `kill` 命令:

```bash
xlogo &
[1] 13546
kill -1 13546
[1]+ Hangup
xlogo
```

在这个例子里,我们在后台启动 `xlogo` 程序,然后通过 `kill` 命令,发送给它一个 `HUP` 信号.
这个 `xlogo` 程序终止运行,并且 `shell` 指示这个后台进程已经接受了一个挂起信号.
在看到这条 信息之前,你可能需要多按几次 `enter` 键.注意,既可以用号码,也可以用名字,不过要在名字前面 加上字母`SIG`,来指定所要发送的信号.

```bash
xlogo &
[1] 13546
kill -1 13546
[1]+ Hangup
xlogo
```

重复上面的例子,试着使用其它的信号.记住,你也可以用 `jobspecs` 来代替 `PID` .

进程,和文件一样,拥有所有者,所以为了能够通过 `kill` 命令来给进程发送信号, 你必须是进程的所有者(或者是超级用户).

除了上表列出的 `kill` 命令最常使用的信号之外,还有一些系统频繁使用的信号.以下是其它一些常用 信号列表:

***
其它常用信号
| 编号 | 名字 | 含义 |

+ `3` `QUIT` `退出`
+ `11` `SEGV` `段错误`: 如果一个程序非法使用内存,就会发送这个信号.也就是说, 程序试图写入内存,而这个内存空间是不允许此程序写入的
+ `20` `TSTP` `终端停止`: 当按下 `Ctrl-z` 组合键后,终端发送这个信号.不像 `STOP` 信号, `TSTP` 信号由目标进程
接收,且可能被忽略.
+ `28` `WINCH` `改变窗口大小`: 当改变窗口大小时,系统会发送这个信号. 一些程序,像 `top` 和 `less` 程序会响
应这个信号,按照新窗口的尺寸,刷新显示的内容.

为了满足读者的好奇心,通过下面的命令可以得到一个完整的信号列表:

```bash
kill -l
```

#### 通过 `killall` 命令给多个进程发送信号

也有可能通过 `killall` 命令,给匹配特定程序或用户名的多个进程发送信号.下面是 `killall` 命令的语法形式:

```bash
killall [-u user] [-signal] name...
```

为了说明情况,我们将启动一对 `xlogo` 程序的实例,然后再终止它们:

```bash
$ xlogo &
[1] 18801
$ xlogo &
[2] 18802
$ killall xlogo
[1]- Terminated xlogo
[2]+ Terminated xlogo
```

记住,和 `kill` 命令一样,你必须拥有超级用户权限才能给不属于你的进程发送信号.

### 更多和进程相关的命令

因为监测进程是一个很重要的系统管理任务,所以有许多命令与它相关.玩玩下面几个命令:

***
| 命令名 | 命令描述 |

+ `pstree` : 输出一个树型结构的进程列表,这个列表展示了进程间父/子关系.
+ `vmstat`: 输出一个系统资源使用快照,包括内存,交换分区和磁盘`I/O`. 为了看到连续的显示结果,则在命令名后加上延时的时间(以秒为单位).例如,`vmstat 5`. 终止输出,按下 `Ctrl-c` 组合键.
+ `xload`: 一个图形界面程序,可以画出系统负载的图形.
+ `tload`: 与 `xload` 程序相似,但是在终端中画出图形.使用 `Ctrl-c`,来终止输出.

## 第十二章:shell环境

正如我们之前所讨论到的,`shell` 在 `shell`会话中维护着大量的信息,这些信息称为 (`shell`) 环境. 
存储在 `shell`环境中的数据被程序用来确定配置属性.

然而大多数程序用配置文件来存储程序设置, 某些程序也会查找存储在`shell` 环境中的数值来调整他们的行为.
知道了这些,我们就可以用 `shell` 环境 来自定制 `shell` 经历.

在这一章,我们将用到以下命令:

+ `printenv` - 打印部分或所有的环境变量
+ `set` - 设置 `shell` 选项
+ `export` — 导出环境变量,让随后执行的程序知道.
+ `alias` - 创建命令别名

### 什么存储在环境变量中?

shell 在环境中存储了两种基本类型的数据,虽然对于 bash 来说,很大程度上这些类型是不可辨别的.
它们是环境变量和 shell 变量.

Shell 变量是由 `bash` 存放的少量数据,而剩下的基本上 都是环境变量.

除了变量,shell 也存储了一些可编程的数据,命名为别名和 shell 函数.
我们 已经在第六章讨论了别名,而 shell 函数(涉及到 shell 脚本)将会在第五部分叙述.

### 检查环境变量

我们既可以用 bash 的内部命令 `set`,或者是 `printenv` 程序来查看什么存储在环境当中.

`set` 命令可以显示shell 和环境变量两者,而 `printenv` 只是显示环境变量.
因为环境变量内容列表相当长,所以最好 把每个命令的输出结果管道到 less 命令:

```bash
$ printenv | less
```

执行以上命令之后,我们应该能得到类似以下内容:

```bash
KDE_MULTIHEAD=false
SSH_AGENT_PID=6666
...
```

我们所看到的是环境变量及其数值的列表.
例如,我们看到一个叫做 USER 的变量,这个变量值是 `me`.`printenv` 命令也能够列出特定变量的数值:

```bash
$ printenv USER
me
```

当使用没有带选项和参数的 `set` 命令时,shell 和环境变量二者都会显示,同时也会显示定义的 shell 函数.
不同于 `printenv` 命令,`set` 命令的输出结果很礼貌地按照字母顺序排列:

```bash
$ set | less
```

也可以通过 `echo` 命令来查看一个变量的内容,像这样:

```bash
$ echo $HOME
/home/me
```

如果 shell 环境中的一个成员既不可用 `set` 命令也不可用 `printenv` 命令显示,则这个变量是别名. 
输入不带参数的 `alias` 命令来查看它们:

```bash
$ alias
alias l.='ls -d .* --color=tty'
alias ll='ls -l --color=tty'
...
```

### 一些有趣的变量

shell 环境中包含相当多的变量,虽然你的 shell 环境可能不同于这里展示的,但是你可能会看到 以下变量在你的 shell 环境中:

***
环境变量
变量 内容

+ `DISPLAY`: 如果你正在运行图形界面环境,那么这个变量就是你显示器的名字.
通常,它是 `:0`, 意思是由`X`产生的第一个显示器.
+ `EDITOR`: 文本编辑器的名字.
+ `SHELL`: shell 程序的名字.
+ `HOME`: 用户家目录.
+ `LANG`: 定义了字符集以及语言编码方式.
+ `OLD_PWD`: 先前的工作目录.
+ `PAGER`: 页输出程序的名字.这经常设置为`/usr/bin/less`.
+ `PATH`: 由冒号分开的目录列表,当你输入可执行程序名后,会搜索这个目录列表.
+ `PS1`: `Prompt String 1`. 这个定义了你的shell 提示符的内容.随后我们可以看到,这个变量 内容可以全面地定制.
+ `PWD`: 当前工作目录.
+ `TERM`: 终端类型名.类 Unix 的系统支持许多终端协议;这个变量设置你的终端仿真器所用的协议.
+ `TZ`: 指定你所在的时区.大多数类 Unix 的系统按照协调时间时 (UTC) 来维护计算机内部的时钟 ,然后应用一个由这个变量指定的偏差来显示本地时间.
+ `USER`: 你的用户名

如果缺失了一些变量,不要担心,这些变量会因发行版本的不同而不同.

### 如何建立 shell 环境?

当我们登录系统后,启动 bash 程序,并且会读取一系列称为启动文件的配置脚本, 这些文件定义了默认的可供所有用户共享的 shell 环境.
然后是读取更多位于我们自己家目录中的启动文件,这些启动文件定义了用户个人的 shell 环境.

精确的启动顺序依赖于要运行的 shell 会话 类型.
有两种 shell 会话类型:一个是登录 shell 会话,另一个是非登录 shell 会话.
登录 shell 会话会提示用户输入用户名和密码;例如,我们启动一个虚拟控制台会话.
当我们在 GUI 模式下 运行终端会话时,非登录 shell 会话会出现.

登录 shell 会读取一个或多个启动文件,正如表12-2所示:
***
表12-2: 登录 shell 会话的启动文件文件 内容

+ `/etc/profile`: 应用于所有用户的全局配置脚本.
+ `~/.bash_profile`: 用户私人的启动文件.可以用来扩展或重写全局配置脚本中的设置.
+ `~/.bash_login`: 如果文件 `~/.bash_profile` 没有找到,`bash` 会尝试读取这个脚本.
+ `~/.profile`: 如果文件 `~/.bash_profile` 或文件`~/.bash_login` 都没有找到,`bash` 会试图读取这个文件.
这是基于 Debian发行版的默认设置,比方说 Ubuntu.

非登录 shell 会话会读取以下启动文件:

***
表12-3: 非登录 shell 会话的启动文件
文件 内容

+ `/etc/bash.bashrc` 应用于所有用户的全局配置文件.
+ `~/.bashrc` 用户私有的启动文件.可以用来扩展或重写全局配置脚本中的设置.

除了读取以上启动文件之外,非登录 shell 会话也会继承它们父进程的环境设置,通常是一个登录 shell.

浏览一下你的系统,看一看系统中有哪些启动文件.记住--因为上面列出的大多数文件名都以圆点开头 (意味着它们是隐藏文件),你需要使用带`-a`选项的 `ls` 命令.

在普通用户看来,文件 `~/.bashrc` 可能是最重要的启动文件,因为它几乎总是被读取.

非登录 shell 默认 会读取它,并且大多数登录 shell 的启动文件会设置成读取 `~/.bashrc` 文件.
一个启动文件的内容如果我们看一下典型的 `.bash_profile` 文件(来自于 `CentOS 4` 系统),它看起来像这样:

```bash
# .bash_profile
# Get the aliases and functions
if [ -f ~/.bashrc ]; then
. ~/.bashrc
fi
# User specific environment and startup programs
PATH=$PATH:$HOME/bin
export PATH
```

以`#`开头的行是注释,shell 不会读取它们.它们在那里是为了方便人们阅读.
第一件有趣的事情发生在第四行,伴随着以下代码:

```bash
if [ -f ~/.bashrc ]; then
. ~/.bashrc
fi
```

这叫做一个 `if` 复合命令,我们将会在第五部分详细地介绍它,现在我们对它翻译一下:

```bash
If the file ~/.bashrc exists, then
read the ~/.bashrc file.
```

我们可以看到这一小段代码就是一个登录 shell 得到 `.bashrc` 文件内容的方式.
在我们启动文件中, 下一件有趣的事与 `PATH` 变量有关系.

曾经是否感到迷惑 shell 是怎样知道到哪里找到我们在命令行中输入的命令的?
例如,当我们输入 `ls` 后, shell不会查找整个计算机系统,来找到 `/bin/ls`(`ls` 命令的绝对路径名),
它将查找一个目录列表, 这些目录包含在 `PATH` 变量中.

`PATH` 变量经常(但不总是,依赖于发行版)在`/etc/profile` 启动文件中设置,通过这些代码:

```bash
PATH=$PATH:$HOME/bin
```

修改 `PATH` 变量,添加目录 `$HOME/bin` 到目录列表的末尾.这是一个参数展开的实例, 参数展开我们在第八章中提到过.

为了说明这是怎样工作的,试试下面的例子:

```bash
$ foo="This is some"
$ echo $foo
$ foo="$foo text."
$ echo $foo
```

使用这种技巧,我们可以把文本附加到一个变量值的末尾.

通过添加字符串 `$HOME/bin` 到 `PATH` 变量值 的末尾,则目录 `$HOME/bin` 就添加到了命令搜索目录列表中.
这意味着当我们想要在自己的家目录下, 创建一个目录来存储我们自己的私人程序时,shell 已经给我们准备好了.

我们所要做的事就是把创建的目录叫做 `bin`,赶快行动吧.注意:很多发行版默认地提供了这个 `PATH` 设置.
一些基于 Debian 的发行版,例如 Ubuntu,在登录 的时候,会检测目录 `~/bin` 是否存在,若找到目录则把它动态地加到 `PATH` 变量中.

最后,有下面一行代码:

```bash
export PATH
```

这个 `export` 命令告诉 `shell` 让这个 `shell` 的子进程可以使用 PATH 变量的内容.

### 修改 shell 环境

既然我们知道了启动文件所在的位置和它们所包含的内容,我们就可以修改它们来定制自己的 shell 环境.
我们应该修改哪个文件?

按照通常的规则,添加目录到你的 PATH 变量或者是定义额外的环境变量,要把这些更改放置到 `.bash_profile`文件中(或者其替代文件中,根据不同的发行版.例如,Ubuntu 使用 `.profile` 文件). 

对于其它的更改,要放到 `.bashrc` 文件中.除非你是系统管理员,需要为系统中的所有用户修改默认设置,那么则限定你只能对自己家
目录下的文件进行修改.

当然,有可能会更改 `/etc` 目录中的文件,比如说 `profile` 文件,而且在许多情况下,修改这些文件也是明智的,但是现在,我们要 安全起见.

### 文本编辑器

为了编辑(例如,修改)shell 的启动文件,还有系统中大多数其它配置文件,我们使用一个叫做文本编辑器的程序.

文件编辑器是一个,在某些方面,类似于文字处理器的程序,比如说随着鼠标的移动, 它允许你在屏幕上编辑文字.
只有一点,文本编辑器不同于文字处理器,就是它只能支持纯文本,并且 经常包含为便于写程序而设计的特性.

文本编辑器分为两种基本类型:图形化的和基于文本的编辑器.
GNOME 和 KDE 两者都包含一些流行的 图形编辑器.GNOME 自带了一个叫做 `gedit` 的编辑器,这个编辑器通常在 `GNOME` 菜单中称为`文本编辑器`.

`KDE` 通常自带了三种编辑器,分别是(按照复杂度递增的顺序排列)`kedit`,`kwrite`,`kate`.
有许多基于文本的编辑器.你将会遇到一些流行的编辑器,它们是 `nano`,`vi`,和 `emacs`.

这个 `nano` 编辑器 是一个简单的,容易使用的编辑器,它是 `pico` 编辑器的替代物,`pico` 编辑器由 `PINE` 邮件套件提供.
`vi` 编辑器(在大多数 Linux 系统中被 `vim` 替代,`vim` 是 `Vi IMproved`的简写)是类 Unix 操作系统的传统编辑器.
`vim` 是我们下一章节的讨论对象.

`emacs` 编辑器最初由 Richard Stallman 写成.
`emacs` 是一个庞大的,多用途的, 可做任何事情的编程环境.虽然 `emacs` 很容易获取,但是大多数 Linux 系统很少默认安装它.

### 使用文本编辑器

所有的文本编辑器都可以通过在命令行中输入编辑器的名字,加上你所想要编辑的文件来唤醒.
如果所 输入的文件名不存在,编辑器则会假定你想要创建一个新文件.下面是一个使用 `gedit` 的例子:

```bash
$ gedit some_file
```

这条命令将会启动 `gedit` 文本编辑器,同时加载名为 `some_file` 的文件,如果这个文件存在的话.

所有的图形文本编辑器都相当不言自明的,所以我们在这里不会介绍它们.
反之,我们将集中精力在 我们第一个基于文本的文本编辑器,`nano`.

让我们启动 `nano`,并且编辑文件`.bashrc`.但是在我们这样 做之前,先练习一些`安全准备`.

当我们编辑一个重要的配置文件时,首先创建一个这个文件的备份总是一个不错的主意.
这样能避免我们在编辑文件时弄乱文件.创建文件 `.bashrc` 的备份文件,这样做:

```bash
$ cp .bashrc .bashrc.bak
```

备份文件的名字无关紧要,只要选择一个容易理解的文件名.
扩展名 `.bak`,`.sav`, `.old`,和`.orig` 都是用来指示备份文件的流行方法.
哦,记住 `cp` 命令会默默地重写存在的文件.现在我们有了一个备份文件,我们启动 `nano` 编辑器吧:

```bash
$ nano .bashrc
```

一旦 `nano` 编辑器启动后,我们将会得到一个像下面一样的屏幕:

```bash
GNU nano 2.0.3
....
```

注意:如果你的系统中没有安装 `nano` 编辑器,你可以用一个图形化的编辑器代替.

这个屏幕由上面的标头,中间正在编辑的文件文本和下面的命令菜单组成.
因为设计 nano 是为了 代替由电子邮件客户端提供的编辑器的,所以它相当缺乏编辑特性.

在任一款编辑器中,你应该 学习的第一个命令是怎样退出程序.
以 nano 为例,你输入 `Ctrl-x` 来退出 nano.在屏幕底层的菜单中 说明了这个命令.
`^X` 表示法意思是 `Ctrl-x`.这是控制字符的常见表示法,许多程序都使用它.

第二个我们需要知道的命令是怎样保存我们的劳动成果.对于 nano 来说是 `Ctrl-o`.
尽然我们 已经获得了这些知识,接下来我们准备做些编辑工作.

使用下箭头按键和 / 或下翻页按键,移动鼠标到文件的最后一行,然后添加以下几行到文件 `.bashrc` 中:

```bash
umask 0002
export HISTCONTROL=ignoredups
export HISTSIZE=1000
alias l.='ls -d .* --color=auto'
alias ll='ls -l --color=auto'
```

注意:你的发行版可能已经包含其中的一些行,但是复制没有任何伤害.

下表是所添加行的意义:

***
表12-4:
文本行 含义

+ `umask 0002` 设置掩码来解决共享目录的问题.
+ `export HISTCONTROL=ignoredups` 使得 shell 的历史记录功能忽略一个命令,如果相同的命令已被记录.
+ `export HISTSIZE=1000` 增加命令历史的大小,从默认的 `500` 行扩大到 `1000` 行.
+ `alias l.='ls -d .* --color=auto'` 创建一个新命令,叫做`l.`,这个命令会显示所有以点开头的目录项.
+ `alias ll='ls -l --color=auto'` 创建一个叫做`ll`的命令,这个命令会显示长格式目录列表.

正如我们所看到的,我们的许多附加条目意思直觉上并不是明显的,所以添加注释到我们的文件 `.bashrc` 中是 一个好主意,可以帮助人们理解.
使用编辑器,更改我们的附加条目,让它们看起来像这样:

```bash
# Change umask to make directory sharing easier
umask 0002
# Ignore duplicates in command history and increase
# history size to 1000 lines
export HISTCONTROL=ignoredups
export HISTSIZE=1000
# Add some helpful aliases
alias l.='ls -d .* --color=auto'
alias ll='ls -l --color=auto'
```

啊,看起来好多了! 当我们完成修改后,输入 `Ctrl-o` 来保存我们修改的 `.bashrc` 文件,输入 `Ctrl-x` 退出 nano.
为什么注释很重要?

不管什么时候你修改配置文件时,给你所做的更改加上注释都是一个好主意.
的确,明天你会记得你修改了的内容,但是六个月之后会怎样呢?帮自己一个忙,加上一些注释吧.
`Shell` 脚本和 `bash` 启动文件都使用 `#` 符号来开始注释.其它配置文件可能使用其它的符号. 
大多数配置文件都有注释.把它们作为指南.
你会经常看到配置文件中的一些行被注释掉,以此防止它们被受影响的程序使用.

这样做 是为了给读者在可能的配置选项方面一些建议,或者给出正确的配置语法实例.
例如,Ubuntu 8.04 中的 `.bashrc `文件包含这些行:

```bash
# some more ls aliases
#alias ll='ls -l'
#alias la='ls -A'
#alias l='ls -CF'
```

最后三行是有效的被注释掉的别名定义.如果你删除这三行开头的 `#` 符号,此技术程称为 `uncommenting` (不注释),这样你就会激活这些别名.
相反地,如果你在一行的开头加上 `#` 符号, 你可以注销掉这一行,但会保留它所包含的信息.

### 激活我们的修改

我们对于文件 `.bashrc` 的修改不会生效,直到我们关闭终端会话,再重新启动一个新的会话, 
因为 `.bashrc` 文件只是在刚开始启动终端会话时读取.

然而,我们可以强迫 bash 重新读取修改过的 `.bashrc` 文件,使用下面的命令:

```bash
$ source .bashrc
```

运行上面命令之后,我们就应该能够看到所做修改的效果了.试试其中一个新的别名:

```bash
$ ll
```

总结

在这一章中,我们学到了用文本编辑器来编辑配置文件的必要技巧.
随着继续学习,当我们 读到命令的手册页时,记录下命令所支持的环境变量.可能会有一个或两个宝贝.

在随后的章节里面,我们将会学习 shell 函数,一个很强大的特性,你可以把它包含在 bash 启动文件里面,以此来添加你自定制的命令宝库.

拓展阅读

bash 手册页的 INVOCATION 部分非常详细地讨论了 bash 启动文件.

## 第十三章:VI简介

有一个古老的笑话,说是一个在纽约的游客向行人打听这座城市中著名古典音乐场馆的方向:

游客: 请问一下,我怎样去卡内基音乐大厅?
行人: 练习,练习,练习!

学习 Linux 命令行,就像要成为一名造诣很深的钢琴家一样,它不是我们一下午就能学会的技能.
这需要 经历几年的勤苦练习.在这一章中,我们将介绍 vi(发音`vee eye`)文本编辑器,它是 Unix 传统中核心程序之一.

vi 因它难用的用户界面而有点声名狼藉,但是当我们看到一位大师坐在钢琴前开始演奏时,我们的确成了 伟大艺术的见证人.
虽然我们在这里不能成为 vi 大师,但是当我们学完这一章后, 我们会知道怎样在 vi 中玩`筷子`.

### 为什么我们应该学习 vi

在现在这个图形编辑器和易于使用的基于文本编辑器的时代,比如说 `nano`,为什么我们还应该学习 `vi` 呢? 下面有三个充分的理由:

1. `vi` 很多系统都预装.如果我们的系统没有图形界面,比方说一台远端服务器或者是一个 `X` 配置损坏了的本地系统,那么 `vi` 就成了我们的救星.
虽然 `nano` 逐渐流行起来,但是它 还没有普及.`POSIX`,这套 Unix 系统中程序兼容的标准,就要求系统要预装`vi`.
1. `vi` 是轻量级且执行快速的编辑器.
对于许多任务来说,启动 `vi` 比起在菜单中找到一个图形化文本编辑器,再等待编辑器数倍兆字节的数据加载而言,要容易的多.
另外,`vi` 是为了加快输入速度而设计的. 我们将会看到,当一名熟练的 `vi` 用户在编辑文件时,他或她的手从不需要移开键盘.
1. 我们不希望其他 Linux 和 Unix 用户把我们看作胆小鬼.

好吧,可能只有两个充分的理由.

### 一点儿背景介绍

第一版 `vi` 是在1976由 `Bill Joy` 写成的,当时他是加州大学伯克利分校的学生, 后来他共同创建了 `Sun` 微系统公司.

`vi` 这个名字 来源于单词`visual`,因为它打算在带有可移动光标的视频终端上编辑文本.
在发明可视化编辑器之前, 有一次只能操作一行文本的行编辑器.
为了指定一个修改,我们告诉行编辑器到一个特殊行并且说明做什么修改,比方说添加或删除文本.

视频终端(而不是基于打印机的终端,像电传打印机)的出现 ,可视化编辑成为可能.
`vi` 实际上整合了一个强大的叫做 `ex` 行编辑器, 所以我们在使用 `vi` 时能运行行编辑命令.

大多数 Linux 发行版不包含真正的 `vi`;而是自带一款高级替代版本,叫做 `vim`(它是`vi improved`的简写)由 Bram Moolenaar 开发的.`vim` 相对于传统的 Unix vi 来说,取得了实质性进步.
通常,`vim` 在 Linux 系统中是`vi`的符号链接(或别名). 在随后的讨论中,我们将会假定我们有一个叫做`vi`的程序,但它其实是`vim`.

### 启动和停止 vi

要想启动 `vi`,只要简单地输入以下命令:

```
$ vi
```

一个像这样的屏幕应该出现:

```bash
VIM - Vi Improved
....
```

正如我们之前操作 `nano` 时,首先要学的是怎样退出 `vi`.要退出 `vi`,输入下面的命令(注意冒号是命令的一部分):

```bash
:q
```

shell 提示符应该返回.如果由于某种原因,`vi` 不能退出(通常因为我们对文件做了修改,却没有保存文件).
通过给命令加上叹号,我们可以告诉 `vi` 我们真要退出 `vi`.

```bash
:q!
```

小贴示:如果你在 vi 中`迷失`了,试着按下 Esc 键两次来找到路(回到普通模式).

### vi模式

#### 兼容模式

上面实例中的启动屏幕(来自于 Ubuntu 8.04),我们看到一行文字`以 Vi 兼容的模式运行`.
这意味着vim 将以近似于 vi 常规的模式 运行,而不是 vim 的高级规范.
为了这章的目的,我们想要使用 vim 的高级规范.要想这样做, 你有几个选择:
用 `vim` 来代替 `vi`.
如果命令生效,考虑在你的`.bashrc` 文件中添加别名 `vi='vim'`.
或者,使用这个命令在你的 `vim` 配置文件中添加一行:

```bash
echo `set nocp` >> ~/.vimrc
```

不同的 Linux 发行版其 vim 软件包也迥然不同.一些发行版只是安装了 vim 的最小版本, 其默认只支持有限的 vim 特性.
当练习随后的课程时,你可能会遇到缺失的功能. 如果是这种情况,就安装 vim 的完整版.

#### 编辑模式

再次启动 `vi`,这次传递给 `vi` 一个不存在的文件名.这也是用 `vi` 创建新文件的方法.

```bash
$ rm -f foo.txt
$ vi foo.txt
```

如果一切运行正常,我们应该获得一个像这样的屏幕:

```bash
....
"foo.txt" [New File]
```

每行开头的波浪号(`~`)指示那一行不存在文本.这表示我们有一个空文件.还没有输入任何字符?
学习 vi 时,要知道的第二件非常重要的事情是(知道了如何退出 vi 后)vi 是一个模式编辑器,当 vi 启动后,进入 的是命令模式.
这种模式下,几乎每个按键都是一个命令,所以如果我们打算输入字符,vi 会发疯,弄得一团糟.

#### 插入模式

为了在文件中添加文本,首先我们必须进入插入模式.
按下`i`按键进入插入模式.之后,我们应该 在屏幕底部看到下面一行,如果 vi 运行在高级模式下(这不会出现在 vi 兼容模式下):

```bash
-- INSERT --
```

现在我们能输入一些文本了.试着输入这些文本:`The quick brown fox jumped over the lazy dog.`
按下 `Esc` 按键,退出插入模式并返回命令模式.

#### 保存我们的工作

为了保存我们刚才对文件所做的修改,我们必须在命令模式下输入一个 `ex` 命令. 
通过按下`:`键,这很容易完成.按下冒号键之后,一个冒号字符应该出现在屏幕的底部:

```bash
:
```

为了写入我们修改的文件,我们在冒号之后输入`w`字符,然后按下回车键:

```bash
:w
```

文件将会写入到硬盘,并且我们应该在屏幕底部得到一个确认信息,就像这样:

```bash
"foo.txt" [New] 1L, 46C written
```

小贴示:如果你阅读 vim 的文档,你注意到(混淆地)命令模式被叫做普通模式,`ex` 命令 叫做命令模式.当心.

#### 移动光标

当在 vi 命令模式下时,vi 提供了大量的移动命令,其中一些是与 `less` 阅读器共享的.这里 列举了一些:

***
表13-1: 光标移动按键
按键 移动光标

+ `l` or 右箭头 向右移动一个字符
+ `h` or 左箭头 向左移动一个字符
+ `j` or 下箭头 向下移动一行
+ `k` or 上箭头 向上移动一行
+ `0` (零按键) 移动到当前行的行首.
+ `^` 移动到当前行的第一个非空字符.
+ `$` 移动到当前行的末尾.
+ `w` 移动到下一个单词或标点符号的开头.
+ `W` 移动到下一个单词的开头,忽略标点符号.
+ `b` 移动到上一个单词或标点符号的开头.
+ `B` 移动到上一个单词的开头,忽略标点符号.
+ `Ctrl -f ` or `Page Down` 向下翻一页
+ `Ctrl -b` or `Page Up` 向上翻一页
+ `numberG` 移动到第 `number` 行.例如,`1G` 移动到文件的第一行.`G` 移动到文件末尾.

为什么 `h`,`j`,`k`,和 `l` 按键被用来移动光标呢?
因为在开发 vi 之初,并不是所有的视频终端都有箭头按键,
熟练的打字员可以使用规则的键盘按键来移动光标,他们的手从不需要移开键盘.

`vi` 中的许多命令都可以在前面加上一个数字,比方说上面提到的`G`命令.
在命令之前加上一个 数字,我们就可以指定命令执行的次数.例如,命令`5j`导致 vi 向下移动5行.

### 基本编辑

大多数编辑工作由一些基本的操作组成,比如说插入文本,删除文本和通过剪切和粘贴来移动文本. 

vi,当然,以它自己的独特方式来支持所有的操作.vi 也提供了有限的撤销形式.
如果我们按下`u` 按键,当在命令模式下,vi 将会撤销你所做的最后一次修改.
当我们试着执行一些基本的 编辑命令时,这会很方便.

#### 追加文本

vi 有几种不同进入插入模式的方法.我们已经使用了 `i` 命令来插入文本.
让我们返回到我们的 `foo.txt` 文件中,呆一会儿:`The quick brown fox jumped over the lazy dog.`

如果我们想要在这个句子的末尾添加一些文本,我们会发现 `i` 命令不能完成任务,因为我们不能把 光标移到行尾.

vi 提供了追加文本的命令,明智地命名为`a`命令.
如果我们把光标移动到行尾,输入`a`, 光标就会越过行尾,vi 进入插入模式.这样就允许我们添加更多的文本:
`The quick brown fox jumped over the lazy dog. It was cool.`
记住按下 `Esc` 按键来退出插入模式.

因为我们几乎总是想要在行尾附加文本,所以 vi 提供了一种快捷方式来移动到当前行的末尾,并且能添加文本.
它是`A`命令.试着用一下它,给文件添加更多行.

首先,使用`0`(零)命令,将光标移动到行首.现在我们输入`A`,来添加以下文本行:

```bash
The quick brown fox jumped over the lazy dog. It was cool.
Line 2
Line 3
```

再一次,按下 `Esc` 按键退出插入模式.

正如我们所看到的,大 `A` 命令非常有用,因为在启动插入模式之前,它把光标移到了行尾.

### 打开一行

我们插入文本的另一种方式是`打开`一行.这会在存在的两行之间插入一个空白行,并且进入插入模式. 
这种方式有两个变体:

***
表13-2: 文本行打开按键
命令 打开行

+ `o` 当前行的下方打开一行.
+ `O` 当前行的上方打开一行.

我们可以演示一下:把光标放到`Line 3`上,按下小 `o` 按键.

```bash
The quick brown fox jumped over the lazy dog. It was cool.
Line 2
Line 3
```

在第三行之下打开了新的一行,并且进入插入模式.按下 `Esc`,退出插入模式.按下 `u` 按键,撤销我们的修改.
按下大 `O` 按键在光标之上打开新的一行:

```bash
The quick brown fox jumped over the lazy dog. It was cool.
Line 2
Line 3
```

按下 `Esc` 按键,退出插入模式,并且按下 `u` 按键,撤销我们的更改.

### 删除文本

正如我们期望的,vi 提供了各种各样的方式来删除文本,所有的方式包含一个或两个按键.

首先, `x` 按键会删除光标位置的一个字符.可以在 `x` 命令之前带上一个数字,来指明要删除的字符个数.
`d` 按键更通用一些.类似 `x`命令,`d` 命令之前可以带上一个数字,来指定要执行的删除次数.
另外, `d` 命令之后总是带上一个移动命令,用来控制删除的范围.这里有些实例:

***
表13-3: 文本删除命令
命令 删除的文本

+ `x` : 当前字符
+ `3x` : 当前字符及其后的两个字符.
+ `dd` : 当前行.
+ `5dd` : 当前行及随后的四行文本.
+ `dW` : 从光标位置开始到下一个单词的开头.
+ `d$` : 从光标位置开始到当前行的行尾.
+ `d0` : 从光标位置开始到当前行的行首.
+ `d^` : 从光标位置开始到文本行的第一个非空字符.
+ `dG` : 从当前行到文件的末尾.
+ `d20G`: 从当前行到文件的第20行.

把光标放到第一行单词`It`之上.重复按下 `x` 按键直到删除剩下的部分.下一步,重复按下 `u` 按键 直到恢复原貌.

注意:真正的 vi 只是支持单层面的 `undo` 命令.vim 则支持多个层面的.

我们再次执行删除命令,这次使用 `d` 命令.还是移动光标到单词`fox`之上,按下的 `dW` 来删除单词,
按下 `d$`删除从光标位置到行尾的文本.按下 `dG` 按键删除从当前行到文件末尾的所有行.

连续按下 `u` 按键三次,来恢复删除部分.

### 剪切,复制和粘贴文本

这个 `d` 命令不仅删除文本,它还`剪切`文本.每次我们使用 `d` 命令,删除的部分被复制到一个 粘贴缓冲区中(看作剪切板).
过后我们执行小 `p` 命令把剪切板中的文本粘贴到光标位置之后, 或者是大 `P` 命令把文本粘贴到光标之前.

`y` 命令用来`拉`(复制)文本,和 `d` 命令剪切文本的方式差不多.这里有些把 `y` 命令和各种移动命令结合起来使用的实例:

***
表13-4: 复制命令
命令 复制的内容

+ `yy` 当前行.
+ `5yy` 当前行及随后的四行文本.
+ `yw`从当前光标位置到下一个单词的开头.
+ `y$` 从当前光标位置到当前行的末尾.
+ `y0` 从当前光标位置到行首.
+ `y^` 从当前光标位置到文本行的第一个非空字符.
+ `yG` 从当前行到文件末尾.
+ `y20G` 从当前行到文件的第20行.

我们试着做些复制和粘贴工作.把光标放到文本第一行,输入 `yy` 来复制当前行.
下一步,把光标移到 最后一行(`G`),输入小写的 `p` 把复制的一行粘贴到当前行的下面:

和以前一样,`u` 命令会撤销我们的修改.光标仍然位于文件的最后一行,输入大写的 `P` 命令把 所复制的文本粘贴
到当前行之上

试着执行上表中一些其他的 `y` 命令,了解小写 `p` 和大写 `P` 命令的行为.当你完成练习之后,把文件 恢复原样.

#### 连接行 

`vi` 对于行的概念相当严格.通常,不可能把光标移到行尾,再删除行尾结束符(回车符)来连接当前行和它下面的一行.

由于这个原因,vi 提供了一个特定的命令,大写的 `J`(不要与小写的 `j` 混淆了, `j` 是用来移动光标的)把行与行之间连接起来.
如果我们把光标放到 `line 3`上,输入大写的 `J` 命令,看看发生什么情况:

```bash
The quick brown fox jumped over the lazy dog. It was cool.
Line 2
Line 3 Line 4
Line 5
```

### 查找和替换

vi 有能力把光标移到搜索到的匹配项上.vi 可以在单一行或整个文件中运用这个功能. 
它也可以在有或没有用户确认的情况下实现文本替换.

#### 查找一行

`f` 命令查找一行,移动光标到下一个所指定的字符上.例如,命令 `fa` 会把光标定位到同一行中下一个出现的`a`字符上.
在一行中执行了字符的查找命令之后,通过输入分号来重复这个查找.

#### 查找整个文件

移动光标到下一个出现的单词或短语上,使用 `/` 命令.这个命令和我们之前在 `less` 程序中学到 的一样.

当你输入`/`命令后,一个`/`字符会出现在屏幕底部.下一步,输入要查找的单词或短语后, 按下回车.
光标就会移动到下一个包含所查找字符串的位置.通过 `n` 命令来重复先前的查找. 这里有个例子:

```bash
The quick brown fox jumped over the lazy dog. It was cool.
Line 2
Line 3
Line 4
Line 5
```

把光标移动到文件的第一行.输入:`/Line`然后键入回车.光标会移动到第二行.

下一步,输入 `n`,光标移到第三行.重复这个 `n` 命令,光标会 继续向下移动直到遍历了所有的匹配项.

虽然目前,我们只是使用了单词和短语来作为我们的查找 模式,但是 vi 允许使用正则表达式,一种强大的用来表示复杂文本模式的方法.

我们将会在随后 的章节里面详尽地介绍正则表达式.

#### 全局查找和替代

vi 使用 `ex` 命令来执行查找和替代操作(vi 中叫做`替换`).

把整个文件中的单词`Line`更改为`line`,我们输入以下命令:

```bash
:%s/Line/line/g
```

我们把这个命令分解为几个单独的部分,看一下每部分的含义:

***
条目 含义

+ `:`: 冒号字符运行一个 `ex` 命令.指定要操作的行数.
+ `%` :是一个快捷方式,表示从第一行到最后一行.
另外,操作范围也 可以用 `1,5` 来代替(因为我们的文件只有`5`行文本),或者用 `1,$`来代替,意思是 从第一行到文件的最后一行.`如果省略了文本行的范围,那么操作只对当前行生效.
+ `s` :指定操作.在这种情况下是,替换(查找与替代).
+ `/Line/line` :查找类型与替代文本.
+ `g` :这是`全局`的意思,意味着对文本行中所有匹配的字符串执行查找和替换操作.如果省略 g,则 只替换每个文本行中第一个匹配的字符串.

执行完查找和替代命令之后,我们的文件看起来像这样:

```bash
The quick brown fox jumped over the lazy dog. It was cool.
line 2
line 3
line 4
line 5
```

我们也可以指定一个需要用户确认的替换命令.通过添加一个`c`字符到这个命令的末尾,来完成 这个替换命令.例如:

```bash
:%s/line/Line/gc
```

这个命令会把我们的文件恢复先前的模样;然而,在执行每个替换命令之前,vi 会停下来, 通过下面的信息,来要求我们确认这个替换:
`replace with Line (y/n/a/q/l/^E/^Y)?`

括号中的每个字符都是一个可能的选择,如下所示:

***
表13-5: 替换确认按键
按键 行为

+ `y` 执行替换操作
+ `n` 跳过这个匹配的实例
+ `a` 对这个及随后所有匹配的字符串执行替换操作.
+ `q` or `esc` 退出替换操作.
+ `l` 执行这次替换并退出.l 是 `last` 的简写.

`Ctrl-e`, `Ctrl-y `分别是向下滚动和向上滚动.用于查看建议替换的上下文.
如果你输入 `y`,则执行这个替换,输入 `n` 则会导致 `vi` 跳过这个实例,而移到下一个匹配项上.

### 编辑多个文件

同时能够编辑多个文件是很有用的.你可能需要更改多个文件或者从一个文件复制内容到 另一个文件.
通过 vi,我们可以打开多个文件来编辑,只要在命令行中指定要编辑的文件名.

```bash
vi file1 file2 file3...
```

我们先退出已经存在的 vi 会话,然后创建一个新文件来编辑.输入`:wq` 来退出 vi 并且保存了所做的修改.
下一步,我们将在家目录下创建一个额外的用来玩耍的文件.通过获取从 ls 命令的输出,来创建这个文件.

```bash
$ ls -l /usr/bin > ls-output.txt
```

用 vi 来编辑我们的原文件和新创建的文件:

```bash
$ vi foo.txt ls-output.txt
```

vi 启动,我们会看到第一个文件显示出来.

#### 文件之间转换

从这个文件转到下一个文件,使用这个 ex 命令:

```bash
:n
```

回到先前的文件使用:

```bash
:N
```

当我们从一个文件移到另一个文件时,如果当前文件没有保存修改,vi 会阻止我们转换文件, 这是 vi 强制执行的政策.
在命令之后添加感叹号,可以强迫 vi 放弃修改而转换文件.

另外,上面所描述的转换方法,vim(和一些版本的 vi)也提供了一些 ex 命令,这些命令使 多个文件更容易管理.

我们可以查看正在编辑的文件列表,使用`:buffers` 命令.运行这个 命令后,屏幕顶部就会显示出一个文件列表:

```bash
:buffers
1 # "foo.txt" line 1
2 %a "ls-output.txt" line 0
Press ENTER or type command to continue
```

注意:你不能通过`:n` 或`:N` 命令在由`:e` 命令加载的文件之间进行切换.
这时要使用`:buffer` 命令, 其后加上缓冲区号码,来转换文件.

从一个文件复制内容到另一个文件当我们编辑多个文件时,经常地要复制文件的一部分到另一个正在编辑的文件.
使用之前我们学到的 拉(`yank`)和粘贴命令,这很容易完成.说明如下.

以打开的两个文件为例,首先转换到缓冲区1(foo.txt) ,输入:

```bash
:buffer 1
```

我们应该得到以下输出:

```bash
The quick brown fox jumped over the lazy dog. It was cool.
Line 2
Line 3
Line 4
Line 5
```

下一步,把光标移到第一行,并且输入 `yy` 来复制这一行.
转换到第二个缓冲区,输入:

```bash
:buffer 2
```

现在屏幕会包含一些文件列表,移动光标到第一行,输入 `p` 命令把我们从前面文件中复制的一行粘贴到这个文件中.

### 插入整个文件到另一个文件

也有可能把整个文件插入到我们所编辑的文件中.
看一下实际操作,结束 vi 会话,重新 启动一个只打开一个文件的 vi 会话:

```bash
$ vi ls-output.txt
```

移动光标到第三行,然后输入以下 `ex` 命令:

```bash
:r foo.txt
```

这个`:r` 命令(是`read`的简称)把指定的文件插入到光标位置之前.

### 保存工作

像 vi 中的其它操作一样,有几种不同的方法来保存我们所修改的文件,我们已经研究了`:w` 这个 ex 命令, 但还有几种方法,可能我们也觉得有帮助.

在命令模式下,输入 `ZZ` 就会保存并退出当前文件.同样地,`ex` 命令`:wq` 把`:w` 和`:q` 命令结合到 一起,来完成保
存和退出任务.

这个`:w `命令也可以指定可选的文件名.这个的作用就如`Save As...`.

例如,如果我们 正在编辑 `foo.txt` 文件,想要保存一个副本,叫做 `foo1.txt`,那么我们可以执行以下命令:

```bash
:w foo1.txt
```

注意:当上面的命令以一个新名字保存文件时,但它并没有更改你正在编辑的文件的名字. 
如果你继续编辑的话,你还是在编辑文件 `foo.txt`,而不是 `foo1.txt`.

### 拓展阅读

即使把这章所学的内容都加起来,我们也只是学了 vi 和 vim 的一点儿皮毛而已.这里 有一些在线的资料,你可
以用来继续 vi 学习之旅.

+ [学习 vi 编辑器][]-一本来自于 Wikipedia 的 Wikibook,是一本关于 vi 的简要指南,并介绍了几个类似 vi 的程序,其中包括 vim.
+ [The Vim Book-vim 项目][], 一本570页的书籍,包含了(几乎)所有的 vim 特性.你能在下面链接中找到它:
+ Wikipedia 上关于 [Bill Joy][] 的文章,vi 的创始人.http://en.wikipedia.org/wiki/Bill_Joy
+ Wikipedia 上关于 [Bram Moolenaar][] 的文章,vim 的作者

[Bill Joy]: http://en.wikipedia.org/wiki/Bill_Joy
[Bram Moolenaar]: http://en.wikipedia.org/wiki/Bram_Moolenaar
[学习 vi 编辑器]: http://en.wikibooks.org/wiki/Vi

## 第十四章:自定制shell提示符

在这一章中,我们将会看一下表面上看来很琐碎的细节-shell 提示符.但这会揭示一些内部 shell 和 终端仿真器的工作方式.

和 Linux 内的许多程序一样,shell 提示符是可高度配置的,虽然我们大多时候把它看作是理所当然的, 但是我们一旦学会了怎样控制它,shell 提示符是一个真正有用的设备.

### 解剖一个提示符

我们默认的提示符看起来像这样:

```bash
$
```

注意它包含我们的用户名,主机名和当前工作目录,但是它又是怎样得到这些东西的呢? 结果证明非常简单.
提示符是由一个环境变量定义的,叫做 PS1(是`prompt string one` 的简写).

我们可以通过 `echo` 命令来查看 `PS1` 的内容.

```bash
$ echo $PS1
[\u@\h \W]\$
```

注意:如果你 shell 提示符的内容和上例不是一模一样,也不必担心.
每个 Linux 发行版 定义的提示符稍微有点不同,其中一些相当异乎寻常.

从输出结果中,我们看到那个 PS1 环境变量包含一些这样的字符,比方说`中括号`,`@`符号,和`$`符号, 但是剩余部分就是个谜.

我们中一些机敏的人会把这些看作是由反斜杠转义的特殊字符,就像我们在第八章中看到的一样.

这里是一部分字符列表,在shell中 会受到特殊对待:
***
表14-1: Shell 提示符中用到的转义字符
序列 显示值

+ `\a` 以 ASCII 格式编码的铃声 . 当遇到这个转义序列时,计算机会发出嗡嗡的响声.
+ `\d` 以日,月,天格式来表示当前日期.例如,`Mon May 26.`
+ `\h` 本地机的主机名,但不带末尾的域名.
+ `\H` 完整的主机名.
+ `\j` 运行在当前 shell 会话中的工作数.
+ `\l` 当前终端设备名.
+ `\n` 一个换行符.
+ `\r` 一个回车符.
+ `\s` shell 程序名.
+ `\t` 以24小时制,`hours:minutes:seconds`的格式表示当前时间.
+ `\T` 以12小时制表示当前时间.
+ `@ `以12小时制,`AM/PM` 格式来表示当前时间.
+ `\A` 以24小时制,`hours:minutes` 格式表示当前时间.
+ `\u` 当前用户名.
+ `\v` shell 程序的版本号.
+ `\V` Version and release numbers of theshell.
+ `\w` 当前工作目录名.
+ `\W` 当前工作目录名的最后部分.
+ `!` 当前命令的历史号.
+ `#` 当前 `shell` 会话中的命令数.
+ `\$` 这会显示一个`$`字符,除非你拥有超级用户权限.在那种情况下, 它会显示一个`#`字符.
+ `\[` 标志着一系列一个或多个非打印字符的开始.这被用来嵌入非打印 的控制字符,这些字符以某种方式来操作终端仿真器,比方说移动光标或者是更改文本颜色.
+ `\]` 标志着非打印字符序列结束.

### 试试一些可替代的提示符设计

参照这个特殊字符列表,我们可以更改提示符来看一下效果.首先, 我们把原来提示符字符串的内容备份一下,以备之后恢复原貌.

为了完成备份, 我们把已有的字符串复制到另一个 shell 变量中,这个变量是我们自己创造的.

```bash
$ ps1_old="$PS1"
```

我们新创建了一个叫做 `ps1_old` 的变量,并把变量 PS1的值赋 `ps1_old`.通过 `echo` 命令可以证明 我们的确复制了 PS1的值.

```bash
$ echo $ps1_old
[\u@\h \W]\$
```

在终端会话中,我们能在任一时间复原提示符,只要简单地反向操作就可以了.

```bash
$ PS1="$ps1_old"
```

现在,我们准备开始,让我们看看如果有一个空的字符串会发生什么:

```bash
$ PS1=
```

如果我们没有给提示字符串赋值,那么我们什么也得不到.
根本没有提示字符串!提示符仍然在那里, 但是什么也不显示,正如我们所要求的那样.我们将用一个最小的提示符来代替它:

```bash
PS1="\$ "
```

这样要好一些.至少能看到我们在做什么.注意双引号中末尾的空格.当提示符显示的时候, 这个空格把美元符号和光标分离开.
在提示符中添加一个响铃:

```bash
$ PS1="\a\$ "
```

现在每次提示符显示的时候,我们应该能听到嗡嗡声.这会变得很烦人,但是它可能会 很有用,特别是当一个需要运行很长时间的命令执行完后,我们要得到通知.

下一步,让我们试着创建一个信息丰富的提示符,包含主机名和当天时间的信息.

```bash
$ PS1="\A \h \$ "
17:33 linuxbox $
```

试试其他上表中列出的转义序列,看看你能否想出精彩的新提示符.

### 添加颜色

大多数终端仿真器程序支持一定的非打印字符序列来控制,比方说字符属性(像颜色,黑体和可怕的闪烁) 和光标位置.我们会更深入地讨论光标位置,但首先我们要看一下字体颜色.

#### 混乱的终端时代

回溯到终端连接到远端计算机的时代,有许多竞争的终端品牌,它们各自工作不同.它们有着不同的键盘,以不同的方式来解释控制信息.

Unix 和类 Unix 的系统有两个 相当复杂的子系统来处理终端控制领域的混乱局面(称为 termcap 和 terminfo).
如果你 查看一下终端仿真器最底层的属性设置,可能会找到一个关于终端仿真器类型的设置.

为了努力使所有的终端都讲某种通用语言,美国国家标准委员会(ANSI)制定了 一套标准的字符序列集合来控制视频终端.
原先 DOS 用户会记得 ANSI.SYS 文件, 这是一个用来使这些编码解释生效的文件.

字符颜色是由发送到终端仿真器的一个嵌入到了要显示的字符流中的 ANSI 转义编码来控制的. 
这个控制编码不会`打印`到屏幕上,而是被终端解释为一个指令.正如我们在上表看到的字符序列, 这个 [ 和 ] 序列被用来封装这些非打印字符.

一个 `ANSI` 转义编码以一个八进制`033`(这个编码是由`退出按键`产生的)开头,其后跟着一个可选的字符属性,在之后是一个指令.

例如,把文本颜色 设为正常(attribute = 0),黑色文本的编码如下:

```bash
\033[0;30m
```

这里是一个可用的文本颜色列表.
注意这些颜色被分为两组,由应用程序粗体字符属性(1) 分化开来,这个属性可以描绘出`浅`色文本.
***
表14-2: 用转义序列来设置文本颜色
序列 文本颜色 序列 文本颜色

+ `\033[0;30m` 黑色 `\033[1;30m` 深灰色
+ `\033[0;31m` 红色 `\033[1;31m` 浅红色
+ `\033[0;32m` 绿色 `\033[1;32m` 浅绿色
+ `\033[0;33m` 棕色 `\033[1;33m` 黄色
+ `\033[0;34m` 蓝色 `\033[1;34m` 浅蓝色
+ `\033[0;35m` 粉红 `\033[1;35m` 浅粉色
+ `\033[0;36m` 青色 `\033[1;36m` 浅青色
+ `\033[0;37m` 浅灰色 `\033[1;37m` 白色

让我们试着制作一个红色提示符.我们将在开头加入转义编码:

```bash
<me@linuxbox ~>$ PS1='\[\033[0;31m\]<\u@\h \W>\$'
<me@linuxbox ~>$
```

我们的提示符生效了,但是注意我们在提示符之后输入的文本也是红色的.
为了修改这个问题, 我们将添加另一个转义编码到这个提示符的末尾来告诉终端仿真器恢复到原来的颜色.

```bash
<me@linuxbox ~>$ PS1='\[\033[0;31m\]<\u@\h \W>\$\[\033[0m\]'
<me@linuxbox ~>$
```

这看起来要好些!

也有可能要设置文本的背景颜色,使用下面列出的转义编码.这个背景颜色不支持黑体属性.
***
表14-3: 用转义序列来设置背景颜色
序列 文本颜色 序列 文本颜色

+ `\033[0;40m` 蓝色 `\033[1;44m` 黑色
+ `\033[0;41m` 红色 `\033[1;45m` 粉红
+ `\033[0;42m` 绿色 `\033[1;46m` 青色
+ `\033[0;43m` 棕色 `\033[1;47m` 浅灰色
  
我们可以创建一个带有红色背景的提示符,只是对第一个转义编码做个简单的修改.

```bash
<me@linuxbox ~>$ PS1='\[\033[0;41m\]<\u@\h \W>\$\[\033[0m\] '
<me@linuxbox ~>$
```

试试这些颜色编码,看看你能定制出怎样的提示符!

注意:除了正常的 (0) 和黑体 (1) 字符属性之外,文本也可以具有下划线 (`4`),闪烁 (`5`), 和反向 (`7`) 属性.
为了拥有好品味,然而,许多终端仿真器拒绝使用这个闪烁属性.

### 移动光标

转义编码也可以用来定位光标.

这些编码被普遍地用来,每次当提示符出现的时候,会在屏幕的不同位置比如说上面一个角落,显示一个时钟或者其它一些信息.
这里是一系列用来定位光标的转义编码:
***
表14-4: 光标移动转义序列
转义编码 行动

+ `\033[l;cH`: 把光标移到第 `l` 行,第 `c` 列.
+ `\033[nA`: 把光标向上移动 `n` 行.
+ `\033[nB`: 把光标向下移动 `n` 行.
+ `\033[nC`: 把光标向前移动 `n` 个字符.
+ `\033[nD`: 把光标向后移动 `n` 个字符.
+ `\033[2J`: 清空屏幕,把光标移到左上角(第零行,第零列).
+ `\033[K`: 清空从光标位置到当前行末的内容.
+ `\033[s`: 存储当前光标位置.
+ `\033[u`: 唤醒之前存储的光标位置.

使用上面的编码,我们将构建一个提示符,每次当这个提示符出现的时候,会在屏幕的上方画出一个包含时钟(由黄色文本渲染)的红色长条.
提示符的编码就是这个看起来令人敬畏的字符串:

```bash
$ PS1='\[\033[s\033[0;0H\033[0;41m\033[K\033[1;33m\t\033[0m\033[u\]<\u@\h \W>\$ '
```

让我们分别看一下这个字符串的每一部分所表示的意思:
***
序列 行动

+ `\[` 开始一个非打印字符序列.其真正的目的是为了让 bash 能够正确地计算提示符的大小.
如果没有这个转义字符的话,命令行编辑 功能会弄错光标的位置.
+ `\033[s` 存储光标位置.这个用来使光标能回到原来提示符的位置, 当长条和时钟显示到屏幕上方之后.
当心一些终端仿真器不推崇这个编码.
+ `\033[0;0H` 把光标移到屏幕左上角,也就是第零行,第零列的位置.
+ `\033[0;41m` 把背景设置为红色.
+ `\033[K` 清空从当前光标位置到行末的内容.因为现在 背景颜色是红色,则被清空行背
景成为红色,以此来创建长条.注意虽然一直清空到行末, 但是不改变光标位置,它仍然在屏幕左上角.
+ `\033[1;33m` 把文本颜色设为黄色.
+ `\t` 显示当前时间.虽然这是一个可`打印`的元素,但我们仍把它包含在提示符的非打印部分, 
因为我们不想 bash在计算可见提示符的真正大小时包括这个时钟在内.
+ `\033[0m` 关闭颜色设置.这对文本和背景都起作用.
+ `\033[u` 恢复到之前保存过的光标位置处.
+ `\]` 结束非打印字符序列.
+ `\$` 提示符字符串.

### 保存提示符

显然地,我们不想总是敲入那个怪物,所以我们将要把这个提示符存储在某个地方.
通过把它 添加到我们的.bashrc 文件,可以使这个提示符永久存在.为了达到目的,把下面这两行添加到`.bashrc` 文件中.

```bash
PS1='\[\033[s\033[0;0H\033[0;41m\033[K\033[1;33m\t\033[0m\033[u\]<\u@\h \W>\$ '
export PS1
```

总结归纳

不管你信不信,还有许多事情可以由提示符来完成,涉及到我们在这里没有论及的 shell 函数和脚本, 但这是一个好的开始.

并不是每个人都会花心思来更改提示符,因为通常默认的提示符就很让人满意.
但是对于我们这些喜欢思考的人们来说,shell 却提供了许多制造琐碎乐趣的机会.

拓展阅读

The Bash Prompt HOWTO 来自于 Linux 文档工程,对 shell 提示符的用途进行了相当 完备的论述.可在以下链接中得到:
http://tldp.org/HOWTO/Bash-Prompt-HOWTO/

Wikipedia 上有一篇关于 ANSI Escape Codes 的好文章:
http://en.wikipedia.org/wiki/ANSI_escape_code

## 第十五章:软件包管理

如果我们花些时间在 Linux 社区里,我们会得知很多针对, 类如在众多 Linux 发行版中哪个是最好的(等问题的)看法. 
这些集中在像这些事情上的讨论,比方说最漂亮的桌面背景(一些人不使用 Ubuntu, 只是因为 Ubuntu默认主题颜色是棕色的!)和其它的琐碎东西,经常变得非常无聊.

Linux 发行版本质量最重要的决定因素是软件包管理系统和其支持社区的持久性.
随着我们 花更多的时间在Linux 上,我们会发现它的软件园地是非常动态的.软件不断变化.
大多数一线 Linux 发行版每隔六个月发布一个新版本,并且许多独立的程序每天都会更新.

为了能和这些 如暴风雪一般多的软件保持联系,我们需要一些好工具来进行软件包管理.
软件包管理是指系统中一种安装和维护软件的方法.今天,通过从 Linux 发行版中安装的软件包, 已能满足许多人所有需要的软件.
这不同于早期的 Linux,人们需要下载和编辑源码来安装软件.编辑源码没有任何问题,事实上,拥有对源码的访问权限是 Linux 的伟大奇迹.

它赋予我们( 其它每个人)才干来检测和提高系统性能.只是若有一个预先编译好的软件包处理起来要相对 容易快速些.

这章中,我们将查看一些用于包管理的命令行工具.
虽然所有主流 Linux 发行版都 提供了强大且精致的图形管理程序来维护系统,但是学习命令行程序也非常重要.
因为它们 可以完成许多让图形化管理程序处理起来困难(或者不可能)的任务.

### 打包系统

不同的 Linux 发行版使用不同的打包系统,
一般而言,大多数发行版分别属于两大包管理技术阵营: `Debian的``.deb`,和`Red Hat`的`.rpm`.
也有一些重要的例外,比方说 `Gentoo`, `Slackware`,和 `Foresight`,但大多数会使用这两个基本系统中的一个.
***
表15-1: 主要的包管理系统家族
包管理系统 发行版 (部分列表)

+ Debian Style (.deb) Debian, Ubuntu, Xandros, Linspire
+ Red Hat Style (.rpm) Fedora, CentOS, Red Hat Enterprise Linux, OpenSUSE, Mandriva, PCLinuxOS

### 软件包管理系统是怎样工作的

在专有软件产业中找到的软件发布方法通常需要买一张安装媒介,比方说`安装盘`,然后运行 `安装向导`,来在系统中安装新的应用程序.
Linux 不是这样.Linux 系统中几乎所有的软件都可以在互联网上找到.

其中大多数软件由发行商以 包文件的形式提供,剩下的则以源码形式存在,可以手动安装.
在后面章节里,我们将会谈谈怎样 通过编译源码来安装软件.

#### 包文件

在包管理系统中软件的基本单元是包文件.
包文件是一个构成软件包的文件压缩集合.一个软件包可能由大量程序以及支持这些程序的数据文件组成.
除了安装文件之外,软件包文件也包括 关于这个包的元数据,如软件包及其内容的文本说明.
另外,许多软件包还包括预安装和安装后脚本, 这些脚本用来在软件安装之前和之后执行配置任务.

软件包文件是由软件包维护者创建的,他通常是(但不总是)一名软件发行商的雇员.
软件维护者 从上游提供商(程序作者)那里得到软件源码,然后编辑源码,创建软件包元数据以及所需要的 安装脚本.
通常,软件包维护者要把所做的修改应用到最初的源码当中,来提高此软件与 Linux 发行版其它部分的融合性.

资源库虽然某些软件项目选择执行他们自己的打包和发布策略,但是现在大多数软件包是由发行商和感兴趣 的第三方创
建的.
系统发行版的用户可以在一个中心资源库中得到这些软件包,这个资源库可能 包含了成千上万个软件包,每一个软件包都是专门为这个系统发行版建立和维护的.

因软件开发生命周期不同阶段的需要,一个系统发行版可能维护着几个不同的资源库.
例如,通常会 有一个`测试`资源库,其中包含刚刚建立的软件包,它们想要勇敢的用户来使用, 在这些软件包正式发布之前,让用户查
找错误.
系统发行版经常会有一个`开发`资源库, 这个资源库中保存着注定要包含到下一个主要版本中的半成品软件包.

一个系统发行版可能也会拥有相关第三方的资源库.

这些资源库需要支持一些因法律原因, 比如说专利或者是DRM 反规避问题,而不能被包含到发行版中的软件.
可能最著名的案例就是 那个加密的 DVD 支持,在美国这是不合法的.

第三方资源库在这些软件专利和反规避法案不 生效的国家中起作用.这些资源库通常完全地独立于
它们所支持的资源库,要想使用它们, 你必须了解它们,手动地把它们包含到软件包管理系统的配置文件中.

### 依赖性

程序很少是`孤立的`,而是依赖于其它软件组件来完成它们的工作.
常见活动,以 输入/输出为例,就是由共享程序例程来处理的.这些程序例程存储在共享库中,共享库不只 为一个程序提供基本服务.

如果一个软件包需要共享资源,比如说共享库,据说就有一个依赖. 
现代的软件包管理系统都提供了一些依赖项解析方法,以此来确保当安装软件包时,也安装了 其所有的依赖程序.

### 上层和底层软件包工具

软件包管理系统通常由两种工具类型组成:底层工具用来处理这些任务,比方说安装和删除软件包文件, 和上层工具,完成元数据搜索和依赖解析.

在这一章中,我们将看一下由 Debian 风格的系统 (比如说 `Ubuntu`,还有许多其它系统)提供的工具,还有那些由 `Red Hat` 产品使用的工具.
虽然所有基于 `Red Hat` 风格的发行版都依赖于相同的底层程序(`rpm`), 但是它们却使用不同的上层工具.我们将研究上层程序 `yum` 供我们讨论,

Fedora, `Red Hat` 企业版,和 `CentOs` 都是使用 `yum`.其它基于 `Red Hat` 风格的发行版提供了带有可比较特性的上层工具.
***
表15-2: 包管理工具
发行版 底层工具 上层工具

+ `Debian-Style` : `dpkg apt-get`, `aptitude`
+ `Fedora`, `Red Hat Enterprise Linux`,` CentOS` : `rpm yum`

### 常见软件包管理任务

通过命令行软件包管理工具可以完成许多操作.我们将会看一下最常用的工具.
注意底层工具也 支持软件包文件的创建,这个话题超出了本书叙述的范围.
在以下的讨论中,`package_name` 这个术语是指软件包实际名称,而不是指`package_file`,它是包含在软件包中的文件名.

#### 查找资源库中的软件包

使用上层工具来搜索资源库元数据,可以根据软件包的名字和说明来定位它.
***
表15-3: 软件包查找工具
风格 命令

+ Debian : `apt-get update`; `apt-cache search search_string`
+ Red Hat : `yum search search_string`

例如:搜索一个 `yum` 资源库来查找 `emacs` 文本编辑器,使用以下命令:

```bash
yum search emacs
```

#### 从资源库中安装一个软件包

上层工具允许从一个资源库中下载一个软件包,并经过完全依赖解析来安装它.
***
表15-4: 软件包安装命令
风格 命令

+ `Debian` : `apt-get update`; `apt-get install package_name`
+ `Red Hat` : `yum install package_name`

例如:从一个 `apt` 资源库来安装 `emacs` 文本编辑器:

```bash
apt-get update; apt-get install emacs
```

#### 通过软件包文件来安装软件

如果从某处而不是从资源库中下载了一个软件包文件,可以使用底层工具来直接(没有经过依赖解析)安装它.
***
表15-5: 底层软件包安装命令
风格 命令

+ `Debian`: `dpkg --install package_file`
+ `Red Hat`: `rpm -i package_file`

例如:如果已经从一个并非资源库的网站下载了软件包文件 `emacs-22.1-7.fc7-i386.rpm`, 则可以通过这种方法来安装它:

```bash
rpm -i emacs-22.1-7.fc7-i386.rpm
```

注意:因为这项技术使用底层的 `rpm` 程序来执行安装任务,所以没有运行依赖解析. 如果 `rpm` 程序发现缺少了一个依赖,则会报错并退出.

#### 卸载软件

可以使用上层或者底层工具来卸载软件.下面是可用的上层工具.
***
表15-6: 软件包删除命令
风格 命令

+ `Debian`: `apt-get remove package_name`
+ `Red Hat`: `yum erase package_name`

例如:从 `Debian` 风格的系统中卸载 `emacs` 软件包:

```bash
apt-get remove emacs
```

#### 经过资源库来更新软件包

最常见的软件包管理任务是保持系统中的软件包都是最新的.上层工具仅需一步就能完成 这个至关重要的任务.
***
表15-7: 软件包更新命令
风格 命令

+ `Debian`: `apt-get update; apt-get upgrade`
+ `Red Hat`: `yum update`

例如:更新安装在 Debian 风格系统中的软件包:

```bash
apt-get update; apt-get upgrade
```

#### 经过软件包文件来升级软件

如果已经从一个非资源库网站下载了一个软件包的最新版本,可以安装这个版本,用它来 替代先前的版本:
***
表15-8: 底层软件包升级命令
风格 命令

+ `Debian`: `dpkg --install package_file`
+ `Red Hat`: `rpm -U package_file`

例如:`把 Red Hat` 系统中所安装的 `emacs` 的版本更新到软件包文件 `emacs-22.1-7.fc7-i386.rpmz` 所包含的 `emacs` 版本.

```bash
rpm -U emacs-22.1-7.fc7-i386.rpm
```

注意:`rpm` 程序安装一个软件包和升级一个软件包所用的选项是不同的,而 `dpkg` 程序所用的选项是相同的.

#### 列出所安装的软件包

下表中的命令可以用来显示安装到系统中的所有软件包列表:
***
表15-9: 列出所安装的软件包命令
风格 命令

+ `Debian`: `dpkg --list`
+ `Red Hat` : `rpm -qa`

#### 确定是否安装了一个软件包

这些底端工具可以用来显示是否安装了一个指定的软件包:
***
表15-10: 软件包状态命令
风格 命令

+ `Debian`: `dpkg --status package_name`
+ `Red Hat`: `rpm -q package_name`

例如:确定是否` Debian` 风格的系统中安装了这个 `emacs` 软件包:

```bash
dpkg --status emacs
```

#### 显示所安装软件包的信息

如果知道了所安装软件包的名字,使用以下命令可以显示这个软件包的说明信息:
***
表15-11: 查看软件包信息命令
风格 命令

+ `Debian`: `apt-cache show package_name`
+ `Red Hat`: `yum info package_name`

例如:查看 Debian 风格的系统中 `emacs` 软件包的说明信息:

```bash
apt-cache show emacs
```

#### 查找安装了某个文件的软件包

确定哪个软件包对所安装的某个特殊文件负责,使用下表中的命令:
***
表15-12: 包文件识别命令
风格 命令

+ `Debian`: `dpkg --search file_name`
+ `Red Hat`: `rpm -qf file_name`

例如:在 `Red Hat` 系统中,查看哪个软件包安装了`/usr/bin/vim` 这个文件

```bash
rpm -qf /usr/bin/vim
```

总结归纳

在随后的章节里面,我们将探讨许多不同的程序,这些程序涵盖了广泛的应用程序领域.

虽然 大多数程序一般是默认安装的,但是若所需程序没有安装在系统中,那么我们可能需要安装额外的软件包.
通过我们新学到的(和了解的)软件包管理知识,我们应该没有问题来安装和管理所需的程序.

### Linux 软件安装谣言

从其它平台迁移过来的用户有时会成为谣言的受害者,说是在 Linux 系统中,安装软件有些 困难,并且不同系统发行版所使用的各种各样的打包方案是一个障碍.

唉,它是一个障碍, 但只是针对于那些希望把他们的秘密软件只以二进制版本发行的专有软件供应商.
Linux 软件生态系统是基于开放源代码理念.
如果一个程序开发人员发布了一款产品的 源码,那么与系统发行版相关联的开发人员可能就会把这款产品打包,并把它包含在 他们的资源库中.
这种方法保证了这款产品能很好地与系统发行版整合在一起,同时为用户 `一站式采购`软件提供了方便,从而用户不必去搜索每个产品的网站.

设备驱动差不多也以同样的方式来处理,但它们不是系统发行版资源库中单独的项目, 它们本身是 Linux 系统内核的一部分.
一般来说,在 Linux 当中没有一个类似于`驱动盘`的东西. 要不内核支持一个设备,要不不支持,反正 Linux 内核支持很多设备,事实上,多于 Windows 所支持的设备数目.

当然,如果你需要的特定设备不被支持,这里也没有安慰.当那种情况 发生时,你需要查找一下原因.
缺少驱动程序支持通常是由以下三种情况之一导致:

1. 设备太新. 因为许多硬件供应商没有积极地支持 Linux 的发展,那么编写内核 驱动代码的任务就由一些
Linux 社区来承担,而这需要花费时间.
2. 设备太奇异. 不是所有的发行版都包含每个可能的设备驱动.每个发行版会建立 它们自己的内核,因为
内核是可以配置的(这使得从手表到主机的每台设备上运行 Linux 成为可能), 这样它们可能会忽略某
个特殊设备.通过定位和下载驱动程序的源码,可能需要你自己(是的,由你) 来编译和安装驱动.这
个过程不是很难,而是参与.我们将在随后的章节里来讨论编译软件.
3. 硬件供应商隐藏信息. 他们既不发布应用于 Linux 系统的驱动程序代码, 也不发布技术文档来让某人创
建它.这意味着硬件供应商试图保密此设备的程序接口.因为我们 不想在计算机中使用保密的设备,所
以我建议删除这令人厌恶的软件, 把它和其它无用的项目都仍到垃圾桶里.

拓展阅读

花些时间来了解你所用发行版中的软件包管理系统.每个发行版都提供了关于自带软件包管理工具的文档.
另外,这里有一些更普遍的资源:

Debian GNU/Linux FAQ 关于软件包管理一章对软件包管理进行了概述:
http://www.debian.org/doc/FAQ/ch-pkgtools.en.html

RPM 工程的主页:
http://www.rpm.org

杜克大学 YUM 工程的主页:
http://linux.duke.edu/projects/yum/

了解一点儿背景知识,Wikipedia 上有一篇关于 metadata 的文章:
http://en.wikipedia.org/wiki/Metadata

## 第十六章:存储媒介

在前面章节中,我们已经从文件级别看了操作数据.在这章里,我们将从设备级别来考虑数据. 
Linux 有着令人惊奇的能力来处理存储设备,
不管是物理设备,比如说硬盘,还是网络设备,或者是 虚拟存储设备,像RAID(独立磁盘冗余阵列)和 LVM(逻辑卷管理器).

然而,这不是一本关于系统管理的书籍,我们不会试图深入地覆盖整个主题.
我们将努力做的就是 介绍一些概念和用来管理存储设备的重要命令.
我们将会使用 `USB` 闪存,`CD-RW` 光盘(因为系统配备了 `CD-ROM` 烧写器)和一张软盘(若系统这样配备),来做这章的练习题.

我们将看看以下命令:

+ `mount` – 挂载一个文件系统
+ `umount` – 卸载一个文件系统
+ `fsck` – 检查和修复一个文件系统
+ `fdisk` – 分区表控制器
+ `mkfs` – 创建文件系统
+ `fdformat` – 格式化一张软盘
+ `dd` — 把面向块的数据直接写入设备
+ `genisoimage` (`mkisofs`) – 创建一个 `ISO 9660` 的映像文件
+ `wodim` (`cdrecord`) – 把数据写入光存储媒介
+ `md5sum` – 计算 `MD5` 检验码

### 挂载和卸载存储设备

Linux 桌面系统的最新进展已经使存储设备管理对于桌面用户来说极其容易.
大多数情况下,我们 只要把设备连接到系统中,它就能工作.在过去(比如说,2004年),这个工作必须手动完成.

在非桌面系统中(例如,服务器中),这仍然是一个主要地手动过程,因为服务器经常有极端的存储需求 和复杂的配置要求.
管理存储设备的第一步是把设备连接到文件系统树中.这个过程叫做挂载,允许设备参与到操作系统中. 

回想一下第三章,类 Unix 的操作系统,像 `Linux`,维护单一文件系统树,设备连接到各个结点上. 
这与其它操作系统形成对照,比如说 `MS-DOS` 和 `Windows` 系统中,每个设备(例如 `C:\`,`D:\`,等) 保持着单独的文件系统树.

有一个叫做`/etc/fstab` 的文件可以列出系统启动时要挂载的设备(典型地,硬盘分区).
下面是 来自于 Fedora7系统的`/etc/fstab` 文件实例:

```bash
LABEL=/12   /   ext3    defaults    1 1
LABEL=/home  /home   ext3    defaults    1 2
LABEL=/boot  /boot   ext3    defaults    1 2
...
```

在这个实例中所列出的大多数文件系统是虚拟的,并不适用于我们的讨论.就我们的目的而言, 前三个是我们感兴趣的:

```bash
LABEL=/12   /   ext3    defaults    1 1
LABEL=/home  /home   ext3    defaults    1 2
LABEL=/boot  /boot   ext3    defaults    1 2
```

这些是硬盘分区.每行由六个字段组成,如下所示:
***
表16-1: `/etc/fstab` 字段
字段 内容 说明

1. `设备名`: 
传统上,这个字段包含与物理设备相关联的设备文件的实际名字,比如说`/dev/hda1`(第一个IDE 通道上第一个主设备分区).
然而今天的计算机,有很多热插拔设备(像 USB 驱动设备),许多 现代的 Linux 发行版用一个文本标签和设备相关联.
当这个设备连接到系统中时, 这个标签(当储存媒介格式化时,这个标签会被添加到存储媒介中)会被操作系统读取. 
那样的话,不管赋给实际物理设备哪个设备文件,这个设备仍然能被系统正确地识别.
2. `挂载点`: 设备所连接到的文件系统树的目录.
3. `文件系统类型` : Linux 允许挂载许多文件系统类型.大多数本地的Linux 文件系统是 `ext3`,但是也支持很多其它的,比方说 `FAT16` (msdos),`FAT32` (vfat),`NTFS`(ntfs),`CD-ROM`(iso9660),等等.
4. `选项`:  文件系统可以通过各种各样的选项来挂载.例如,挂载只读的文件系统, 或者挂载阻止执行任何程序的文件系统(一个有用的安全特性,避免删除媒介.)
5. `频率`: 一位数字,指定是否和在什么时间用 `dump` 命令来备份一个文件系统.
6. `次序`: 一位数字,指定 `fsck` 命令按照什么次序来检查文件系统.

### 查看挂载的文件系统列表

这个 `mount` 命令被用来挂载文件系统.执行这个不带参数的命令,将会显示 一系列当前挂载的文件系统:

```bash
$ mount
/dev/sda2 on / type ext3 (rw)
...
```

这个列表的格式是:`设备 on 挂载点 type 文件系统类型(可选的)`.

例如,第一行所示设备`/dev/sda2` 作为根文件系统被挂载,文件系统类型是 `ext3`,并且可读可写(这个`rw`选项).

在这个列表的底部有两个有趣的条目.
倒数第二行显示了在读卡器中的一张`2G` 的 SD 内存卡,挂载到了`/media/disk` 上.
最后一行 是一个网络设备,挂载到了`/misc/musicbox` 上.

第一次实验,我们将使用一张 `CD-ROM`.首先,在插入 `CD-ROM` 之前,我们将看一下系统:

```bash
$ mount

/dev/mapper/VolGroup00-LogVol00 on / type ext3 (rw)
proc on /proc type proc (rw)
```

这个列表来自于 `CentOS 5`系统,使用 `LVM`(逻辑卷管理器)来创建它的根文件系统.
正如许多现在的 Linux 发行版一样,这个 系统试图自动挂载插入的 `CD-ROM`.当我们插入光盘后,我们看看下面的输出:

```bash
$ mount
/dev/mapper/VolGroup00-LogVol00 on / type ext3 (rw)
proc on /proc type proc (rw)
...
/dev/hdc on /media/live-1.0.10-8 type iso9660 (ro,noexec,nosuid,
nodev,uid=500)
```

当我们插入光盘后,除了额外的一行之外,我们看到和原来一样的列表.

在列表的末尾,我们 看到 CD-ROM 已经挂载到了`/media/live-1.0.10-8`上,它的文件类型是 `iso9660(CD-ROM)`.
就我们的实验目的而言,我们对这个设备的名字感兴趣.当你自己进行这个实验时,这个 设备名字是最有可能不同的.

警告:在随后的实例中,至关重要的是你要密切注意用在你系统中的实际设备名,并且 不要使用此文本中使用的名字!
还要注意音频 CD 和 CD-ROM 不一样.音频 CD 不包含文件系统,这样在通常意义上,它就不能被挂载了.

现在我们拥有 CD-ROM 光盘的设备名字,让我们卸载这张光盘,并把它重新挂载到文件系统树 的另一个位置.
我们需要超级用户身份(使用系统相应的命令)来进行操作,并且用 `umount`(注意这个命令的拼写)来卸载光盘:

```bash
$ su -
Password:
[root@linuxbox ~]# umount /dev/hdc
```

下一步是创建一个新的光盘挂载点.简单地说,一个挂载点就是文件系统树中的一个目录.它没有什么特殊的.
它甚至不必是一个空目录,即使你把设备挂载到了一个非空目录上,你也不能看到 这个目录中原来的内容,直到你卸载这个设备.
就我们的目的而言,我们将创建一个新目录:

```bash
[root@linuxbox ~]# mkdir /mnt/cdrom
```

最后,我们把这个 CD-ROM 挂载到一个新的挂载点上.这个`-t` 选项用来指定文件系统类型:

```bash
[root@linuxbox ~]# mount -t iso9660 /dev/hdc /mnt/cdrom
```

之后,我们可以通过这个新挂载点来查看 CD-ROM 的内容:

```bash
[root@linuxbox ~]# cd /mnt/cdrom
[root@linuxbox cdrom]# ls
```

注意当我们试图卸载这个 CD-ROM 时,发生了什么事情.

```bash
[root@linuxbox cdrom]# umount /dev/hdc
umount: /mnt/cdrom: device is busy
```

这是怎么回事呢?原因是我们不能卸载一个设备,如果某个用户或进程正在使用这个设备的话.
在这种 情况下,我们把工作目录更改到了 CD-ROM 的挂载点,这个挂载点导致设备忙碌.

我们可以很容易地修复这个问题 通过把工作目录改到其它目录而不是这个挂载点.

```bash
[root@linuxbox cdrom]# cd
[root@linuxbox ~]# umount /dev/hdc
```

现在这个设备成功卸载了.

#### 为什么卸载重要

如果你看一下 `free` 命令的输出结果,这个命令用来显示关于内存使用情况的统计信息,你会看到一个统计值叫做`buffers`.
计算机系统旨在尽可能快地运行.系统运行速度的 一个阻碍是缓慢的设备.
打印机是一个很好的例子.即使最快速的打印机相比于计算机标准也 极其地缓慢.
一台计算机确实会运行地非常慢,如果它要停下来等待一台打印机打印完一页. 
在早期的个人电脑时代(多任务之前),这真是个问题.

如果你正在编辑电子表格 或者是文本文档,每次你要打印文件时,计算机都会停下来而且变得不能使用. 
计算机能以打印机可接受的最快速度把数据发送给打印机,但由于打印机不能快速地打印, 这个发送速度会非常慢.
这个问题被解决了,由于打印机缓存的出现,一个包含一些 RAM 内存 的设备,位于计算机和打印机之间.

通过打印机缓存,计算机把要打印的结果发送到这个缓存区, 数据会迅速地存储到这个 RAM 中,这样计算机就能回去工作,而不用等待.
与此同时,打印机缓存将会 以打印机可接受的速度把缓存中的数据缓慢地输出给打印机.
缓存被广泛地应用于计算机中,使其运行地更快.别让偶尔地需要读取或写入慢设备阻碍了系统的运行速度.

在实际与慢设备交互之前,操作系统会尽可能多的读取或写入数据到内存中的 存储设备里.
以 Linux 操作系统为例,你会注意到系统看似填充了多于它所需要的内存.
 这不意味着 Linux 正在使用所有的内存,它意味着 Linux 正在利用所有可用的内存,来作为缓存区.

这个缓存区允许非常快速地写入存储设备,因为写入物理设备的操作被延迟到后面进行.
同时, 这些注定要传送到设备中的数据正在内存中堆积起来.时不时地,操作系统会把这些数据 写入物理设备.

卸载一个设备需要把所有剩余的数据写入这个设备,所以设备可以被安全地移除.
如果 没有卸载设备,就移除了它,就有可能没有把注定要发送到设备中的数据输送完毕.
在某些情况下, 这些数据可能包含重要的目录更新信息,这将导致文件系统损坏,这是发生在计算机中的最坏的事情之一.

### 确定设备名称

有时很难来确定设备名称.在以前,这并不是很难.一台设备总是在某个固定的位置,也不会 挪动它.类 Unix的系统喜欢设备那样安排.
之前在开发 Unix 系统的时候,`更改一个磁盘驱动器`要用一辆 叉车从机房中移除一台如洗衣机大小的设备.

最近几年,典型的桌面硬件配置已经变得相当动态,并且 Linux 已经发展地比其祖先更加灵活.
在以上事例中,我们利用现代 Linux 桌面系统的功能来`自动地`挂载 设备,然后再确定设备名称
.
但是如果我们正在管理一台服务器或者是其它一些(这种自动挂载功能)不会 发生的环境,我们又如何能查清设备名呢?
首先,让我们看一下系统怎样来命名设备.如果我们列出目录`/dev`(所有设备的住所)的内容,我们 会看到许许多多的设备:

```bash
$ ls /dev
```

这个列表的内容揭示了一些设备命名的模式.这里有几个:
***
表16-2: Linux 存储设备名称
模式 设备

+ `/dev/fd*` 软盘驱动器
+ `/dev/hd*`老系统中的`IDE(PATA)`磁盘.
典型的主板包含两个 IDE 连接器或者是通道,每个连接器 带有一根缆线,每根缆线上有两个硬盘驱动器连接点.
缆线上的第一个驱动器叫做主设备, 第二个叫做从设备.设备名称这样安排,`/dev/hdb` 是指第一通道上的主设备名;
`/dev/hdb`是第一通道上的从设备名;`/dev/hdc`是第二通道上的主设备名,等等.末尾的数字表示 硬盘驱动器上的分区.
例如,`/dev/hda1`是指系统中第一硬盘驱动器上的第一个分区,而 `/dev/hda` 则是指整个硬盘驱动器.
+ `/dev/lp*` 打印机
+ `/dev/sd*` `SCSI` 磁盘.在最近的 Linux 系统中,内核把所有类似于磁盘的设备
(包括`PATA/SATA` 硬盘, 闪存,和 `USB` 存储设备,比如说可移动的音乐播放器和数码相机)看作 `SCSI` 磁盘. 
剩下的命名系统类似于上述所描述的旧的`/dev/hd*`命名方案.
+ `/dev/sr*` 光盘(CD/DVD 读取器和烧写器)

另外,我们经常看到符号链接比如说`/dev/cdrom`,`/dev/dvd` 和`/dev/floppy`,它们指向实际的设备文件,提供这些链接是为了方便使用.

如果你工作的系统不能自动挂载可移动的设备,你可以使用下面的技巧来决定当可移动设备连接后,它是怎样被命名的.

首先,启动一个实时查看文件`/var/log/messages` (你可能需要超级用户权限):

```bash
$ sudo tail -f /var/log/messages
# or in ubuantu
$ sudo tail -f /var/log/kern.log
```

这个文件的最后几行会被显示,然后停止.下一步,插入这个可移动的设备.

在 这个例子里,我们将使用一个16MB 闪存.瞬间,内核就会发现这个设备, 并且探测它:

```bash
Jul 23 10:07:59 linuxbox kernel:
...
sd 3:0:0:0: [sdb] 31263 512-byte
sd 3:0:0:0: [sdb] Write Protect is
...
Jul 23 10:07:59 linuxbox kernel: sdb: sdb1
Jul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: [sdb] Attached SCSI
removable disk
```

显示再次停止之后,输入 `Ctrl-c`,重新得到提示符.

输出结果的有趣部分是一再提及`[sdb]`, 这正好符和我们期望的 `SCSI` 磁盘设备名称.
知道这一点后,有两行输出变得颇具启发性:

```bash
Jul 23 10:07:59 linuxbox kernel: sdb: sdb1
Jul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: [sdb] Attached SCSI
removable disk
```

这告诉我们这个设备名称是`/dev/sdb` 指整个设备,`/dev/sdb1`是这个设备的第一分区.
正如我们所看到的,使用 Linux 系统充满了有趣的监测工作.

小贴士:使用这个 `tail -f /var/log/messages` 技巧是一个很不错的方法,可以实时观察系统的一举一动.

既然知道了设备名称,我们就可以挂载这个闪存驱动器了:

```bash
$ sudo mkdir
$ sudo mount
$ df
```

这个设备名称会保持不变只要设备与计算机保持连接并且计算机不会重新启动.

### 创建新的文件系统

假若我们想要用 Linux 本地文件系统来重新格式化这个闪存驱动器,而不是它现用的 `FAT32`系统.这涉及到两个步骤:

1. (可选的)创建一个新的分区布局,若已存在的分区不是我们喜欢的.
2. 在这个闪存上创建一个新的空的文件系统.

注意!在下面的练习中,我们将要格式化一个闪存驱动器.拿一个不包含有用数据的驱动器 作为实验品,因为它将会被擦除!
再次,请确定你指定了正确的系统设备名称.未能注意此警告可能导致你格式化(即擦除)错误的驱动器!

### 用 fdisk 命令操作分区

这个 `fdisk` 程序允许我们直接在底层与类似磁盘的设备(比如说硬盘驱动器和闪存驱动器)进行交互. 

使用这个工具可以在设备上编辑,删除,和创建分区.以我们的闪存驱动器为例, 
首先我们必须卸载它(如果需要的话),然后调用 `fdisk` 程序,如下所示:

```bash
$ sudo umount /dev/sdb1
$ sudo fdisk /dev/sdb
```

注意我们必须指定设备名称,就整个设备而言,而不是通过分区号.这个程序启动后,我们 将看到以下提示:

```bash
Command (m for help):
输入`m`会显示程序菜单:
Command action
a toggle a bootable flag
....
```

我们想要做的第一件事情是检查已存在的分区布局.输入`p`会打印出这个设备的分区表:

```bash
Command (m for help): p
Disk /dev/sdb: 16 MB, 16006656 bytes
1 heads, 31 sectors/track, 1008 cylinders
Units = cylinders of 31 * 512 = 15872 bytes
...
```

在此例中,我们看到一个 `16MB` 的设备只有一个分区(1),此分区占用了可用的1008个柱面中的1006个, 并被标识为 Windows 95 FAT32分区.

有些程序会使用这个标志符来限制一些可以对磁盘所做的操作, 但大多数情况下更改这个标志符没有危害.
然而,为了叙述方便,我们将会更改它, 以此来表明是个 Linux 分区.在更改之前,首先我们必须找到被用来识别一个 Linux 分区的 ID 号码. 

在上面列表中,我们看到 ID 号码`b`被用来指定这个已存在的分区.
要查看可用的分区类型列表, 参考之前的程序菜单.我们会看到以下选项:

`l list known partition types`

如果我们在提示符下输入`l`,就会显示一个很长的可能类型列表.
在它们之中会看到`b`为已存在分区 类型的 ID 号,而`83`是针对 Linux 系统的 ID 号.
回到之前的菜单,看到这个选项来更改分区 ID 号:

`t change a partition's system id`

我们先输入`t`,再输入新的 ID 号:

```bash
Command (m for help): t
Selected partition 1
Hex code (type L to list codes): 83
Changed system type of partition 1 to 83 (Linux)
```

这就完成了我们需要做得所有修改.
到目前为止,还没有接触这个设备(所有修改都存储在内存中, 而不是在此物理设备中),所以我们将会把修改过的分区表写入此设备,再退出.
为此,我们输入 在提示符下输入`w`:

```bash
Command (m for help): w
The partition table has been altered!
Calling ioctl() to re-read partition table.
WARNING: If you have created or modified any DOS 6.x
partitions, please see the fdisk manual page for additional
information.
Syncing disks.
$
```

如果我们已经决定保持设备不变,可在提示符下输入`q`,这将退出程序而没有写更改.
我们 可以安全地忽略这些不祥的警告信息.

### 用`mkfs`命令创建一个新的文件系统

完成了分区编辑工作(它或许是轻量级的),是时候在我们的闪存驱动器上创建一个新的文件系统了. 

为此,我们会使用 mkfs(`make file system`的简写),它能创建各种格式的文件系统. 
在此设备上创建一个 `ext3`文件系统,我们使用`-t` 选项来指定这个`ext3`系统类型,随后是我们要格式化的设备分区名称:

```bash
$ sudo mkfs -t ext3 /dev/sdb1
mke2fs 1.40.2 (12-Jul-2007)
Filesystem label=
OS type: Linux
Block size=1024 (log=0)
...
```

当 `ext3` 被选为文件系统类型时,这个程序会显示许多信息.
若把这个设备重新格式化为它最初的 FAT32文件系统,指定`vfat`作为文件系统类型:

```bash
$ sudo mkfs -t vfat /dev/sdb1
```

任何时候添加额外的存储设备到系统中时,都可以使用这个分区和格式化的过程.

虽然我们只以一个小小的闪存驱动器为例,同样的操作可以被应用到内部硬盘和其它可移动的存储设备上像 USB 硬盘驱动器.

### 测试和修复文件系统

在之前讨论文件`/etc/fstab` 时,我们会在每行的末尾看到一些神秘的数字.
每次系统启动时, 在挂载系统之前,都会按照惯例检查文件系统的完整性.

这个任务由 fsck 程序(是`file system check`的简写)完成.每个 `fstab` 项中的最后一个数字指定了设备的检查顺序.
在上面的实例中,我们看到首先检查根文件系统,然后是 `home` 和 `boot` 文件系统. 若最后一个数字 是零则相应设备不会被检查.

除了检查文件系统的完整性之外,`fsck` 还能修复受损的文件系统,其成功度依赖于损坏的数量. 
在类 Unix 的文件系统中,文件恢复的部分被放置于 `lost+found` 目录里面,位于每个文件系统的根目录下面.

检查我们的闪存驱动器(首先应该卸载),我们能执行下面的操作:

```bash
$ sudo fsck /dev/sdb1
fsck 1.40.8 (13-Mar-2008)
e2fsck 1.40.8 (13-Mar-2008)
/dev/sdb1: clean, 11/3904 files, 1661/15608 blocks
```

以我的经验,文件系统损坏情况相当罕见,除非硬件存在问题,如磁盘驱动器故障. 
在大多数系统中,系统启动阶段若探测到文件系统已经损坏了,则会导致系统停止下来, 在系统继续执行之前,会指导你运行 `fsck` 程序.

#### 什么是 fsck?

在 Unix 文化中,`fsck`这个单词往往会被用来代替一个流行的词,`fsck`和这个词共享了三个字母.
尤其适用于,当你不得不使用 `fsck` 命令时,你可能会说出这个词汇.

### 格式化软盘

对于那些还在使用配备了软盘驱动器的计算机的用户,我们也能管理这些设备.

准备一 张可用的空白软盘要分两个步骤.首先,对这张软盘执行低级格式化,然后创建一个文件系统. 
为了完成格式化,我们使用 `fdformat` 程序,同时指定软盘设备名称(通常为`/dev/fd0`):

```bash
$ sudo fdformat /dev/fd0
Double-sided, 80 tracks, 18 sec/track. Total capacity 1440 kB.
Formatting ... done
Verifying ... done
```

接下来,通过 `mkfs` 命令,给这个软盘创建一个 `FAT` 文件系统:

```bash
$ sudo mkfs -t msdos /dev/fd0
```

注意我们使用这个`msdos`文件系统类型来得到旧(小的)风格的文件分配表.
当一个软磁盘被准备好之后,则可能像其它设备一样挂载它.

### 接把数据移入/出设备

虽然我们通常认为计算机中的数据以文件形式来组织数据,也可以`原始的`形式来考虑数据. 
如果我们看一下磁盘驱动器,例如, 我们看到它由大量的数据`块`组成,而操作系统却把这些数据块看作目录和文件.
然而,如果 把磁盘驱动器简单地看成一个数据块大集合,我们就能执行有用的任务,如克隆设备.

`dd` 程序能执行此任务.它可以把数据块从一个地方复制到另一个地方.它使用独特的语法(由于历史原因):

```bash
dd if=input_file of=output_file [bs=block_size [count=blocks]]
```

比方说我们有两个相同容量的 USB 闪存驱动器,并且要精确地把第一个驱动器(中的内容) 复制给第二个.
如果连接两个设备到计算机上,它们各自被分配到设备`/dev/sdb` 和 `/dev/sdc `上,
这样我们就能通过下面的命令把第一个驱动器中的所有数据复制到第二个 驱动器中.

```bash
dd if=/dev/sdb of=/dev/sdc
```

或者,如果只有第一个驱动器被连接到计算机上,我们可以把它的内容复制到一个普通文件中供以后恢复或复制数据:

```bash
dd if=/dev/sdb of=flash_drive.img
```

警告!这个 `dd` 命令非常强大.
虽然它的名字来自于`数据定义`,有时候也把它叫做`清除磁盘` 因为用户经常会误输入 `if` 或 `of` 的规范.
在按下回车键之前,要再三检查输入与输出规范!

### 创建 CD-ROM 映像

写入一个可记录的 CD-ROM(一个 CD-R 或者是 CD-RW)由两步组成:
首先,构建一个 iso 映像文件, 这就是一个 CD-ROM 的文件系统映像,
第二步,把这个映像文件写入到 CD-ROM 媒介中.

#### 创建一个 CD-ROM 的映像拷贝

如果想要制作一张现有 CD-ROM 的 iso 映像,我们可以使用 dd 命令来读取 CD-ROM 中的所有数据块, 并把它们复制到本地文件中.

比如说我们有一张 Ubuntu CD,用它来制作一个 iso 文件,以后我们可以用它来制作更多的拷贝.
插入这张 CD 之后,确定 它的设备名称(假定是`/dev/cdrom`),然后像这样来制作 iso 文件:

```bash
dd if=/dev/cdrom of=ubuntu.iso
```

这项技术也适用于 DVD 光盘,但是不能用于音频 CD,因为它们不使用文件系统来存储数据.
对于音频 CD,看一下 `cdrdao` 命令.

#### 从文件集合中创建一个映像

创建一个包含目录内容的 iso 映像文件,我们使用 `genisoimage` 程序.

为此,我们首先创建 一个目录,这个目录中包含了要包括到此映像中的所有文件,然后执行这个 `genisoimage` 命令 来创建映像文件.

例如,如果我们已经创建一个叫做`~/cd-rom-files` 的目录,
然后用文件 填充此目录,再通过下面的命令来创建一个叫做 `cd-rom.iso` 映像文件:

```bash
genisoimage -o cd-rom.iso -R -J ~/cd-rom-files
```

`-R`选项添加元数据为 Rock Ridge 扩展,这允许使用长文件名和 POSIX 风格的文件权限.
同样地,这个`-J`选项使 Joliet 扩展生效,这样 Windows 中就支持长文件名了.

#### 一个有着其它名字的程序...

如果你看一下关于创建和烧写光介质如 CD-ROMs 和 DVD 的在线文档,你会经常碰到两个程序 叫做 `mkisofs` 和 `cdrecord` .
这些程序是流行软件包`cdrtools`的一部分,`cdrtools`由 Jorg Schilling 编写成.

在2006年春天,Schilling 先生更改了部分 cdrtools 软件包的协议,Linux 社区许多人的看法是, 这创建了一个与 `GNU GPL` 不相兼容的协议.
结果,就 `fork` 了这个 `cdrtools` 项目, 目前新项目里面包含了 `cdrecord` 和 `mkisofs` 的替代程序,分别是 `wodim` 和 `genisoimage` .

### 写入 CD-ROM 镜像

有了一个映像文件之后,我们可以把它烧写到光盘中.下面讨论的大多数命令对可 记录的 CD-ROM 和 DVD 媒
介都适用.

#### 直接挂载一个 ISO 镜像

有一个诀窍,我们可以用它来挂载 `iso` 映像文件,虽然此文件仍然在我们的硬盘中,但我们当作它已经在光盘中了.

添加 `-o loop` 选项来挂载(同时带有必需的 `-t iso9660` 文件系统类型), 挂载这个映像文件就好像它是一台设备,把它连接到文件系统树上:

```bash
mkdir /mnt/iso_image
mount -t iso9660 -o loop image.iso /mnt/iso_image
```

上面的示例中,我们创建了一个挂载点叫做`/mnt/iso_image`,然后把此映像文件 `image.iso` 挂载到挂载点上.

映像文件被挂载之后,可以把它当作,就好像它是一张 真正的 CD-ROM 或者 DVD.当不再需要此映像文件后,记得卸载它.

#### 清除一张可重写入的 CD-ROM

可重写入的 CD-RW 媒介在被重使用之前需要擦除或清空.为此,我们可以用 `wodim` 命令,指定 设备名称和清空的类型.
`wodim` 程序提供了几种清空类型.最小(且最快)的是 `fast` 类型:

```bash
wodim dev=/dev/cdrw blank=fast
```

#### 写入镜像

写入一个映像文件,我们再次使用 `wodim` 命令,指定光盘设备名称和映像文件名:

```bash
wodim dev=/dev/cdrw image.iso
```

除了设备名称和映像文件之外,`wodim` 命令还支持非常多的选项.
常见的两个选项是,`-v` 可详细输出, 和`-dao` 以 `disk-at-once` 模式写入光盘.

如果你正在准备一张光盘为的是商业复制,那么应该使用这种模式.
`wodim` 命令的默认模式是 track-at-once,这对于录制音乐很有用.

拓展阅读

我们刚才谈到了很多方法,可以使用命令行管理存储介质.看看我们所讲过命令的手册页. 一些命令支持大量的选项和操作.
此外,寻找一些如何添加硬盘驱动器到 Linux 系统(有许多)的在线教程, 这些教程也要适用于光介质存储设备.

友情提示

通常验证一下我们已经下载的 iso 映像文件的完整性很有用处.
在大多数情况下,iso 映像文件的贡献者也会提供 一个 `checksum` 文件.
一个 `checksum` 是一个神奇的数学运算的计算结果,这个数学计算会产生一个能表示目标文件内容的数字.
如果目标文件的内容即使更改一个二进制位,`checksum` 的结果将会非常不一样. 

`生成checksum` 数字的最常见方法是使用 `md5sum` 程序.当你使用 `md5sum` 程序的时候, 它会产生一个独一无二的十六进制数字:

```bash
md5sum image.iso
34e354760f9bb7fbf85c96f6a3f94ece
image.iso
```

当你下载完映像文件之后,你应该对映像文件执行 `md5sum` 命令,然后把运行结果与发行商提供的 `md5sum` 数值作比较.

除了检查下载文件的完整性之外,我们也可以使用 `md5sum` 程序验证新写入的光学存储介质. 

为此,首先我们计算映像文件的 `checksum` 数值,然后计算此光学存储介质的 `checksum` 数值. 
这种验证光学介质的技巧是限定只对 光学存储介质中包含映像文件的部分计算 checksum 数值.
通过确定映像文件所包含的 2048 个字节块的数目(光学存储介质总是以 2048 个字节块的方式写入) 并从存储介质中读取那么多的字节块,我们就可以完成操作.

某些类型的存储介质,并不需要这样做.一个以 disk-at-once 模式写入的 CD-R,可以用下面的方式检验:

```bash
md5sum /dev/cdrom
34e354760f9bb7fbf85c96f6a3f94ece
/dev/cdrom
```

许多存储介质类型,如 DVD 需要精确地计算字节块的数目.

在下面的例子中,我们检验了映像文件 `dvd-image.iso `以及 DVD 光驱中磁盘 `/dev/dvd` 文件的完整性.
你能弄明白这是怎么回事吗?

```bash
md5sum dvd-image.iso
dd if=/dev/dvd bs=2048 count=$(( $(stat -c "%s" dvd-image.iso) / 2048 )) |  md5sum
```

### 第十七章:网络系统

当谈及到网络系统层面,几乎任何东西都能由 Linux 来实现.

`Linux` 被用来创建各式各样的网络系统和装置, 包括防火墙,路由器,名称服务器,网络连接式存储设备等等.

被用来配置和操作网络系统的命令数目,就如网络系统一样巨大.我们仅仅会关注一些最经常 使用到的命令.
我们要研究的命令包括那些被用来监测网络和传输文件的命令.另外,我们 还会探讨用来远端登录的 ssh 程序.
这章会介绍:

+ `ping` - 发送 ICMP ECHO_REQUEST 软件包到网络主机
+ `traceroute` - 打印到一台网络主机的路由数据包
+ `netstat` - 打印网络连接,路由表,接口统计数据,伪装连接,和多路广播成员
+ `ftp` - 因特网文件传输程序
+ `wget` - 非交互式网络下载器
+ `ssh` - OpenSSH SSH 客户端(远程登录程序)

`pint ifconfig netstat traceroute` 等在软件包 `gnome-nettool` 里面

我们假定你已经知道了一点网络系统背景知识.
在这个因特网时代,每个计算机用户需要理解基本的网络 系统概念.为了能够充分利用这一章节的内容,我们应该熟悉以下术语:

IP (网络协议)地址
主机和域名
URI(统一资源标识符)

请查看下面的`拓展阅读`部分,有几篇关于这些术语的有用文章.

注意:一些将要讲到的命令可能(取决于系统发行版)需要从系统发行版的仓库中安装额外的软件包, 并且一些
命令可能需要超级用户权限才能执行.

### 检查和监测网络

即使你不是一名系统管理员,检查一个网络的性能和运作情况也是经常有帮助的.

```bash
ping
```

最基本的网络命令是 `ping`.
这个 `ping` 命令发送一个特殊的网络数据包,叫做`IMCP ECHO_REQUEST`,到 一台指定的主机.
大多数接收这个包的网络设备将会回复它,来允许网络连接验证.

注意:大多数网络设备(包括 Linux 主机)都可以被配置为忽略这些数据包.
通常,这样做是出于网络安全原因,部分地遮蔽一台主机免受一个潜在攻击者地侵袭.配置防火墙来阻塞 `IMCP` 流量也很普遍.

例如,看看我们能否连接到网站 linuxcommand.org(我们最喜欢的网站之一), 我们可以这样使用 `ping` 命令:

```bash
$ ping linuxcommand.org
```

一旦启动,ping 命令会持续在特定的时间间隔内(默认是一秒)发送数据包,直到它被中断:
$ ping linuxcommand.org
PING linuxcommand.org (66.35.250.210) 56(84) bytes of data.
64 bytes from vhost.sourceforge.net (66.35.250.210): icmp\_seq=1
ttl=43 time=107 ms
...
按下组合键 `Ctrl-c`,中断这个命令之后,`ping` 打印出运行统计信息.一个正常工作的网络会报告零个数据包丢失.
一个成功执行的`ping`命令会意味着网络的各个部件(网卡,电缆,路由,网关) 都处于正常的工作状态.

`tracepath`, `tracepath6` - traces path to a network host discovering MTU along this path

[什么是MTU？为什么MTU值普遍都是1500？][]

[什么是MTU？为什么MTU值普遍都是1500？]: https://developer.aliyun.com/article/222535

`Maximum Transmission Unit`,缩写`MTU`,中文名是：最大传输单元.这是哪一层网络的概念？

从下面这个表格中可以看到,在`7`层网络协议中,`MTU`是数据链路层的概念.`MTU`限制的是数据链路层的`payload`,也就是上层协议的大小,例如`IP`,`ICMP`等.

***
`OSI`中的层  功能  `TCP/IP`协议族

+ 应用层  文件传输,电子邮件,文件服务,虚拟终端  `TFTP`,`HTTP`,`SNMP`,`FTP`,`SMTP`,`DNS`,`Telnet`
+ 表示层  `数据格式化`,`代码转换`,`数据加密`  `没有协议`
+ 会话层  解除或建立与别的接点的联系  `没有协议`
+ 传输层  提供端对端的接口  `TCP`,`UDP`
+ 网络层  为数据包选择路由  `IP`,`ICMP`,`RIP`,`OSPF`,`BGP`,`IGMP`
+ 数据链路层  传输有地址的帧以及错误检测功能  `SLIP`,`CSLIP`,`PPP`,`ARP`,`RARP`,`MTU`
+ 物理层  以二进制数据形式在物理媒体上传输数据  `ISO2110`,`IEEE802`,`IEEE802.2`

```bash
traceroute
```

这个 `traceroute` 程序(`ubuntu` 使用相似的 `tracepath` 程序来代替)会显示从本地到指定主机 要经过的所有`跳数`的网络流量列表.
例如,看一下到达 `soso.com` 网站,需要经过的路由 器,我们将这样做:

```
$ traceroute soso.com
```

命令输出看起来像这样:
traceroute to soso.com (216.34.181.45), 30 hops max, 40 bytepackets
1 ipcop.localdomain (192.168.1.1) 1.066 ms 1.366 ms 1.720 ms
2 * * *
...
...

从输出结果中,我们可以看到连接测试系统到 `soso.com` 网站需要经由16个路由器.
对于那些 提供标识信息的路由器,我们能看到它们的主机名,`IP` 地址和性能数据,这些数据包括三次从本地到 此路由器的往返时间样
本.
对于那些没有提供标识信息的路由器(由于路由器配置,网络拥塞,防火墙等 方面的原因),我们会看到几个星号,正如行中所示.

### netstat

`netstat` 程序被用来检查各种各样的网络设置和统计数据.通过此命令的许多选项,我们 可以看看网络设置中的各种特性.
使用`-ie`选项,我们能够查看系统中的网络接口:

```bash
$ netstat -ie
enp0s31f6: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.218.191  netmask 255.255.255.0  broadcast 192.168.218.255
        inet6 xxxx:xxxx:1:2218:8eec:4bff:fe91:d65b  prefixlen 64  scopeid 0x0<global>
        ...
lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
    inet 127.0.0.1  netmask 255.0.0.0
    inet6 ::1  prefixlen 128  scopeid 0x10<host>
    ...
```

在上述实例中,我们看到我们的测试系统有两个网络接口.
第一个,叫做`enp0s31f6`,是 因特网接口,和第二个,叫做 `lo`,是内部回环网络接口,它是一个虚拟接口,系统用它来 `自言自语`.

当执行日常网络诊断时,要查看的重要信息是每个网络接口第一行开头出现的单词 `UP`,
说明这个网络接口已经生效,还要查看第二行中 `inet` 字段出现的有效 `IP` 地址.

对于使用 `DHCP`(动态主机配置协议)的系统,在这个字段中的一个有效 `IP` 地址则证明了 `DHCP` 工作正常.
使用这个`-r`选项会显示内核的网络路由表.这展示了系统是如何配置网络之间发送数据包的.

```bash
$ netstat -r
Kernel IP routing table
Destination     Gateway         Genmask             Flags   MSS     Window          irtt Iface
192.168.1.1         *             255.255.255.0         U        0         0          0 enp0s31f6
default             192.168.1.1         0.0.0.0                 UG          0       0 enp0s31f6
...
```

在这个简单的例子里面,我们看到了,位于防火墙之内的局域网中,一台客户端计算机的典型路由表. 

第一行显示了目的地 `192.168.1.0`.IP 地址以零结尾是指网络,而不是个人主机, 所以这个目的地意味着局域网中的任何一台主机.
下一个字段,`Gateway`, 是网关(路由器)的名字或 `IP` 地址,用它来连接当前的主机和目的地的网络. 
若这个字段显示一个星号,则表明不需要网关.

最后一行包含目的地 `default`.指的是发往任何表上没有列出的目的地网络的流量.
在我们的实例中,我们看到网关被定义为地址 `192.168.1.1` 的路由器,它应该能 知道怎样来处理目的地流量.
`netstat` 程序有许多选项,我们仅仅讨论了几个.查看 `netstat` 命令的手册,可以 得到所有选项的完整列表.

### 网络中传输文件

网络有什么用处呢?除非我们知道了怎样通过网络来传输文件.
有许多程序可以用来在网络中传送数据.我们先讨论两个命令,随后的章节里再介绍几个命令.

#### ftp

`ftp` 命令属于真正的`经典`程序之一,它的名字来源于其所使用的协议,就是文件传输协议. 

`FTP` 被广泛地用来从因特网上下载文件.
大多数,并不是所有的,网络浏览器都支持 `FTP`, 你经常可以看到它们的 URI 以协议`ftp://`开头.

在出现网络浏览器之前,`ftp` 程序已经存在了.
 `ftp` 程序可用来与 `FTP` 服务器进行通信,`FTP` 服务器就是存储文件的计算机,这些文件能够通过 网络下载和上传.

`FTP`(它的原始形式)并不是安全的,因为它会以明码形式发送帐号的姓名和密码.
这就意味着 这些数据没有加密,任何嗅探网络的人都能看到.
由于此种原因,几乎因特网中所有 `FTP` 服务器 都是匿名的.
一个匿名服务器能允许任何人使用注册名`anonymous`和无意义的密码登录系统.

在下面的例子中,我们将展示一个典型的会话,
从匿名 `FTP` 服务器-- `fileserver`的`/pub/_images/Ubuntu-8.04`的目录下,
使用 ftp 程序下载一个 Ubuntu 系统映像文件.

```bash
$ ftp fileserver
Connected to fileserver.localdomain.
...
Password:
...
ftp> cd pub/cd\_images/Ubuntu-8.04
250 Directory successfully changed.
ftp> ls
200 PORT command successful. Consider using PASV.
...
ftp> lcd Desktop
Local directory now /home/me/Desktop
ftp> get ubuntu-8.04-desktop-i386.iso
local: ubuntu-8.04-desktop-i386.iso remote: ubuntu-8.04-desktop-
i386.iso
...
ftp> bye
```

这里是对会话期间所输入命令的解释说明:

***
表17-1:
命令 意思

+ `ftp fileserver` 唤醒 `ftp` 程序,让它连接到 FTP 服务器,`fileserver` .
+ `anonymous` 登录名.输入登录名后,将出现一个密码提示.一些服务器将会接受空密码,其它一些则会要求一个邮件地址形式的密码.如果是这种情况,试着输入`user@example.com`.
+ `cd pub/cd_images/Ubuntu-8.04` 跳转到远端系统中,要下载文件所在的目录下, 注意在大多数匿名的 FTP 服务器中,支持公共下载的文件都能在目录 `pub` 下找到
+ `ls` 列出远端系统中的目录.
+ `lcd Desktop` 跳转到本地系统中的 `~/Desktop` 目录下.在实例中,`ftp` 程序在工作目录 `~`下被唤醒. 这个命令把工作目录改为`~/Desktop`
+ `get ubuntu-8.04-desktop-i386.iso` 告诉远端系统传送文件到本地.因为本地系统的工作目录 已经更改到了`~/Desktop`,所以文件会被下载到此目录.
+ `bye` 退出远端服务器,结束 ftp 程序会话.也可以使用命令 `quit` 和 `exit` .

在 `ftp>` 提示符下,输入 `help`,会显示所支持命令的列表.
使用 `ftp` 登录到一台 授予了用户足够权限的服务器中,则可以执行很多普通的文件管理任务.虽然很笨拙, 但它真能工作.

### lftp - 更好的 ftp

ftp 并不是唯一的命令行形式的 FTP 客户端.
实际上,还有很多.其中比较好(也更流行的)是 `lftp` 程序, 由Alexander Lukyanov 编写完成.

虽然 `lftp` 工作起来与传统的 ftp 程序很相似,但是它带有额外的便捷特性,
包括 多协议支持(包括 HTTP),若下载失败会自动地重新下载,后台处理,用 tab 按键来补全路径名,还有很多.

#### wget

另一个流行的用来下载文件的命令行程序是 `wget`. 

若想从网络和 FTP 网站两者上都能下载数据,`wget` 是很有用处的. 
不只能下载单个文件,多个文件,甚至整个网站都能下载.
下载 linuxcommand.org 网站的首页, 我们可以这样做:

```bash
$ wget http://linuxcommand.org/index.php
--11:02:51-- http://linuxcommand.org/index.php
=> `index.php'
Resolving linuxcommand.org... 66.35.250.210
...
11:02:51 (161.75 MB/s) - 'index.php' saved [3120]
```

这个程序的许多选项允许 `wget` 递归地下载,在后台下载文件(你退出后仍在下载),能完成未下载全的文件.
这些特性在命令手册,`better-than-average` 一节中有详尽地说明.

+ `-r` `--recursive`: Turn on recursive retrieving.    The default maximum depth is `5`.
+ `-b` `--background`:  Go to background immediately after startup.  
If no output file is specified via the `-o`, output is redirected to wget-log.
+ `-c` `--continue` Continue getting a partially-downloaded file.  
This is useful when you want to finish up a download started by a previous instance of Wget, or by another program.  For instance: `wget -c ftp://sunsite.doc.ic.ac.uk/ls-lR.Z`

### 与远程主机安全通信

通过网络来远程操控类 Unix 的操作系统已经有很多年了.

早些年,在因特网普遍推广之前,有 一些受欢迎的程序被用来登录远程主机.它们是 rlogin 和 telnet 程序.
然而这些程序,拥有和 ftp 程序 一样的致命缺点;它们以明码形式来传输所有的交流信息(包括登录命令和密码).
这使它们完全不 适合使用在因特网时代.

### ssh

为了解决这个问题,开发了一款新的协议,叫做 SSH(Secure Shell). SSH 解决了这两个基本的和远端主机安全交流的问题.

首先,它要认证远端主机是否为它 所知道的那台主机(这样就阻止了所谓的`中间人`的攻击),
其次,它加密了本地与远程主机之间 所有的通讯信息.

`SSH` 由两部分组成.

`SSH `**服务器**运行在远端主机上运行,在端口号`22`上监听将要到来的连接,而 `SSH` **客户端**用在本地系统中,用来和远端服务器通信.

大多数 Linux 发行版自带一个提供 SSH 功能的软件包,叫做 `OpenSSH`,来自于 `BSD` 项目.
一些发行版 默认包含客户端和服务器端两个软件包(例如,Red Hat),而另一些(比方说 Ubuntu)则只是提供客户端服务.
为了能让系统接受远端的连接,它必须安装 OpenSSH-server 软件包,配置,运行它,
并且(如果系统正在运行,或者是在防火墙之后) 它必须允许在 TCP 端口号上接收网络连接.

小贴示:如果你没有远端系统去连接,但还想试试这些实例,则确认安装了 OpenSSH-server 软件包 ,则可使用 localhost 作为远端主机的名字.这种情况下,计算机会和它自己创建网络连接.

用来与远端 SSH 服务器相连接的 SSH 客户端程序,顺理成章,叫做 `ssh`.
连接到远端名为 `remote-sys` 的主机,我们可以这样使用 ssh 客户端程序:

```bash
$ ssh remote-sys
The authenticity of host 'remote-sys (192.168.1.4)' can't be
established.
RSA key fingerprint is
41:ed:7a:df:23:19:bf:3c:a5:17:bc:61:b3:7f:d9:bb.
Are you sure you want to continue connecting (yes/no)?
```

第一次尝试连接,提示信息表明远端主机的真实性不能确立.这是因为客户端程序以前从没有看到过这个远端主机.
为了接受远端主机的身份验证凭据,输入`yes`.一旦建立了连接,会提示 用户输入他或她的密码:

```bash
Warning: Permanently added 'remote-sys,192.168.1.4' (RSA) to the list
of known hosts.
me@remote-sys's password:
```

成功地输入密码之后,我们会接收到远端系统的 `shell` 提示符:

```bash
Last login: Sat Aug 30 13:00:48 2008
[me@remote-sys ~]$
```

远端 `shell` 会话一直存在,直到用户输入 `exit` 命令后,则关闭了远程连接.这时候,本地的 shell 会话 恢复,本地 shell 提示符重新出现.

也有可能使用不同的用户名连接到远程系统.
例如,如果本地用户`me`,在远端系统中有一个帐号名`bob`,则用户 `me` 能够用 `bob` 帐号登录到远端系统,如下所示:

```bash
$ ssh bob@remote-sys
bob@remote-sys's password:
Last login: Sat Aug 30 13:03:21 2008
[bob@remote-sys ~]$
```

正如之前所讲到的,`ssh` 验证远端主机的真实性.如果远端主机不能成功地通过验证,则会提示以下信息:

```bash
$ ssh remote-sys
@@@@@@@@@@@@@@@@@@@@@...
WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!
@
@@@@@@@@@@@@@@@@@...
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle
attack)!
...
```

有两种可能的情形会提示这些信息.第一,某个攻击者企图制造`中间人`袭击.
这很少见, 因为每个人都知道ssh 会针对这种状况发出警告.

最有可能的罪魁祸首是远端系统已经改变了; 例如,它的操作系统或者是 SSH服务器重新安装了.
然而,为了安全起见,第一个可能性不应该 被轻易否定.当这条消息出现时,总要与远端系统的管理员查对一下.

当确定了这条消息归结为一个良性的原因之后,那么在客户端更正问题就很安全了. 
使用文本编辑器(可能是vim)从文件`~/.ssh/known_hosts` 中删除废弃的钥匙, 就解决了问题.
在上面的例子里,我们看到这样一句话:

```bash
Offending key in /home/me/.ssh/known_hosts:1
```

这意味着文件 `known_hosts` 里面某一行包含攻击型的钥匙.
从文件中删除这一行,则 ssh 程序 就能够从远端系统接受新的身份验证凭据.

除了能够在远端系统中打开一个 shell 会话,ssh 程序也允许我们在远端系统中执行单个命令. 
例如,在名为`remote-sys` 的远端主机上,执行 `free` 命令,并把输出结果显示到本地系统 shell 会话中.

```bash
$ ssh remote-sys free
me@twin4's password:
...
$
```

有可能以更有趣的方式来利用这项技术,比方说下面的例子,我们在远端系统中执行 `ls` 命令, 并把命令输出重
定向到本地系统中的一个文件里面.

```bash
$ ssh remote-sys 'ls *' > dirlist.txt
me@twin4's password:
$
```

注意,上面的例子中使用了单引号.这样做是因为我们不想路径名展开操作在本地执行 ;而希望 它在远端系统中被执行.
同样地,如果我们想要把输出结果重定向到远端主机的文件中,我们可以 把重定向操作符和文件名都放到单引号里面.

```bash
$ ssh remote-sys 'ls * > dirlist.txt'
```

### SSH 通道

当你通过 SSH 协议与远端主机建立连接的时候,其中发生的事就是在本地与远端系统之间 创建了一条加密通道.
通常,这条通道被用来把在本地系统中输入的命令安全地传输到远端系统, 同样地,再把执行结果安全地发送回来.
除了这个基本功能之外,SSH 协议允许大多数网络流量类型通过这条加密通道来被传送,在本地与远端系统之间创建某种 VPN(虚拟专用网络).

可能这个特性的最普遍使用是允许传递 `X` 窗口系统流量.

在运行着 `X` 服务器(也就是, 能显示 GUI 的机器)的系统中,有可能在远端启动和运行一个 `X` 客户端程序(一个图形化应用程序), 而应用程序的显示结果出现在本地.

这很容易完成,这里有个例子:
假设我们正坐在一台装有 Linux 系统, 叫做 `linuxbox` 的机器之前,且系统中运行着 `X` 服务器,
现在我们想要在名为 `remote-sys` 的远端系统中运行 `xload` 程序,但是要在我们的本地系统中看到这个程序的图形化输出.
我们可以这样做:

```bash
$ ssh -X remote-sys
me@remote-sys's password:
Last login: Mon Sep 08 13:23:11 2008
[me@remote-sys ~]$ xload
```

这个 `xload` 命令在远端执行之后,它的窗口就会出现在本地.
在某些系统中,你可能需要 使用 `-Y` 选项,而不是 `-X` 选项来完成这个操作.

### `scp` 和 `sftp`

这个 `OpenSSH` 软件包也包含两个程序,它们可以利用 `SSH` 加密通道在网络间复制文件. 
第一个:`scp`(安全复制)被用来复制文件,与熟悉的 `cp` 程序非常相似.
最显著的区别就是源或者目标路径名要以远端主机的名字,后跟一个**冒号**字符开头.

例如,如果我们想要 从远端系统`remote-sys`的家目录下复制文档`document.txt`,到我们本地系统的当前工作目录下, 可以这样操作:

```bash
$ scp remote-sys:document.txt .
me@remote-sys's password:
...
```

和 `ssh` 命令一样,如果你所期望的远端主机帐户与你本地系统中的不一致, 则可以把用户名添加到远端主机名的开头.

```bash
$ scp bob@remote-sys:document.txt .
```

第二个 `SSH` 文件复制命令是 `sftp`,正如其名字所示,它是 `ftp` 程序的安全替代品.
`sftp` 工作起来与我们 之前使用的 `ftp` 程序很相似;然而,它不用明码形式来传递数据,它使用加密的 `SSH` 通道.
`sftp` 有一个 重要特性强于传统的 `ftp` 命令,就是 `sftp` 不需要远端系统中运行 `FTP` 服务器.

它仅仅要求 `SSH` 服务器. 
这意味着任何一台能用 `SSH` 客户端连接的远端机器,也可当作类似于 `FTP` 的服务器来使用. 这里是一个样本会话:

```bash
$ sftp remote-sys
Connecting to remote-sys...
me@remote-sys's password:
sftp> ls
ubuntu-8.04-desktop-i386.iso
sftp> lcd Desktop
sftp> get ubuntu-8.04-desktop-i386.iso
Fetching /home/me/ubuntu-8.04-desktop-i386.iso to ubuntu-8.04-
desktop-i386.iso
/home/me/ubuntu-8.04-desktop-i386.iso 100% 699MB 7.4MB/s 01:35
sftp> bye
```

小贴示:这个 `SFTP` 协议被许多 Linux 发行版中的图形化文件管理器支持.
使用 `Nautilus` (GNOME), 或者是 `Konqueror` (KDE),我们都能在位置栏中输入以 `sftp://` 开头的 URI, 来操作存储在运行着 SSH 服务器的远端系统中的文件.

### Windows 中的 SSH 客户端

比方说你正坐在一台 Windows 机器前面,但是你需要登录到你的 Linux 服务器中,去完成 一些实际的工作,那该怎么办呢?
当然是得到一个 Windows 平台下的 SSH 客户端!有很多这样 的工具.

最流行的可能就是由 Simon Tatham 和他的团队开发的 `PuTTY` 了.
这个 `PuTTY` 程序 能够显示一个终端窗口,而且允许Windows 用户在远端主机中打开一个 SSH(或者 telnet)会话. 
这个程序也提供了 `scp` 和 `sftp` 程序的类似物.

[PuTTY链接][]

[PuTTY链接]: http://www.chiark.greenend.org.uk/~sgtatham/putty/

拓展阅读

Linux 文档项目提供了 Linux 网络管理指南,可以广泛地(虽然过时了)了解网络管理方面的知识.

[http://tldp.org/LDP/nag2/index.html][]

[http://tldp.org/LDP/nag2/index.html]: http://tldp.org/LDP/nag2/index.html

Wikipedia 上包含了许多网络方面的优秀文章.这里有一些基础的:

[http://en.wikipedia.org/wiki/Internet_protocol_address][]

[http://en.wikipedia.org/wiki/Host_name][]

[http://en.wikipedia.org/wiki/Uniform_Resource_Identifier][]

[http://en.wikipedia.org/wiki/Internet_protocol_address]: http://en.wikipedia.org/wiki/Internet_protocol_address

[http://en.wikipedia.org/wiki/Host_name]: http://en.wikipedia.org/wiki/Host_name

[http://en.wikipedia.org/wiki/Uniform_Resource_Identifier]: http://en.wikipedia.org/wiki/Uniform_Resource_Identifier

### Linux 配置SSH免密登录`ssh-keygen`

[Linux 配置SSH免密登录`ssh-keygen`][]

[Linux 配置SSH免密登录`ssh-keygen`]: https://www.jb51.net/article/163093.htm

为了在不同平台/网络主机之间的通信安全, 很多时候我们都要通过ssh进行认证. ssh认证方式主要有2种:

+ 基于口令的安全认证: 每次登录的时候都要输入用户名和密码, 由于要在网络上传输密码, 可能存在中间人攻击的风险;
+ 基于密钥的安全认证: 配置完成后就可以实现免密登录, 这种方式更加安全 -- 不需要在网络上传递口令, 只需要传输一次公钥. 
常见的`git`的`ssh`方式就是通过公钥进行认证的.

#### 配置SSH免密登录

说明: 这里演示所用的服务器操作系统是`Cent OS 7`. 我们的目标是:
`A`服务器(`172.16.22.131`) 能免密登录`B`服务器 (`172.16.22.132`).

注意: `ssh`连接是单向的, `A`能免密登录`B`, 并不能同时实现`B`能免密登录`A`.

#### 安装必需的软件

在操作之前, 先确保所需要的软件已经正常安装.

这里我们需要安装`ssh-keygen`和`ssh-copy-id`, 

#### ssh-keygen创建公钥-私钥对

(1) 在指定目录下生成rsa密钥, 并指定注释为`xxx`, 实现示例:

```bash
$ ssh-keygen -t rsa -f ~/.ssh/id_rsa -C "xxxxx"
#        ~密钥类型 ~密钥文件路径及名称 ~ 备注信息
Generating public/private rsa key pair.
Enter passphrase (empty for no passphrase): # 输入密码, 若不输入则直接回车
Enter same passphrase again: # 再次确认密码, 若不输入则直接回车
Your identification has been saved in /root/.ssh/id_rsa.
Your public key has been saved in /root/.ssh/id_rsa.pub....
```

注意: 密钥的文件名称必须是`id_xxx`, 这里的`xxx`就是`-t`参数指定的密钥类型. 
比如密钥类型是`rsa`, 那么密钥文件名就必须是`id_rsa`.

#### ssh-keygen常用参数说明:

+ `-t`: 密钥类型, 可以选择 `dsa | ecdsa | ed25519 | rsa`;
+ `-f`: 密钥目录位置, 默认为`/home/username/.ssh/`, 默认密钥文件名以`id_rsa`开头. 如果是`root`用户, 则在`/root/.ssh/id_rsa`.
+ `-C`: 指定此密钥的备注信息, 需要配置多个免密登录时, 建议补充;
+ `-N`: 指定此密钥对的密码, 如果指定此参数, 则命令执行过程中就不会出现交互确认密码的信息了.

举例说明: 同时指定目录位置、密码、注释信息, 就不需要输入回车键即可完成创建:

```bash
ssh-keygen -t rsa -f ~/.ssh/id_rsa -N shoufeng -C shoufeng
```

***
前往`~/.ssh/`目录下查看生成的文件:

```bash
# 生成的文件以test_rsa开头, test_rsa是私钥, test_rsa.pub是公钥:
$ ls
test_rsa test_rsa.pub
 
# 通过cat命令查看公钥文件: 
$ cat id_rsa.pub 
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC2JpLMqgeg9jB9ZztOCw0WMS8hdVpFxthqG1vOQTOji/cp0+8RUZl3P6NtzqfHbs0iTcY0ypIJGgx4eXyipfLvilV2bSxRINCVV73VnydVYl5gLHsrgOx+372Wovlanq7Mxq06qAONjuRD0c64xqdJFKb1OvS/nyKaOr9D8yq/FxfwKqK7TzJM0cVBAG7+YR8lc9tJTCypmNXNngiSlipzjBcnfT+5VtcFSENfuJd60dmZDzrQTxGFSS2J34CuczTQSsItmYF3DyhqmrXL+cJ2vjZWVZRU6IY7BpqJFWwfYY9m8KaL0PZ+JJuaU7ESVBXf6HJcQhYPp2bTUyff+vdV shoufeng
# 可以看到最后有一个注释内容shoufeng
```

#### `ssh-copy-id`把A的公钥发送给B

默认用法是: `ssh-copy-id root@172.16.22.132`, 

`ssh-copy-id`命令连接远程服务器时的默认端口是`22,` 当然可以指定`文件`、远程主机的`IP`、`用户`和`端口`:

```bash
# 指定要拷贝的本地文件、远程主机的IP+用户名+端口号:
$ ssh-copy-id -i ~/.ssh/id_rsa.pub -p 22 root@172.16.22.132
...
root@172.16.22.132's password: # 输入密码后, 将拷贝公钥
...
```
 
#### 在A服务器上免密登录B服务器

```bash
$ ssh root@172.16.22.132
Last login: Fri Jun 14 08:46:04 2019 from 192.168.34.16 # 登录成功
```

#### 扩展说明

其他方式发送公钥文件

上述步骤是通过`ssh-copy-id`工具发送公钥文件的, 当然我们也可以通过其他方式实现:

***
将A的公钥文件发给B:

通过`scp`命令将A服务器的公钥文件发送到B服务器的用户目录下, 因为还没有配置成功免密登录, 
所以期间需要输入B服务器对应用户的密码:

```bash
$ scp id_rsa.pub root@172.16.22.132:/root/.ssh 
root@172.16.22.132's password: 
id_rsa.pub           100% 390  0.4KB/s 00:00
```

在B上创建`authorized_keys`文件:

```bash
$ cd /root/.ssh/
$ ls
id_rsa.pub
# 通过A服务器的公钥生成"authorized_keys"文件:
$ cat id_rsa.pub >> authorized_keys
$ cat authorized_keys 
...
```

注意: 上述重定向时使用`>>`进行追加, 不要用`>`, 那会清空原有内容.

****
文件权限

为了让私钥文件和公钥文件能够在认证中起作用, 需要确保权限的正确性:

+ 对于`.ssh`目录以及其内部的公钥、私钥文件, 当前用户至少要有执行权限, 其他用户最多只能有执行权限.
+ 不要图省事设置成`777`权限: 太大的权限不安全, 而且数字签名也不支持这种权限策略.
+ 对普通用户, 建议设置成`600`权限: `chmod 600 authorized_keys id_rsa id_rsa.pub`;
+ 对root用户, 建议设置成`644`权限: `chmod 644 authorized_keys id_rsa id_rsa.pub`.

## ssh 使用

[Linux (一) SSH 使用][]

[Linux (一) SSH 使用]: https://www.jianshu.com/p/e6d308e9162f

### 安装

如果你的服务器上没有`ssh`服务的话,可以使用以下命令（一般来说购买的阿里云、腾讯云自动就装好了这个）

```bash
yum install openssh-server   (安装过程种我们可以发现openssh-clients 客户端也已经装好了)
service sshd start                 启动ssh服务
chkconfig sshd on  
```

### 连接服务器

确认安装好`ssh`并启动后,我们在windows、mac上或者其他linux服务器上通过以下命令便可以连接到这台主机

```bash
ssh root@192.168.0.105   
```

`root` 表示你连接改服务器的用户名

`192.168.0.105` 是服务器`ip`.这个`ip`不能使用内网`ip`,如果是本地虚拟机的话,可以将连接方式改为“桥接”的方式.
然后用`ifconfig`查看本机公网`ip`

### ssh 的 config 文件

先展示一下`SSH config` 语法关键字,如下五个：

+ `Host` 别名
+ `HostName` 主机名
+ `Port` 端口
+ `User` 用户名
+ `IdentityFile` 密钥文件的路径

这个config的路径在服务的位置是 `~/.ssh/config` 如果没有找到这个文件,就在`>~/.ssh/config`

那么说到这个文件我们怎么用呢？
实际上在平时的运维管理中,我们可能管理多台机器,可能是几台、十几台甚至几十上百台.
我们将这些服务器配置在config中,方便我们去连接和管理.

例如:(IdentityFile可以暂时不配置,ssh默认端口为22)

```bash
host "KatoUyi"
    HostName 192.168.0.105
    User root
    Port 22
    IdentityFile  ~/.ssh.id_rsa
    IdentitiesOnly  yes

host "NagaSiren"
    HostName 192.168.0.106
    User root
    Port 22
```

在配置了这个文件之后,我们不需要再通过 `ssh root@192.168.0.105` 这个命令去连接服务器了,
我们可以这么写连接语句 `ssh KatoUyi` .这样管理方式在一定程度上简化了我们的操作.

### ssh key (SSH安全免密码登录)

我们需要先了解一些基础
ssh key使用对称加密的方式生成公钥和私钥
私钥存放在本地 `~/.ssh` 目录下
公钥可以对外开放,放在服务器的 `~/.ssh/authorized_keys`

在上一节的操作当中,我们发现每次使用`ssh`连接服务器的时候,都要输入一次密码.
密码长了复杂了会很麻烦.我们可以使用`ssh key`去解决这个麻烦.

```bash
ssh-keygen -t rsa   # linux中生成密钥的指令
```

`windows`中生成密钥：可以在`Xshell`中也可以达到类似效果,这种方式生成了密钥之后,可以将之保存起来.
当然也可以通过其他方式例如`git bash`中用`linux`指令生成,在这里不详细描述了.

那么我们怎么使用这个生成好的`ssh key`呢.
在`Xshell`中,我们之前连接服务器,在用户认证窗口使用的是`password`密码的方式去连接,现在我们切换成`Public Key`的方式

实际上,在这个时候连接还少了很重要的一步,会出现"所选的用户密钥未在远程主机上注册.请再试一次"的错误提示.
为了达到免密码的登录过程,我们需要将公钥放置在`authorized_keys`这个文件中.

我们需要先进入linux服务器,将我们选择的这个 `id_rsa_2048.pub` 的内容放置到linux服务器的`authorized_keys`文件中.
这样的话我们再访问就可以无密码连接了.

***
在linux连接别的linux的服务器的时候怎么做到免密呢？

首先先将本机的 `rsa.pub`公钥追加到目标服务器的 `authorized_keys` 中.
然后执行以下命令

```bash
ssh-agent bash   # ssh-agent is a program to hold private keys used for public key authentication (RSA, DSA, ECDSA, Ed25519).
ssh-add  ~/.ssh/'私钥文件 ' # ssh-add adds private key identities to the authentication agent
```

完成了这个之后,就可以直接用 `ssh root@192.168.0.106`  直接连接服务器而不需要输入密码了

### ssh 安全端口

端口安全指的是尽量避免服务器的远程连接端口被不法份子知道,为此而改变默认的服务端口号的操作.

在上一节中我们知道了`SSH`的默认端口是`22`.可以修改默认端口.
对应需要修改的文件是 `/etc/ssh/sshd_config`. 我们也可以同时监听多个端口.

## 

第十八章:查找文件
因为我们已经浏览了 Linux 系统,所以一件事已经变得非常清楚:一个典型的 Linux 系统包含很多文件! 这就引
发了一个问题,“我们怎样查找东西?”。虽然我们已经知道 Linux 文件系统良好的组织结构,是源自 类 Unix
的操作系统代代传承的习俗。但是仅文件数量就会引起可怕的问题。在这一章中,我们将察看 两个用来在系统中
查找文件的工具。这些工具是:
locate – 通过名字来查找文件
find – 在目录层次结构中搜索文件
我们也将看一个经常与文件搜索命令一起使用的命令,它用来处理搜索到的文件列表:
xargs – 从标准输入生成和执行命令行
另外,我们将介绍两个命令来协助我们探索:
touch – 更改文件时间
stat – 显示文件或文件系统状态
locate - 查找文件的简单方法
这个 locate 程序快速搜索路径名数据库,并且输出每个与给定字符串相匹配的文件名。比如说, 例如,我们想
要找到所有名字以“zip”开头的程序。因为我们正在查找程序,可以假定包含 匹配程序的目录以”bin/”结
尾。因此,我们试着以这种方式使用 locate 命令,来找到我们的文件:
[me@linuxbox ~]$ locate bin/zip
locate 命令将会搜索它的路径名数据库,输出任一个包含字符串“bin/zip”的路径名:
/usr/bin/zip
/usr/bin/zipcloak
/usr/bin/zipgrep
/usr/bin/zipinfo
/usr/bin/zipnote
/usr/bin/zipsplit
如果搜索要求没有这么简单,locate 可以结合其它工具,比如说 grep 命令,来设计更加 有趣的搜索:
[me@linuxbox ~]$ locate zip | grep bin
/bin/bunzip2
本文档使用 看云 构建
- 159 -第十八章:查找文件
/bin/bzip2
/bin/bzip2recover
/bin/gunzip
/bin/gzip
/usr/bin/funzip
/usr/bin/gpg-zip
/usr/bin/preunzip
/usr/bin/prezip
/usr/bin/prezip-bin
/usr/bin/unzip
/usr/bin/unzipsfx
/usr/bin/zip
/usr/bin/zipcloak
/usr/bin/zipgrep
/usr/bin/zipinfo
/usr/bin/zipnote
/usr/bin/zipsplit
这个 locate 程序已经存在了很多年了,它有几个不同的变体被普遍使用着。在现在 Linux 发行版中发现的两个
最常见的变体是 slocate 和 mlocate,但是通常它们被名为 locate 的 符号链接访问。不同版本的 locate 命令拥
有重复的选项集合。一些版本包括正则表达式 匹配(我们会在下一章中讨论)和通配符支持。查看 locate 命令
的手册,从而确定安装了 哪个版本的 locate 程序。
locate 数据库来自何方?
你可能注意到了,在一些发行版中,仅仅在系统安装之后,locate 不能工作, 但是如果你第二天再试一下,
它就工作正常了。怎么回事呢?locate 数据库由另一个叫做 updatedb 的程序创建。通常,这个程序作为一
个 cron 工作例程周期性运转;也就是说,一个任务 在特定的时间间隔内被 cron 守护进程执行。大多数装有
locate 的系统会每隔一天运行一回 updatedb 程序。因为数据库不能被持续地更新,所以当使用 locate 时,
你会发现 目前最新的文件不会出现。为了克服这个问题,可以手动运行 updatedb 程序, 更改为超级用户身
份,在提示符下运行 updatedb 命令。
find - 查找文件的复杂方式
locate 程序只能依据文件名来查找文件,而 find 程序能基于各种各样的属性, 搜索一个给定目录(以及它的子
目录),来查找文件。我们将要花费大量的时间学习 find 命令,因为 它有许多有趣的特性,当我们开始在随后
的章节里面讨论编程概念的时候,我们将会重复看到这些特性。
find 命令的最简单使用是,搜索一个或多个目录。例如,输出我们的家目录列表。
[me@linuxbox ~]$ find ~
对于最活跃的用户帐号,这将产生一张很大的列表。因为这张列表被发送到标准输出, 我们可以把这个列表管道
本文档使用 看云 构建
- 160 -第十八章:查找文件
到其它的程序中。让我们使用 wc 程序来计算出文件的数量:
[me@linuxbox ~]$ find ~ | wc -l
47068
哇,我们一直很忙!find 命令的美丽所在就是它能够被用来识别符合特定标准的文件。它通过 (有点奇怪)应用
选项,测试条件,和操作来完成搜索。我们先看一下测试条件。
Tests
比如说我们想要目录列表。我们可以添加以下测试条件:
[me@linuxbox ~]$ find ~ -type d | wc -l
1695
添加测试条件-type d 限制了只搜索目录。相反地,我们使用这个测试条件来限定搜索普通文件:
[me@linuxbox ~]$ find ~ -type f | wc -l
38737
这里是 find 命令支持的普通文件类型测试条件:
表18-1: find 文件类型
文件类型 描述
b 块设备文件
c 字符设备文件
d 目录
f 普通文件
l 符号链接
我们也可以通过加入一些额外的测试条件,根据文件大小和文件名来搜索:让我们查找所有文件名匹配 通配符模
式“*.JPG”和文件大小大于1M 的文件:
[me@linuxbox ~]$ find ~ -type f -name "\*.JPG" -size +1M | wc -l
840
在这个例子里面,我们加入了 -name 测试条件,后面跟通配符模式。注意,我们把它用双引号引起来, 从而阻
止 shell 展开路径名。紧接着,我们加入 -size 测试条件,后跟字符串“+1M”。开头的加号表明 我们正在寻找
文件大小大于指定数的文件。若字符串以减号开头,则意味着查找小于指定数的文件。 若没有符号意味着“精确
本文档使用 看云 构建
- 161 -第十八章:查找文件
匹配这个数”。结尾字母“M”表明测量单位是兆字节。下面的字符可以 被用来指定测量单位:
表18-2: find 大小单位
字符 单位
b 512 个字节块。如果没有指定单位,则
这是默认值。
c 字节
w 两个字节的字
k 千字节(1024个字节单位)
M 兆字节(1048576个字节单位)
G 千兆字节(1073741824个字节单位)
find 命令支持大量不同的测试条件。下表是列出了一些常见的测试条件。请注意,在需要数值参数的 情况下,可
以应用以上讨论的“+”和”-“符号表示法:
表18-3: find 测试条件
测试条件 描述
-cmin n 匹配的文件和目录的内容或属性最后修
改时间正好在 n 分钟之前。 指定少于
n 分钟之前,使用 -n,指定多于 n 分
钟之前,使用 +n。
-cnewer file 匹配的文件和目录的内容或属性最后修
改时间早于那些文件。
-ctime n 匹配的文件和目录的内容和属性最后修
改时间在 n*24小时之前。
-empty 匹配空文件和目录。
-group name 匹配的文件和目录属于一个组。组可以
用组名或组 ID 来表示。
-iname pattern 就像-name 测试条件,但是不区分大
小写。
-inum n 匹配的文件的 inode 号是 n。这对于找
到某个特殊 inode 的所有硬链接很有
帮助。
-mmin n 匹配的文件或目录的内容被修改于 n 分
钟之前。
-mtime n 匹配的文件或目录的内容被修改于
n*24小时之前。
-name pattern
本文档使用 看云 构建
用指定的通配符模式匹配的文件和目
- 162 -第十八章:查找文件
-name pattern 录。
-newer file 匹配的文件和目录的内容早于指定的文
件。当编写 shell 脚本,做文件备份
时,非常有帮助。 每次你制作一个备
份,更新文件(比如说日志),然后使
用 find 命令来决定自从上次更新,哪
一个文件已经更改了。
-nouser 匹配的文件和目录不属于一个有效用
户。这可以用来查找 属于删除帐户的文
件或监测攻击行为。
-nogroup 匹配的文件和目录不属于一个有效的
组。
-perm mode 匹配的文件和目录的权限已经设置为指
定的 mode。mode 可以用 八进制或
符号表示法。
-samefile name 相似于-inum 测试条件。匹配和文件
name 享有同样 inode 号的文件。
-size n 匹配的文件大小为 n。
-type c 匹配的文件类型是 c。
-user name 匹配的文件或目录属于某个用户。这个
用户可以通过用户名或用户 ID 来表
示。
这不是一个完整的列表。find 命令手册有更详细的说明。
操作符
即使拥有了 find 命令提供的所有测试条件,我们还需要一个更好的方式来描述测试条件之间的逻辑关系。例如,
如果我们需要确定是否一个目录中的所有的文件和子目录拥有安全权限,怎么办呢? 我们可以查找权限不是
0600的文件和权限不是0700的目录。幸运地是,find 命令提供了 一种方法来结合测试条件,通过使用逻辑操作
符来创建更复杂的逻辑关系。 为了表达上述的测试条件,我们可以这样做:
[me@linuxbox ~]$ find ~ \( -type f -not -perm 0600 \) -or \( -type d -not -perm
0700 \)
呀!这的确看起来很奇怪。这些是什么东西?实际上,这些操作符没有那么复杂,一旦你知道了它们的原理。 这
里是操作符列表:
表18-4: find 命令的逻辑操作符
本文档使用 看云 构建
- 163 -第十八章:查找文件
-and 如果操作符两边的测试条件都是真,则
匹配。可以简写为 -a。 注意若没有使
用操作符,则默认使用 -and。
-or 若操作符两边的任一个测试条件为真,
则匹配。可以简写为 -o。
-not 若操作符后面的测试条件是真,则匹
配。可以简写为一个感叹号(!)。
() 把测试条件和操作符组合起来形成更大
的表达式。这用来控制逻辑计算的优先
级。 默认情况下,find 命令按照从左
到右的顺序计算。经常有必要重写默认
的求值顺序,以得到期望的结果。 即使
没有必要,有时候包括组合起来的字
符,对提高命令的可读性是很有帮助
的。注意 因为圆括号字符对于 shell 来
说有特殊含义,所以在命令行中使用它
们的时候,它们必须 用引号引起来,才
能作为实参传递给 find 命令。通常反
斜杠字符被用来转义圆括号字符。
通过这张操作符列表,我们重建 find 命令。从最外层看,我们看到测试条件被分为两组,由一个 -or 操作符分
开:
( expression 1 ) -or ( expression 2 )
这很有意义,因为我们正在搜索具有不同权限集合的文件和目录。如果我们文件和目录两者都查找, 那为什么要
用 -or 来代替 -and 呢?因为 find 命令扫描文件和目录时,会计算每一个对象,看看它是否 匹配指定的测试条
件。我们想要知道它是具有错误权限的文件还是有错误权限的目录。它不可能同时符合这 两个条件。所以如果展
开组合起来的表达式,我们能这样解释它:
( file with bad perms ) -or ( directory with bad perms )
下一个挑战是怎样来检查“错误权限”,这个怎样做呢?我们不从这个角度做。我们将测试 “不是正确权限”,
因为我们知道什么是“正确权限”。对于文件,我们定义正确权限为0600, 目录则为0711。测试具有“不正
确”权限的文件表达式为:
-type f -and -not -perms 0600
对于目录,表达式为:
本文档使用 看云 构建
- 164 -第十八章:查找文件
对于目录,表达式为:
-type d -and -not -perms 0700
正如上述操作符列表中提到的,这个-and 操作符能够被安全地删除,因为它是默认使用的操作符。 所以如果我
们把这两个表达式连起来,就得到最终的命令:
find ~ ( -type f -not -perms 0600 ) -or ( -type d -not -perms 0700 )
然而,因为圆括号对于 shell 有特殊含义,我们必须转义它们,来阻止 shell 解释它们。在圆括号字符 之前加上
一个反斜杠字符来转义它们。
逻辑操作符的另一个特性要重点理解。比方说我们有两个由逻辑操作符分开的表达式:
expr1 -operator expr2
在所有情况下,总会执行表达式 expr1;然而由操作符来决定是否执行表达式 expr2。这里 列出了它是怎样工作
的:
表18-5: find AND/OR 逻辑
expr1 的结果 操作符 expr2 is...
真 -and 总要执行
假 -and 从不执行
真 -or 从不执行
假 -or 总要执行
为什么这会发生呢?这样做是为了提高性能。以 -and 为例,我们知道表达式 expr1 -and expr2 不能为真,如
果表达式 expr1的结果为假,所以没有必要执行 expr2。同样地,如果我们有表达式 expr1 -or expr2,并且表
达式 expr1的结果为真,那么就没有必要执行 expr2,因为我们已经知道 表达式 expr1 -or expr2 为真。好,这
样会执行快一些。为什么这个很重要? 它很重要是因为我们能依靠这种行为来控制怎样来执行操作。我们会很快
看到...
预定义的操作
让我们做一些工作吧!从 find 命令得到的结果列表很有用处,但是我们真正想要做的事情是操作列表 中的某些
条目。幸运地是,find 命令允许基于搜索结果来执行操作。有许多预定义的操作和几种方式来 应用用户定义的操
作。首先,让我们看一下几个预定义的操作:
表18-6: 几个预定义的 find 命令操作
本文档使用 看云 构建
- 165 -第十八章:查找文件
-delete 删除当前匹配的文件。
-ls 对匹配的文件执行等同的 ls -dils 命
令。并将结果发送到标准输出。
-print 把匹配文件的全路径名输送到标准输
出。如果没有指定其它操作,这是 默认
操作。
-quit 一旦找到一个匹配,退出。
和测试条件一样,还有更多的操作。查看 find 命令手册得到更多细节。在第一个例子里, 我们这样做:
find ~
这个命令输出了我们家目录中包含的每个文件和子目录。它会输出一个列表,因为会默认使用-print 操作 ,如果
没有指定其它操作的话。因此我们的命令也可以这样表述:
find ~ -print
我们可以使用 find 命令来删除符合一定条件的文件。例如,来删除扩展名为“.BAK”(这通常用来指定备份文
件) 的文件,我们可以使用这个命令:
find ~ -type f -name '*.BAK' -delete
在这个例子里面,用户家目录(和它的子目录)下搜索每个以.BAK 结尾的文件名。当找到后,就删除它们。
警告:当使用 -delete 操作时,不用说,你应该格外小心。首先测试一下命令, 用 -print 操作代替 -delete,来
确认搜索结果。
在我们继续之前,让我们看一下逻辑运算符是怎样影响操作的。考虑以下命令:
find ~ -type f -name '*.BAK' -print
正如我们所见到的,这个命令会查找每个文件名以.BAK (-name ‘*.BAK’) 结尾的普通文件 (-type f), 并把每
个匹配文件的相对路径名输出到标准输出 (-print)。然而,此命令按这个方式执行的原因,是 由每个测试和操作
之间的逻辑关系决定的。记住,在每个测试和操作之间会默认应用 -and 逻辑运算符。 我们也可以这样表达这个
命令,使逻辑关系更容易看出:
find ~ -type f -and -name '*.BAK' -and -print
本文档使用 看云 构建
- 166 -第十八章:查找文件
当命令被充分表达之后,让我们看看逻辑运算符是如何影响其执行的:
测试/行为 只有...的时候,才被执行
-print 只有 -type f and -name '*.BAK'为真
的时候
-name ‘*.BAK’ 只有 -type f 为真的时候
-type f 总是被执行,因为它是与 -and 关系中
的第一个测试/行为。
因为测试和行为之间的逻辑关系决定了哪一个会被执行,我们知道测试和行为的顺序很重要。例如, 如果我们重
新安排测试和行为之间的顺序,让 -print 行为是第一个,那么这个命令执行起来会截然不同:
find ~ -print -and -type f -and -name '*.BAK'
这个版本的命令会打印出每个文件(-print 行为总是为真),然后测试文件类型和指定的文件扩展名。
用户定义的行为
除了预定义的行为之外,我们也可以唤醒随意的命令。传统方式是通过 -exec 行为。这个 行为像这样工作:
-exec command {} ;
这里的 command 就是指一个命令的名字,{}是当前路径名的符号表示,分号是要求的界定符 表明命令结束。这
里是一个使用 -exec 行为的例子,其作用如之前讨论的 -delete 行为:
-exec rm '{}' ';'
重述一遍,因为花括号和分号对于 shell 有特殊含义,所以它们必须被引起来或被转义。
也有可能交互式地执行一个用户定义的行为。通过使用 -ok 行为来代替 -exec,在执行每个指定的命令之前, 会
提示用户:
find ~ -type f -name 'foo*' -ok ls -l '{}' ';'
< ls ... /home/me/bin/foo > ? y
-rwxr-xr-x 1 me
me 224 2007-10-29 18:44 /home/me/bin/foo
< ls ... /home/me/foo.txt > ? y
-rw-r--r-- 1 me
me 0 2008-09-19 12:53 /home/me/foo.txt
在这个例子里面,我们搜索以字符串“foo”开头的文件名,并且对每个匹配的文件执行 ls -l 命令。 使用 -ok 行
为,会在 ls 命令执行之前提示用户。
本文档使用 看云 构建
- 167 -第十八章:查找文件
提高效率
当 -exec 行为被使用的时候,若每次找到一个匹配的文件,它会启动一个新的指定命令的实例。 我们可能更愿意
把所有的搜索结果结合起来,再运行一个命令的实例。例如,而不是像这样执行命令:
ls -l file1
ls -l file2
我们更喜欢这样执行命令:
ls -l file1 file2
这样就导致命令只被执行一次而不是多次。有两种方法可以这样做。传统方式是使用外部命令 xargs,另一种方
法是,使用 find 命令自己的一个新功能。我们先讨论第二种方法。
通过把末尾的分号改为加号,就激活了 find 命令的一个功能,把搜索结果结合为一个参数列表, 然后执行一次
所期望的命令。再看一下之前的例子,这个:
find ~ -type f -name 'foo*' -exec ls -l '{}' ';'
-rwxr-xr-x 1 me
me 224 2007-10-29 18:44 /home/me/bin/foo
-rw-r--r-- 1 me
me 0 2008-09-19 12:53 /home/me/foo.txt
会执行 ls 命令,每次找到一个匹配的文件。把命令改为:
find ~ -type f -name 'foo*' -exec ls -l '{}' +
-rwxr-xr-x 1 me
me 224 2007-10-29 18:44 /home/me/bin/foo
-rw-r--r-- 1 me
me 0 2008-09-19 12:53 /home/me/foo.txt
虽然我们得到一样的结果,但是系统只需要执行一次 ls 命令。
xargs
这个 xargs 命令会执行一个有趣的函数。它从标准输入接受输入,并把输入转换为一个特定命令的 参数列表。对
于我们的例子,我们可以这样使用它:
find ~ -type f -name 'foo\*' -print | xargs ls -l
-rwxr-xr-x 1 me
me 224 2007-10-29 18:44 /home/me/bin/foo
-rw-r--r-- 1 me
me 0 2008-09-19 12:53 /home/me/foo.txt
这里我们看到 find 命令的输出被管道到 xargs 命令,反过来,xargs 会为 ls 命令构建 参数列表,然后执行 ls 命
令。
本文档使用 看云 构建
- 168 -第十八章:查找文件
注意:当被放置到命令行中的参数个数相当大时,参数个数是有限制的。有可能创建的命令 太长以至于 shell 不
能接受。当命令行超过系统支持的最大长度时,xargs 会执行带有最大 参数个数的指定命令,然后重复这个过程
直到耗尽标准输入。执行带有 –show–limits 选项 的 xargs 命令,来查看命令行的最大值。
处理古怪的文件名
类 Unix 的系统允许在文件名中嵌入空格(甚至换行符)。这就给一些程序,如为其它 程序构建参数列表的
xargs 程序,造成了问题。一个嵌入的空格会被看作是一个界定符,生成的 命令会把每个空格分离的单词解
释为单独的参数。为了解决这个问题,find 命令和 xarg 程序 允许可选择的使用一个 null 字符作为参数分隔
符。一个 null 字符被定义在 ASCII 码中,由数字 零来表示(相反的,例如,空格字符在 ASCII 码中由数字
32表示)。find 命令提供的 -print0 行为, 则会产生由 null 字符分离的输出,并且 xargs 命令有一个 –null
选项,这个选项会接受由 null 字符 分离的输入。这里有一个例子:
find ~ -iname ‘*.jpg’ -print0 | xargs –null ls -l
使用这项技术,我们可以保证所有文件,甚至那些文件名中包含空格的文件,都能被正确地处理。
返回操练场
到实际使用 find 命令的时候了。我们将会创建一个操练场,来实践一些我们所学到的知识。
首先,让我们创建一个包含许多子目录和文件的操练场:
[me@linuxbox ~]$ mkdir -p playground/dir-{00{1..9},0{10..99},100}
[me@linuxbox ~]$ touch playground/dir-{00{1..9},0{10..99},100}/file-{A..Z}
惊叹于命令行的强大功能!只用这两行,我们就创建了一个包含一百个子目录,每个子目录中 包含了26个空文件
的操练场。试试用 GUI 来创建它!
我们用来创造这个奇迹的方法中包含一个熟悉的命令(mkdir),一个奇异的 shell 扩展(大括号) 和一个新命
令,touch。通过结合 mkdir 命令和-p 选项(导致 mkdir 命令创建指定路径的父目录),以及 大括号展开,我
们能够创建一百个目录。
这个 touch 命令通常被用来设置或更新文件的访问,更改,和修改时间。然而,如果一个文件名参数是一个 不
存在的文件,则会创建一个空文件。
在我们的操练场中,我们创建了一百个名为 file-A 的文件实例。让我们找到它们:
[me@linuxbox ~]$ find playground -type f -name 'file-A'
注意不同于 ls 命令,find 命令的输出结果是无序的。其顺序由存储设备的布局决定。为了确定实际上 我们拥有
一百个此文件的实例,我们可以用这种方式来确认:
[me@linuxbox ~]$ find playground -type f -name 'file-A' | wc -l
本文档使用 看云 构建
- 169 -第十八章:查找文件
下一步,让我们看一下基于文件的修改时间来查找文件。当创建备份文件或者以年代顺序来 组织文件的时候,这
会很有帮助。为此,首先我们将创建一个参考文件,我们将与其比较修改时间:
[me@linuxbox ~]$ touch playground/timestamp
这个创建了一个空文件,名为 timestamp,并且把它的修改时间设置为当前时间。我们能够验证 它通过使用另
一个方便的命令,stat,是一款加大马力的 ls 命令版本。这个 stat 命令会展示系统对 某个文件及其属性所知道
的所有信息:
[me@linuxbox ~]$ stat playground/timestamp
File: 'playground/timestamp'
Size: 0 Blocks: 0 IO Block: 4096 regular empty file
Device: 803h/2051d Inode: 14265061 Links: 1
Access: (0644/-rw-r--r--) Uid: ( 1001/ me) Gid: ( 1001/ me)
Access: 2008-10-08 15:15:39.000000000 -0400
Modify: 2008-10-08 15:15:39.000000000 -0400
Change: 2008-10-08 15:15:39.000000000 -0400
如果我们再次 touch 这个文件,然后用 stat 命令检测它,我们会发现所有文件的时间已经更新了。
[me@linuxbox ~]$ touch playground/timestamp
[me@linuxbox ~]$ stat playground/timestamp
File: 'playground/timestamp'
Size: 0 Blocks: 0 IO Block: 4096 regular empty file
Device: 803h/2051d Inode: 14265061 Links: 1
Access: (0644/-rw-r--r--) Uid: ( 1001/ me) Gid: ( 1001/ me)
Access: 2008-10-08 15:23:33.000000000 -0400
Modify: 2008-10-08 15:23:33.000000000 -0400
Change: 2008-10-08 15:23:33.000000000 -0400
下一步,让我们使用 find 命令来更新一些操练场中的文件:
[me@linuxbox ~]$ find playground -type f -name 'file-B' -exec touch '{}' ';'
这会更新操练场中所有名为 file-B 的文件。接下来我们会使用 find 命令来识别已更新的文件, 通过把所有文件
与参考文件 timestamp 做比较:
[me@linuxbox ~]$ find playground -type f -newer playground/timestamp
搜索结果包含所有一百个文件 file-B 的实例。因为我们在更新了文件 timestamp 之后, touch 了操练场中名为
本文档使用 看云 构建
- 170 -第十八章:查找文件
file-B 的所有文件,所以现在它们“新于”timestamp 文件,因此能被用 -newer 测试条件识别出来。
最后,让我们回到之前那个错误权限的例子中,把它应用于操练场里:
[me@linuxbox ~]$ find playground \( -type f -not -perm 0600 \) -or \( -type d -
not -perm 0700 \)
这个命令列出了操练场中所有一百个目录和二百六十个文件(还有 timestamp 和操练场本身,共 2702 个) ,
因为没有一个符合我们“正确权限”的定义。通过对运算符和行为知识的了解,我们可以给这个命令 添加行为,
对实战场中的文件和目录应用新的权限。
[me@linuxbox ~]$ find playground \( -type f -not -perm 0600 -exec chmod 0600 '{
}' ';' \)
-or \( -type d -not -perm 0711 -exec chmod 0700 '{}' ';' \)
在日常的基础上,我们可能发现运行两个命令会比较容易一些,一个操作目录,另一个操作文件, 而不是这一个
长长的复合命令,但是很高兴知道,我们能这样执行命令。这里最重要的一点是要 理解怎样把操作符和行为结合
起来使用,来执行有用的任务。
选项
最后,我们有这些选项。这些选项被用来控制 find 命令的搜索范围。当构建 find 表达式的时候, 它们可能被其
它的测试条件和行为包含:
表 18-7: find 命令选项
选项 描述
-depth 指导 find 程序先处理目录中的文件,
再处理目录自身。当指定-delete 行为
时,会自动 应用这个选项。
-maxdepth levels 当执行测试条件和行为的时候,设置
find 程序陷入目录树的最大级别数
-mindepth levels 在应用测试条件和行为之前,设置 find
程序陷入目录数的最小级别数。
-mount 指导 find 程序不要搜索挂载到其它文
件系统上的目录。
-noleaf 指导 find 程序不要基于搜索类 Unix 的
文件系统做出的假设,来优化它的搜
索。
拓展阅读
本文档使用 看云 构建
- 171 -第十八章:查找文件
程序 locate,updatedb,find 和 xargs 都是 GNU 项目 findutils 软件包的一部分。 这个 GUN 项目提供了
大量的在线文档,这些文档相当出色,如果你在高安全性的 环境中使用这些程序,你应该读读这些文档。
http://www.gnu.org/software/findutils/