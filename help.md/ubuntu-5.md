# ubuntu-5

## 第十一章:进程

通常,现在的操作系统都支持多任务,意味着操作系统(给用户)造成了一种假象,(让用户觉得) 它同时能够做多件事情,事实上,它是快速地轮换执行这些任务的.

Linux 内核通过使用**进程**,来管理多任务.通过进程,Linux 安排不同的程序等待使用 CPU.
有时候,计算机变得呆滞,运行缓慢,或者一个应用程序停止响应.
在这一章中,我们将看一些可用的命令行工具,这些工具帮助我们查看程序的执行状态,以及怎样终止行为不当的进程.

这一章将介绍以下命令:

+ `ps` – 报告当前进程快照
+ `top` – 显示任务
+ `jobs` – 列出活跃的任务
+ `bg` – 把一个任务放到后台执行
+ `fg` – 把一个任务放到前台执行
+ `kill` – 给一个进程发送信号
+ `killall` – 杀死指定名字的进程
+ `shutdown` – 关机或重启系统

### 进程是怎样工作的

当系统启动的时候,内核先把一些它自己的程序初始化为进程,然后运行一个叫做 `init` 的程序.

`init`, 依次地,再运行一系列的称为 `init` 脚本的 `shell` 脚本(位于`/etc`),它们可以启动所有的系统服务.

其中许多系统服务以守护(daemon)程序的形式实现,守护程序仅在后台运行,没有任何用户接口.
这样,即使我们没有登录系统,至少系统也在忙于执行一些例行事务.

一个程序可以发动另一个程序,这个事实在进程方案中,表述为一个父进程创建了一个子进程.

内核维护每个进程的信息,以此来保持事情有序.
例如,系统分配给每个进程一个数字,这个数字叫做 进程 `ID`或 `PID`.`PID` 号按升序分配,`init` 进程的 `PID` 总是1.
内核也对分配给每个进程的内存进行跟踪. 像文件一样,进程也有所有者和用户 `ID`,有效用户 `ID`,等等.

### 查看进程

查看进程,最常使用的命令(有几个命令)是` ps`.`ps` 程序有许多选项,它最简单地使用形式是这样的:

```bash
ps
```

正如我们所看到的, 默认情况下,ps 不会显示很多进程信息,只是列出与当前终端会话相关的进程.

为了得到更多信息, 我们需要加上一些选项,但是在这样做之前,我们先看一下 `ps` 命令运行结果的其它字段.

TTY 是 `Teletype` 的简写,是指进程的控制终端.这里,`Unix` 展示它的年龄.`TIME` 字段表示 进程所消耗的 `CPU` 时间数量.

如果给 `ps` 命令加上选项,我们可以得到更多关于系统运行状态的信息:

```bash
ps x
```

加上 `x` 选项(注意没有开头的 `-` 字符),告诉 `ps` 命令,展示所有进程,不管它们由什么 终端(如果有的话)控制.
在 `TTY` 一栏中出现的 `?` ,表示没有控制终端.使用这个 `x` 选项,可以 看到我们所拥有的每个进程的信息.

因为系统中正运行着许多进程,所以 `ps` 命令的输出结果很长.把 `ps` 的输出结果管道到less 命令经常很有帮助.
一些选项组合也会产生很长的输出结果,所以最大化 终端仿真器窗口,也是一个好主意.

输出结果中,新添加了一栏,标题为 `STAT` .`STAT` 是 `state` 的简写,它揭示了进程当前状态:

****
状态 意义

+ `R` :  运行.这意味着,进程正在运行或准备运行.
+ `S` :  正在睡眠. 进程没有运行,而是,正在等待一个事件, 比如说,一个按键或者网络数据包.
+ `D` :  不可中断睡眠.进程正在等待` I/O`,比方说,一个磁盘驱动器的` I/O`.
+ `T` :  已停止. 已经指示进程停止运行.稍后介绍更多.
+ `Z` :  一个死进程或`僵尸`进程.这是一个已经终止的子进程,但是它的父进程还没有清空它. (父进程没有把子进程从进程表中删除)
+ `<` : 一个高优先级进程.这可能会授予一个进程更多重要的资源,给它更多的CPU 时间. 进程的这种属性叫做niceness.
具有高优先级的进程据说是不好的(less nice), 因为它占用了比较多的 CPU 时间,这样就给其它进程留下很少时间.
+ `N` :低优先级进程. 一个低优先级进程(一个`好`进程)只有当其它高优先级进程执行之后,才会得到处理器时间.

进程状态信息之后,可能还跟随其他的字符.这表示各种外来进程的特性.详细信息请看 `ps` 手册页.

另一个流行的选项组合是 `aux`(不带开头的`-`字符).这会给我们更多信息:

```bash
ps aux
```

这个选项组合,能够显示属于每个用户的进程信息.使用这个选项,可以唤醒 `BSD 风格` 的输出结果.

Linux 版本的 `ps` 命令,可以模拟几个不同 Unix 版本中的 `ps` 程序的行为.
通过这些选项,我们得到 这些额外的列.

***
标题 意思

+ `USER` 用户 `ID`. 进程的所有者.
+ `%CPU` 以百分比表示的 CPU 使用率
+ `%MEM` 以百分比表示的内存使用率
+ `VSZ` 虚拟内存大小
+ `RSS` 进程占用的物理内存的大小,以千字节为单位.
+ `START` 进程运行的起始时间.若超过`24`小时,则用天表示.

### 用 `top` 命令动态查看进程

虽然 `ps` 命令能够展示许多计算机运行状态的信息,但是它只是提供,`ps` 命令执行时刻的机器状态快照.
为了看到更多动态的信息,我们使用 `top` 命令:

```bash
top
```

`top` 程序连续显示系统进程更新的信息(默认情况下,每三分钟更新一次),`top`这个名字来源于这个事实,`top` 程序是用来查看系统中`顶端`进程的.
`top` 显示结果由两部分组成: 最上面是系统概要,下面是进程列表,以 `CPU` 的使用率排序.

其中系统概要包含许多有用信息.下表是对系统概要的说明:

***
行号 字段 意义

1. `top` 程序名. `14:59:20` 当前时间. `up 6:30` 这是正常运行时间.
它是计算机从上次启动到现在所运行的时间. 在这个例子里,系统已经运行了六个半小时.
`2 users` 有两个用户登录系统.
`load average`: 加载平均值是指,等待运行的进程数目,也就是说,处于运行状态的进程个数, 这些进程共享`CPU`.
展示了三个数值,每个数值对应不同的时间周期.第一个是最后`60`秒的平均值, 下一个是前`5`分钟的平均值,
最后一个是前15分钟的平均值.若平均值低于`1.0`,则指示计算机 工作不忙碌.
2. `Tasks`: 总结了进程数目和各种进程状态.
3. `Cpu(s)`: 这一行描述了` CPU` 正在执行的进程的特性.
`0.7%us`: `0.7%` of the CPU is being used for user processes. 这意味着进程在内核之外.
`1.0%sy`: `1.0%`的 `CPU` 时间被用于 系统(内核)进程.
`0.0%ni` : `0.0%`的 `CPU` 时间被用于`nice`(低优先级)进程.
`98.3%id`: `98.3%`的 `CPU` 时间是空闲的.
`0.0%wa` : `0.0%`的 `CPU` 时间来等待 `I/O`.
4. `Mem`: 展示物理内存的使用情况.
5. `Swap`: 展示交换分区(虚拟内存)的使用情况.

top 程序接受一系列从键盘输入的命令.两个最有趣的命令是 `h` 和 `q`.
`h`:显示程序的帮助屏幕,`q`: 退出 `top` 程序.

两个主要的桌面环境都提供了图形化应用程序,来显示与 `top` 程序相似的信息 (和 `Windows` 中的任务管理器差不多),
但是我觉得 `top` 程序要好于图形化的版本, 因为它运行速度快,并且消费很少的系统资源.
毕竟,我们的系统监测程序不能成为 系统怠工的源泉,而这是我们试图追踪的信息.

### 控制进程

现在我们可以看到和监测进程,然后得到一些对它们的控制权.
为了我们的实验,我们将使用 一个叫做 `xlogo` 的小程序,作为我们的实验品.

这个 `xlogo` 程序是 `X` 窗口系统 (底层引擎使图形界面显示在屏幕上)提供的实例程序,这个实例简单地显示一个大小可调的包含 X 标志的窗口.

首先,我们需要知道测试的主题:

```bash
xlogo
```

命令执行之后,一个包含 `X` 标志的小窗口应该出现在屏幕的某个位置上.在一些系统中,`xlogo` 命令 会打印一条警告信息,但是不用理会它.
小贴士:如果你的系统不包含 xlogo 程序,试着用 `gedit` 或者 `kwrite` 来代替.

通过调整它的窗口大小,我们能够证明 `xlogo` 程序正在运行.如果这个标志以新的尺寸被重画, 则这个程序正在运行.

注意,为什么我们的 `shell` 提示符还没有返回?这是因为 `shell` 正在等待这个程序结束, 就像到目前为止我们用过的其它所有程序一样.如果我们关闭 `xlogo` 窗口,`shell` 提示符就返回了.

#### 中断一个进程

我们再运行 `xlogo` 程序一次,观察一下发生了什么事.首先,执行 `xlogo` 命令,并且 证实这个程序正在运行.
下一步,回到终端窗口,按下 `Ctrl-c`.

在一个终端中,输入 `Ctrl-c`,中断一个程序.这意味着,我们礼貌地要求终止这个程序. 输入 `Ctrl-c` 之后, `xlogo` 窗口关闭,`shell` 提示符返回.通过这个技巧,许多(但不是全部)命令行程序可以被中断.

#### 把一个进程放置到后台(执行)

比方说,我们想让 `shell` 提示符返回,却不想终止 `xlogo` 程序.为达到这个目的,我们把 这个程序放到后台执行.

把终端看作是一个有前台(表层放置可见的事物,像 `shell` 提示符) 和后台(表层之下放置隐藏的事物)(的设备).
启动一个程序,让它立即在后台 运行,我们在程序命令之后,加上`&`字符:
注意，在`bash`中，会把`&`当作语句结束的标志，后面不能再出现`;`，否则会报错。
而在`zsh`中，可以在`&`后面再加上`;`号。

```bash
xlogo &
[1] 28236
```

执行命令之后,这个 `xlogo` 窗口出现,并且 `shell` 提示符返回,同时打印一些有趣的数字.
这条信息是 `shell` 特性的一部分,叫做工作控制.
通过这条信息,`shell` 告诉我们,已经启动了 工作号为`1`(`[1]`),`PID` 为`28236`的程序.
如果我们运行 `ps` 命令,可以看到我们的进程.

shell 功能--工作控制,这个 可以列出从终端中启动的任务.执行 `jobs` 命令,我们可以看到这个输出列表:

```bash
jobs
[1]+ Running
xlogo &
```

结果显示我们有一个任务,编号为`1`,它正在运行,并且这个任务的命令是 `xlogo &`.

#### 进程返回到前台

一个在后台运行的进程对一切来自键盘的输入都免疫,也不能用 `Ctrl-c` 来中断它.
使用 `fg` 命令,让一个进程返回前台执行:

```bash
jobs
[1]+ Running
xlogo &
fg %1
xlogo
```

`fg` 命令之后,跟随着一个百分号和工作序号(叫做 `jobspec`).如果我们只有一个后台任务,那么 `jobspec` 是可有可无的.
输入 `Ctrl-c` 来终止 `xlogo` 程序.

#### 停止一个进程

有时候,我们想要停止一个进程,而没有终止它.这样会把一个前台进程移到后台等待.
输入`Ctrl-z`,可以停止一个前台进程.让我们试一下.在命令提示符下,执行 `xlogo` 命令, 然后输入 `Ctrl-z`:

```bash
xlogo
[1]+ Stopped xlogo
```

停止 `xlogo` 程序之后,通过调整 `xlogo` 的窗口大小,我们可以证实这个程序已经停止了.
它看起来像死掉了一样.使用 `fg` 命令,可以恢复程序到前台运行,或者用 `bg` 命令把程序移到后台.

```bash
bg %1
[1]+ xlogo &
```

和 `fg` 命令一样,如果只有一个任务的话, `jobspec` 参数是可选的.
因为把一个进程从前台移到后台很方便,如果我们从命令行启动一个图形界面的程序,但是忘记把它放到后台执行,即没有在命令后加上字符`&`,(也不用担心).

为什么要从命令行启动一个图形界面程序呢?有两个原因.
第一个,你想要启动的程序,可能 没有在窗口管理器的菜单中列出来(比方说 `xlogo`).
第二个,从命令行启动一个程序, 你能够看到一些错误信息,如果从窗口系统中运行程序的话,这些信息是不可见的.
有时候, 一个程序不能从图形界面菜单中启动.这时候,应该从命令行中启动它.我们可能会看到 错误信息,这些信息揭示了问题所在.
一些图形界面程序还有许多有意思并且有用的命令行选项.

#### Signals

`kill` 命令被用来`杀死`程序.这样我们就可以终止需要杀死的程序.这里有一个实例:

```bash
xlogo &
:[1] 28401
kill 28401
:[1]+ Terminated
xlogo
```

首先,我们在后台启动 `xlogo` `程序.shell` 打印出 `jobspec` 和这个后台进程的 `PID`.
下一步,我们使用 `kill` 命令,并且指定我们想要终止的进程 `PID`.也可以用 `jobspec`(例如,`%1`)来代替 `PID`.

虽然这个命令很直接了当,但不仅仅这些.这个 `kill` 命令不是确切地`杀死`程序,而是给程序 发送信号.
信号是操作系统与程序之间进行通信,所采用的几种方式中的一种.

我们已经看到 信号,在使用 `Ctrl-c` 和 `Ctrl-z` 的过程中.当终端接受了其中一个按键组合后,它会给在前端运行 的程序发送一个信号.
在使用 `Ctrl-c` 的情况下,会发送一个叫做 `INT`(中断)的信号;当使用 `Ctrl-z` 时,则发送一个叫做 `TSTP`(终端停止)的信号.程序,反过来,倾听信号的到来,当程序 接到信号之后,则做出响应.

一个程序能够倾听和响应信号,这个事实允许一个程序做些事情, 比如,当程序接到一个终止信号时,它可以保存所做的工作.

#### 通过 `kill` 命令给进程发送信号

`kill` 命令被用来给程序发送信号.它最常见的语法形式看起来像这样:

```bash
kill [-signal] PID...
```

如果在命令行中没有指定信号,那么默认情况下,发送 `TERM`(终止)信号.`kill` 命令被经常 用来发送以下命令:

****
常用信号
| 编号 | 名字 | 含义 |

+ `1` `HUP` `挂起` : 这是美好往昔的痕迹,那时候终端机通过电话线和调制解调器连接到 远端的计算机.这个信号
被用来告诉程序,控制的终端机已经`挂起`. 通过关闭一个终端会话,可以说明这个信号的作用.发送这个信号到终端机上的前台程序,程序会终止.
许多守护进程也使用这个信号,来重新初始化.这意味着,当发送这个信号到一个守护进程后, 这个进程会重新启动,并且重新读取它的配置文件.`Apache` 网络服务器守护进程就是一个例子.

+ `2` `INT` `中断`:实现和 `Ctrl-c` 一样的功能,由终端发送.通常,它会终止一个程序.
+ `9` `KILL` `杀死` : 这个信号很特别.鉴于进程可能会选择不同的方式来处理信号,其中也包含忽略信号.
`Kill`并不发送`9`信号到目标进程.而是内核立即终止 这个进程.
当一个进程以这种方式终止的时候,它没有机会去做些`清理`工作,或者是保存劳动成果.
因为这个原因,把 `KILL` 信号看作杀手锏,当其它终止信号失败后,再使用它.
+ `15` `TERM` `终止`: 这是 `kill` 命令发送的默认信号.如果程序仍然`活着`,可以接受信号,那么 这个信号终止程序.
+ `18` `CONT` `继续`: 在停止一段时间后,进程恢复运行.
+ `19` `STOP` `停止`: 这个信号导致进程停止运行,而没有终止.类似`KILL` 信号,它不被发送到目标进程,因此它不能被忽略.

让我们实验一下 `kill` 命令:

```bash
xlogo &
[1] 13546
kill -1 13546
[1]+ Hangup
xlogo
```

在这个例子里,我们在后台启动 `xlogo` 程序,然后通过 `kill` 命令,发送给它一个 `HUP` 信号.
这个 `xlogo` 程序终止运行,并且 `shell` 指示这个后台进程已经接受了一个挂起信号.
在看到这条 信息之前,你可能需要多按几次 `enter` 键.注意,既可以用号码,也可以用名字,不过要在名字前面 加上字母`SIG`,来指定所要发送的信号.

```bash
xlogo &
[1] 13546
kill -1 13546
[1]+ Hangup
xlogo
```

重复上面的例子,试着使用其它的信号.记住,你也可以用 `jobspecs` 来代替 `PID` .

进程,和文件一样,拥有所有者,所以为了能够通过 `kill` 命令来给进程发送信号, 你必须是进程的所有者(或者是超级用户).

除了上表列出的 `kill` 命令最常使用的信号之外,还有一些系统频繁使用的信号.以下是其它一些常用 信号列表:

***
其它常用信号
| 编号 | 名字 | 含义 |

+ `3` `QUIT` `退出`
+ `11` `SEGV` `段错误`: 如果一个程序非法使用内存,就会发送这个信号.也就是说, 程序试图写入内存,而这个内存空间是不允许此程序写入的
+ `20` `TSTP` `终端停止`: 当按下 `Ctrl-z` 组合键后,终端发送这个信号.不像 `STOP` 信号, `TSTP` 信号由目标进程
接收,且可能被忽略.
+ `28` `WINCH` `改变窗口大小`: 当改变窗口大小时,系统会发送这个信号. 一些程序,像 `top` 和 `less` 程序会响
应这个信号,按照新窗口的尺寸,刷新显示的内容.

为了满足读者的好奇心,通过下面的命令可以得到一个完整的信号列表:

```bash
kill -l
```

#### 通过 `killall` 命令给多个进程发送信号

也有可能通过 `killall` 命令,给匹配特定程序或用户名的多个进程发送信号.下面是 `killall` 命令的语法形式:

```bash
killall [-u user] [-signal] name...
```

为了说明情况,我们将启动一对 `xlogo` 程序的实例,然后再终止它们:

```bash
$ xlogo &
[1] 18801
$ xlogo &
[2] 18802
$ killall xlogo
[1]- Terminated xlogo
[2]+ Terminated xlogo
```

记住,和 `kill` 命令一样,你必须拥有超级用户权限才能给不属于你的进程发送信号.

### 更多和进程相关的命令

因为监测进程是一个很重要的系统管理任务,所以有许多命令与它相关.玩玩下面几个命令:

***
| 命令名 | 命令描述 |

+ `pstree` : 输出一个树型结构的进程列表,这个列表展示了进程间父/子关系.
+ `vmstat`: 输出一个系统资源使用快照,包括内存,交换分区和磁盘`I/O`. 为了看到连续的显示结果,则在命令名后加上延时的时间(以秒为单位).例如,`vmstat 5`. 终止输出,按下 `Ctrl-c` 组合键.
+ `xload`: 一个图形界面程序,可以画出系统负载的图形.
+ `tload`: 与 `xload` 程序相似,但是在终端中画出图形.使用 `Ctrl-c`,来终止输出.

## 第十二章:shell环境

正如我们之前所讨论到的,`shell` 在 `shell`会话中维护着大量的信息,这些信息称为 (`shell`) 环境. 
存储在 `shell`环境中的数据被程序用来确定配置属性.

然而大多数程序用配置文件来存储程序设置, 某些程序也会查找存储在`shell` 环境中的数值来调整他们的行为.
知道了这些,我们就可以用 `shell` 环境 来自定制 `shell` 经历.

在这一章,我们将用到以下命令:

+ `printenv` - 打印部分或所有的环境变量
+ `set` - 设置 `shell` 选项
+ `export` — 导出环境变量,让随后执行的程序知道.
+ `alias` - 创建命令别名

### 什么存储在环境变量中?

shell 在环境中存储了两种基本类型的数据,虽然对于 bash 来说,很大程度上这些类型是不可辨别的.
它们是环境变量和 shell 变量.

Shell 变量是由 `bash` 存放的少量数据,而剩下的基本上 都是环境变量.

除了变量,shell 也存储了一些可编程的数据,命名为别名和 shell 函数.
我们 已经在第六章讨论了别名,而 shell 函数(涉及到 shell 脚本)将会在第五部分叙述.

### 检查环境变量

我们既可以用 bash 的内部命令 `set`,或者是 `printenv` 程序来查看什么存储在环境当中.

`set` 命令可以显示shell 和环境变量两者,而 `printenv` 只是显示环境变量.
因为环境变量内容列表相当长,所以最好 把每个命令的输出结果管道到 less 命令:

```bash
$ printenv | less
```

执行以上命令之后,我们应该能得到类似以下内容:

```bash
KDE_MULTIHEAD=false
SSH_AGENT_PID=6666
...
```

我们所看到的是环境变量及其数值的列表.
例如,我们看到一个叫做 USER 的变量,这个变量值是 `me`.`printenv` 命令也能够列出特定变量的数值:

```bash
$ printenv USER
me
```

当使用没有带选项和参数的 `set` 命令时,shell 和环境变量二者都会显示,同时也会显示定义的 shell 函数.
不同于 `printenv` 命令,`set` 命令的输出结果很礼貌地按照字母顺序排列:

```bash
$ set | less
```

也可以通过 `echo` 命令来查看一个变量的内容,像这样:

```bash
$ echo $HOME
/home/me
```

如果 shell 环境中的一个成员既不可用 `set` 命令也不可用 `printenv` 命令显示,则这个变量是别名. 
输入不带参数的 `alias` 命令来查看它们:

```bash
$ alias
alias l.='ls -d .* --color=tty'
alias ll='ls -l --color=tty'
...
```

### 一些有趣的变量

shell 环境中包含相当多的变量,虽然你的 shell 环境可能不同于这里展示的,但是你可能会看到 以下变量在你的 shell 环境中:

***
环境变量
变量 内容

+ `DISPLAY`: 如果你正在运行图形界面环境,那么这个变量就是你显示器的名字.
通常,它是 `:0`, 意思是由`X`产生的第一个显示器.
+ `EDITOR`: 文本编辑器的名字.
+ `SHELL`: shell 程序的名字.
+ `HOME`: 用户家目录.
+ `LANG`: 定义了字符集以及语言编码方式.
+ `OLD_PWD`: 先前的工作目录.
+ `PAGER`: 页输出程序的名字.这经常设置为`/usr/bin/less`.
+ `PATH`: 由冒号分开的目录列表,当你输入可执行程序名后,会搜索这个目录列表.
+ `PS1`: `Prompt String 1`. 这个定义了你的shell 提示符的内容.随后我们可以看到,这个变量 内容可以全面地定制.
+ `PWD`: 当前工作目录.
+ `TERM`: 终端类型名.类 Unix 的系统支持许多终端协议;这个变量设置你的终端仿真器所用的协议.
+ `TZ`: 指定你所在的时区.大多数类 Unix 的系统按照协调时间时 (UTC) 来维护计算机内部的时钟 ,然后应用一个由这个变量指定的偏差来显示本地时间.
+ `USER`: 你的用户名

如果缺失了一些变量,不要担心,这些变量会因发行版本的不同而不同.

### 如何建立 shell 环境?

当我们登录系统后,启动 bash 程序,并且会读取一系列称为启动文件的配置脚本, 这些文件定义了默认的可供所有用户共享的 shell 环境.
然后是读取更多位于我们自己家目录中的启动文件,这些启动文件定义了用户个人的 shell 环境.

精确的启动顺序依赖于要运行的 shell 会话 类型.
有两种 shell 会话类型:一个是登录 shell 会话,另一个是非登录 shell 会话.
登录 shell 会话会提示用户输入用户名和密码;例如,我们启动一个虚拟控制台会话.
当我们在 GUI 模式下 运行终端会话时,非登录 shell 会话会出现.

登录 shell 会读取一个或多个启动文件,正如表12-2所示:
***
表12-2: 登录 shell 会话的启动文件文件 内容

+ `/etc/profile`: 应用于所有用户的全局配置脚本.
+ `~/.bash_profile`: 用户私人的启动文件.可以用来扩展或重写全局配置脚本中的设置.
+ `~/.bash_login`: 如果文件 `~/.bash_profile` 没有找到,`bash` 会尝试读取这个脚本.
+ `~/.profile`: 如果文件 `~/.bash_profile` 或文件`~/.bash_login` 都没有找到,`bash` 会试图读取这个文件.
这是基于 Debian发行版的默认设置,比方说 Ubuntu.

非登录 shell 会话会读取以下启动文件:

***
表12-3: 非登录 shell 会话的启动文件
文件 内容

+ `/etc/bash.bashrc` 应用于所有用户的全局配置文件.
+ `~/.bashrc` 用户私有的启动文件.可以用来扩展或重写全局配置脚本中的设置.

除了读取以上启动文件之外,非登录 shell 会话也会继承它们父进程的环境设置,通常是一个登录 shell.

浏览一下你的系统,看一看系统中有哪些启动文件.记住--因为上面列出的大多数文件名都以圆点开头 (意味着它们是隐藏文件),你需要使用带`-a`选项的 `ls` 命令.

在普通用户看来,文件 `~/.bashrc` 可能是最重要的启动文件,因为它几乎总是被读取.

非登录 shell 默认 会读取它,并且大多数登录 shell 的启动文件会设置成读取 `~/.bashrc` 文件.
一个启动文件的内容如果我们看一下典型的 `.bash_profile` 文件(来自于 `CentOS 4` 系统),它看起来像这样:

```bash
# .bash_profile
# Get the aliases and functions
if [ -f ~/.bashrc ]; then
. ~/.bashrc
fi
# User specific environment and startup programs
PATH=$PATH:$HOME/bin
export PATH
```

以`#`开头的行是注释,shell 不会读取它们.它们在那里是为了方便人们阅读.
第一件有趣的事情发生在第四行,伴随着以下代码:

```bash
if [ -f ~/.bashrc ]; then
. ~/.bashrc
fi
```

这叫做一个 `if` 复合命令,我们将会在第五部分详细地介绍它,现在我们对它翻译一下:

```bash
If the file ~/.bashrc exists, then
read the ~/.bashrc file.
```

我们可以看到这一小段代码就是一个登录 shell 得到 `.bashrc` 文件内容的方式.
在我们启动文件中, 下一件有趣的事与 `PATH` 变量有关系.

曾经是否感到迷惑 shell 是怎样知道到哪里找到我们在命令行中输入的命令的?
例如,当我们输入 `ls` 后, shell不会查找整个计算机系统,来找到 `/bin/ls`(`ls` 命令的绝对路径名),
它将查找一个目录列表, 这些目录包含在 `PATH` 变量中.

`PATH` 变量经常(但不总是,依赖于发行版)在`/etc/profile` 启动文件中设置,通过这些代码:

```bash
PATH=$PATH:$HOME/bin
```

修改 `PATH` 变量,添加目录 `$HOME/bin` 到目录列表的末尾.这是一个参数展开的实例, 参数展开我们在第八章中提到过.

为了说明这是怎样工作的,试试下面的例子:

```bash
$ foo="This is some"
$ echo $foo
$ foo="$foo text."
$ echo $foo
```

使用这种技巧,我们可以把文本附加到一个变量值的末尾.

通过添加字符串 `$HOME/bin` 到 `PATH` 变量值 的末尾,则目录 `$HOME/bin` 就添加到了命令搜索目录列表中.
这意味着当我们想要在自己的家目录下, 创建一个目录来存储我们自己的私人程序时,shell 已经给我们准备好了.

我们所要做的事就是把创建的目录叫做 `bin`,赶快行动吧.注意:很多发行版默认地提供了这个 `PATH` 设置.
一些基于 Debian 的发行版,例如 Ubuntu,在登录 的时候,会检测目录 `~/bin` 是否存在,若找到目录则把它动态地加到 `PATH` 变量中.

最后,有下面一行代码:

```bash
export PATH
```

这个 `export` 命令告诉 `shell` 让这个 `shell` 的子进程可以使用 PATH 变量的内容.

### 修改 shell 环境

既然我们知道了启动文件所在的位置和它们所包含的内容,我们就可以修改它们来定制自己的 shell 环境.
我们应该修改哪个文件?

按照通常的规则,添加目录到你的 PATH 变量或者是定义额外的环境变量,要把这些更改放置到 `.bash_profile`文件中(或者其替代文件中,根据不同的发行版.例如,Ubuntu 使用 `.profile` 文件). 

对于其它的更改,要放到 `.bashrc` 文件中.除非你是系统管理员,需要为系统中的所有用户修改默认设置,那么则限定你只能对自己家
目录下的文件进行修改.

当然,有可能会更改 `/etc` 目录中的文件,比如说 `profile` 文件,而且在许多情况下,修改这些文件也是明智的,但是现在,我们要 安全起见.

### 文本编辑器

为了编辑(例如,修改)shell 的启动文件,还有系统中大多数其它配置文件,我们使用一个叫做文本编辑器的程序.

文件编辑器是一个,在某些方面,类似于文字处理器的程序,比如说随着鼠标的移动, 它允许你在屏幕上编辑文字.
只有一点,文本编辑器不同于文字处理器,就是它只能支持纯文本,并且 经常包含为便于写程序而设计的特性.

文本编辑器分为两种基本类型:图形化的和基于文本的编辑器.
GNOME 和 KDE 两者都包含一些流行的 图形编辑器.GNOME 自带了一个叫做 `gedit` 的编辑器,这个编辑器通常在 `GNOME` 菜单中称为`文本编辑器`.

`KDE` 通常自带了三种编辑器,分别是(按照复杂度递增的顺序排列)`kedit`,`kwrite`,`kate`.
有许多基于文本的编辑器.你将会遇到一些流行的编辑器,它们是 `nano`,`vi`,和 `emacs`.

这个 `nano` 编辑器 是一个简单的,容易使用的编辑器,它是 `pico` 编辑器的替代物,`pico` 编辑器由 `PINE` 邮件套件提供.
`vi` 编辑器(在大多数 Linux 系统中被 `vim` 替代,`vim` 是 `Vi IMproved`的简写)是类 Unix 操作系统的传统编辑器.
`vim` 是我们下一章节的讨论对象.

`emacs` 编辑器最初由 Richard Stallman 写成.
`emacs` 是一个庞大的,多用途的, 可做任何事情的编程环境.虽然 `emacs` 很容易获取,但是大多数 Linux 系统很少默认安装它.

### 使用文本编辑器

所有的文本编辑器都可以通过在命令行中输入编辑器的名字,加上你所想要编辑的文件来唤醒.
如果所 输入的文件名不存在,编辑器则会假定你想要创建一个新文件.下面是一个使用 `gedit` 的例子:

```bash
$ gedit some_file
```

这条命令将会启动 `gedit` 文本编辑器,同时加载名为 `some_file` 的文件,如果这个文件存在的话.

所有的图形文本编辑器都相当不言自明的,所以我们在这里不会介绍它们.
反之,我们将集中精力在 我们第一个基于文本的文本编辑器,`nano`.

让我们启动 `nano`,并且编辑文件`.bashrc`.但是在我们这样 做之前,先练习一些`安全准备`.

当我们编辑一个重要的配置文件时,首先创建一个这个文件的备份总是一个不错的主意.
这样能避免我们在编辑文件时弄乱文件.创建文件 `.bashrc` 的备份文件,这样做:

```bash
$ cp .bashrc .bashrc.bak
```

备份文件的名字无关紧要,只要选择一个容易理解的文件名.
扩展名 `.bak`,`.sav`, `.old`,和`.orig` 都是用来指示备份文件的流行方法.
哦,记住 `cp` 命令会默默地重写存在的文件.现在我们有了一个备份文件,我们启动 `nano` 编辑器吧:

```bash
$ nano .bashrc
```

一旦 `nano` 编辑器启动后,我们将会得到一个像下面一样的屏幕:

```bash
GNU nano 2.0.3
....
```

注意:如果你的系统中没有安装 `nano` 编辑器,你可以用一个图形化的编辑器代替.

这个屏幕由上面的标头,中间正在编辑的文件文本和下面的命令菜单组成.
因为设计 nano 是为了 代替由电子邮件客户端提供的编辑器的,所以它相当缺乏编辑特性.

在任一款编辑器中,你应该 学习的第一个命令是怎样退出程序.
以 nano 为例,你输入 `Ctrl-x` 来退出 nano.在屏幕底层的菜单中 说明了这个命令.
`^X` 表示法意思是 `Ctrl-x`.这是控制字符的常见表示法,许多程序都使用它.

第二个我们需要知道的命令是怎样保存我们的劳动成果.对于 nano 来说是 `Ctrl-o`.
尽然我们 已经获得了这些知识,接下来我们准备做些编辑工作.

使用下箭头按键和 / 或下翻页按键,移动鼠标到文件的最后一行,然后添加以下几行到文件 `.bashrc` 中:

```bash
umask 0002
export HISTCONTROL=ignoredups
export HISTSIZE=1000
alias l.='ls -d .* --color=auto'
alias ll='ls -l --color=auto'
```

注意:你的发行版可能已经包含其中的一些行,但是复制没有任何伤害.

下表是所添加行的意义:

***
表12-4:
文本行 含义

+ `umask 0002` 设置掩码来解决共享目录的问题.
+ `export HISTCONTROL=ignoredups` 使得 shell 的历史记录功能忽略一个命令,如果相同的命令已被记录.
+ `export HISTSIZE=1000` 增加命令历史的大小,从默认的 `500` 行扩大到 `1000` 行.
+ `alias l.='ls -d .* --color=auto'` 创建一个新命令,叫做`l.`,这个命令会显示所有以点开头的目录项.
+ `alias ll='ls -l --color=auto'` 创建一个叫做`ll`的命令,这个命令会显示长格式目录列表.

正如我们所看到的,我们的许多附加条目意思直觉上并不是明显的,所以添加注释到我们的文件 `.bashrc` 中是 一个好主意,可以帮助人们理解.
使用编辑器,更改我们的附加条目,让它们看起来像这样:

```bash
# Change umask to make directory sharing easier
umask 0002
# Ignore duplicates in command history and increase
# history size to 1000 lines
export HISTCONTROL=ignoredups
export HISTSIZE=1000
# Add some helpful aliases
alias l.='ls -d .* --color=auto'
alias ll='ls -l --color=auto'
```

啊,看起来好多了! 当我们完成修改后,输入 `Ctrl-o` 来保存我们修改的 `.bashrc` 文件,输入 `Ctrl-x` 退出 nano.
为什么注释很重要?

不管什么时候你修改配置文件时,给你所做的更改加上注释都是一个好主意.
的确,明天你会记得你修改了的内容,但是六个月之后会怎样呢?帮自己一个忙,加上一些注释吧.
`Shell` 脚本和 `bash` 启动文件都使用 `#` 符号来开始注释.其它配置文件可能使用其它的符号. 
大多数配置文件都有注释.把它们作为指南.
你会经常看到配置文件中的一些行被注释掉,以此防止它们被受影响的程序使用.

这样做 是为了给读者在可能的配置选项方面一些建议,或者给出正确的配置语法实例.
例如,Ubuntu 8.04 中的 `.bashrc `文件包含这些行:

```bash
# some more ls aliases
#alias ll='ls -l'
#alias la='ls -A'
#alias l='ls -CF'
```

最后三行是有效的被注释掉的别名定义.如果你删除这三行开头的 `#` 符号,此技术程称为 `uncommenting` (不注释),这样你就会激活这些别名.
相反地,如果你在一行的开头加上 `#` 符号, 你可以注销掉这一行,但会保留它所包含的信息.

### 激活我们的修改

我们对于文件 `.bashrc` 的修改不会生效,直到我们关闭终端会话,再重新启动一个新的会话, 
因为 `.bashrc` 文件只是在刚开始启动终端会话时读取.

然而,我们可以强迫 bash 重新读取修改过的 `.bashrc` 文件,使用下面的命令:

```bash
$ source .bashrc
```

运行上面命令之后,我们就应该能够看到所做修改的效果了.试试其中一个新的别名:

```bash
$ ll
```

总结

在这一章中,我们学到了用文本编辑器来编辑配置文件的必要技巧.
随着继续学习,当我们 读到命令的手册页时,记录下命令所支持的环境变量.可能会有一个或两个宝贝.

在随后的章节里面,我们将会学习 shell 函数,一个很强大的特性,你可以把它包含在 bash 启动文件里面,以此来添加你自定制的命令宝库.

拓展阅读

bash 手册页的 INVOCATION 部分非常详细地讨论了 bash 启动文件.

## 第十三章:VI简介

有一个古老的笑话,说是一个在纽约的游客向行人打听这座城市中著名古典音乐场馆的方向:

游客: 请问一下,我怎样去卡内基音乐大厅?
行人: 练习,练习,练习!

学习 Linux 命令行,就像要成为一名造诣很深的钢琴家一样,它不是我们一下午就能学会的技能.
这需要 经历几年的勤苦练习.在这一章中,我们将介绍 vi(发音`vee eye`)文本编辑器,它是 Unix 传统中核心程序之一.

vi 因它难用的用户界面而有点声名狼藉,但是当我们看到一位大师坐在钢琴前开始演奏时,我们的确成了 伟大艺术的见证人.
虽然我们在这里不能成为 vi 大师,但是当我们学完这一章后, 我们会知道怎样在 vi 中玩`筷子`.

### 为什么我们应该学习 vi

在现在这个图形编辑器和易于使用的基于文本编辑器的时代,比如说 `nano`,为什么我们还应该学习 `vi` 呢? 下面有三个充分的理由:

1. `vi` 很多系统都预装.如果我们的系统没有图形界面,比方说一台远端服务器或者是一个 `X` 配置损坏了的本地系统,那么 `vi` 就成了我们的救星.
虽然 `nano` 逐渐流行起来,但是它 还没有普及.`POSIX`,这套 Unix 系统中程序兼容的标准,就要求系统要预装`vi`.
1. `vi` 是轻量级且执行快速的编辑器.
对于许多任务来说,启动 `vi` 比起在菜单中找到一个图形化文本编辑器,再等待编辑器数倍兆字节的数据加载而言,要容易的多.
另外,`vi` 是为了加快输入速度而设计的. 我们将会看到,当一名熟练的 `vi` 用户在编辑文件时,他或她的手从不需要移开键盘.
1. 我们不希望其他 Linux 和 Unix 用户把我们看作胆小鬼.

好吧,可能只有两个充分的理由.

### 一点儿背景介绍

第一版 `vi` 是在1976由 `Bill Joy` 写成的,当时他是加州大学伯克利分校的学生, 后来他共同创建了 `Sun` 微系统公司.

`vi` 这个名字 来源于单词`visual`,因为它打算在带有可移动光标的视频终端上编辑文本.
在发明可视化编辑器之前, 有一次只能操作一行文本的行编辑器.
为了指定一个修改,我们告诉行编辑器到一个特殊行并且说明做什么修改,比方说添加或删除文本.

视频终端(而不是基于打印机的终端,像电传打印机)的出现 ,可视化编辑成为可能.
`vi` 实际上整合了一个强大的叫做 `ex` 行编辑器, 所以我们在使用 `vi` 时能运行行编辑命令.

大多数 Linux 发行版不包含真正的 `vi`;而是自带一款高级替代版本,叫做 `vim`(它是`vi improved`的简写)由 Bram Moolenaar 开发的.`vim` 相对于传统的 Unix vi 来说,取得了实质性进步.
通常,`vim` 在 Linux 系统中是`vi`的符号链接(或别名). 在随后的讨论中,我们将会假定我们有一个叫做`vi`的程序,但它其实是`vim`.

### 启动和停止 vi

要想启动 `vi`,只要简单地输入以下命令:

```
$ vi
```

一个像这样的屏幕应该出现:

```bash
VIM - Vi Improved
....
```

正如我们之前操作 `nano` 时,首先要学的是怎样退出 `vi`.要退出 `vi`,输入下面的命令(注意冒号是命令的一部分):

```bash
:q
```

shell 提示符应该返回.如果由于某种原因,`vi` 不能退出(通常因为我们对文件做了修改,却没有保存文件).
通过给命令加上叹号,我们可以告诉 `vi` 我们真要退出 `vi`.

```bash
:q!
```

小贴示:如果你在 vi 中`迷失`了,试着按下 Esc 键两次来找到路(回到普通模式).

### vi模式

#### 兼容模式

上面实例中的启动屏幕(来自于 Ubuntu 8.04),我们看到一行文字`以 Vi 兼容的模式运行`.
这意味着vim 将以近似于 vi 常规的模式 运行,而不是 vim 的高级规范.
为了这章的目的,我们想要使用 vim 的高级规范.要想这样做, 你有几个选择:
用 `vim` 来代替 `vi`.
如果命令生效,考虑在你的`.bashrc` 文件中添加别名 `vi='vim'`.
或者,使用这个命令在你的 `vim` 配置文件中添加一行:

```bash
echo `set nocp` >> ~/.vimrc
```

不同的 Linux 发行版其 vim 软件包也迥然不同.一些发行版只是安装了 vim 的最小版本, 其默认只支持有限的 vim 特性.
当练习随后的课程时,你可能会遇到缺失的功能. 如果是这种情况,就安装 vim 的完整版.

#### 编辑模式

再次启动 `vi`,这次传递给 `vi` 一个不存在的文件名.这也是用 `vi` 创建新文件的方法.

```bash
$ rm -f foo.txt
$ vi foo.txt
```

如果一切运行正常,我们应该获得一个像这样的屏幕:

```bash
....
"foo.txt" [New File]
```

每行开头的波浪号(`~`)指示那一行不存在文本.这表示我们有一个空文件.还没有输入任何字符?
学习 vi 时,要知道的第二件非常重要的事情是(知道了如何退出 vi 后)vi 是一个模式编辑器,当 vi 启动后,进入 的是命令模式.
这种模式下,几乎每个按键都是一个命令,所以如果我们打算输入字符,vi 会发疯,弄得一团糟.

#### 插入模式

为了在文件中添加文本,首先我们必须进入插入模式.
按下`i`按键进入插入模式.之后,我们应该 在屏幕底部看到下面一行,如果 vi 运行在高级模式下(这不会出现在 vi 兼容模式下):

```bash
-- INSERT --
```

现在我们能输入一些文本了.试着输入这些文本:`The quick brown fox jumped over the lazy dog.`
按下 `Esc` 按键,退出插入模式并返回命令模式.

#### 保存我们的工作

为了保存我们刚才对文件所做的修改,我们必须在命令模式下输入一个 `ex` 命令. 
通过按下`:`键,这很容易完成.按下冒号键之后,一个冒号字符应该出现在屏幕的底部:

```bash
:
```

为了写入我们修改的文件,我们在冒号之后输入`w`字符,然后按下回车键:

```bash
:w
```

文件将会写入到硬盘,并且我们应该在屏幕底部得到一个确认信息,就像这样:

```bash
"foo.txt" [New] 1L, 46C written
```

小贴示:如果你阅读 vim 的文档,你注意到(混淆地)命令模式被叫做普通模式,`ex` 命令 叫做命令模式.当心.

#### 移动光标

当在 vi 命令模式下时,vi 提供了大量的移动命令,其中一些是与 `less` 阅读器共享的.这里 列举了一些:

***
表13-1: 光标移动按键
按键 移动光标

+ `l` or 右箭头 向右移动一个字符
+ `h` or 左箭头 向左移动一个字符
+ `j` or 下箭头 向下移动一行
+ `k` or 上箭头 向上移动一行
+ `0` (零按键) 移动到当前行的行首.
+ `^` 移动到当前行的第一个非空字符.
+ `$` 移动到当前行的末尾.
+ `w` 移动到下一个单词或标点符号的开头.
+ `W` 移动到下一个单词的开头,忽略标点符号.
+ `b` 移动到上一个单词或标点符号的开头.
+ `B` 移动到上一个单词的开头,忽略标点符号.
+ `Ctrl -f ` or `Page Down` 向下翻一页
+ `Ctrl -b` or `Page Up` 向上翻一页
+ `numberG` 移动到第 `number` 行.例如,`1G` 移动到文件的第一行.`G` 移动到文件末尾.

为什么 `h`,`j`,`k`,和 `l` 按键被用来移动光标呢?
因为在开发 vi 之初,并不是所有的视频终端都有箭头按键,
熟练的打字员可以使用规则的键盘按键来移动光标,他们的手从不需要移开键盘.

`vi` 中的许多命令都可以在前面加上一个数字,比方说上面提到的`G`命令.
在命令之前加上一个 数字,我们就可以指定命令执行的次数.例如,命令`5j`导致 vi 向下移动5行.

### 基本编辑

大多数编辑工作由一些基本的操作组成,比如说插入文本,删除文本和通过剪切和粘贴来移动文本. 

vi,当然,以它自己的独特方式来支持所有的操作.vi 也提供了有限的撤销形式.
如果我们按下`u` 按键,当在命令模式下,vi 将会撤销你所做的最后一次修改.
当我们试着执行一些基本的 编辑命令时,这会很方便.

#### 追加文本

vi 有几种不同进入插入模式的方法.我们已经使用了 `i` 命令来插入文本.
让我们返回到我们的 `foo.txt` 文件中,呆一会儿:`The quick brown fox jumped over the lazy dog.`

如果我们想要在这个句子的末尾添加一些文本,我们会发现 `i` 命令不能完成任务,因为我们不能把 光标移到行尾.

vi 提供了追加文本的命令,明智地命名为`a`命令.
如果我们把光标移动到行尾,输入`a`, 光标就会越过行尾,vi 进入插入模式.这样就允许我们添加更多的文本:
`The quick brown fox jumped over the lazy dog. It was cool.`
记住按下 `Esc` 按键来退出插入模式.

因为我们几乎总是想要在行尾附加文本,所以 vi 提供了一种快捷方式来移动到当前行的末尾,并且能添加文本.
它是`A`命令.试着用一下它,给文件添加更多行.

首先,使用`0`(零)命令,将光标移动到行首.现在我们输入`A`,来添加以下文本行:

```bash
The quick brown fox jumped over the lazy dog. It was cool.
Line 2
Line 3
```

再一次,按下 `Esc` 按键退出插入模式.

正如我们所看到的,大 `A` 命令非常有用,因为在启动插入模式之前,它把光标移到了行尾.

### 打开一行

我们插入文本的另一种方式是`打开`一行.这会在存在的两行之间插入一个空白行,并且进入插入模式. 
这种方式有两个变体:

***
表13-2: 文本行打开按键
命令 打开行

+ `o` 当前行的下方打开一行.
+ `O` 当前行的上方打开一行.

我们可以演示一下:把光标放到`Line 3`上,按下小 `o` 按键.

```bash
The quick brown fox jumped over the lazy dog. It was cool.
Line 2
Line 3
```

在第三行之下打开了新的一行,并且进入插入模式.按下 `Esc`,退出插入模式.按下 `u` 按键,撤销我们的修改.
按下大 `O` 按键在光标之上打开新的一行:

```bash
The quick brown fox jumped over the lazy dog. It was cool.
Line 2
Line 3
```

按下 `Esc` 按键,退出插入模式,并且按下 `u` 按键,撤销我们的更改.

### 删除文本

正如我们期望的,vi 提供了各种各样的方式来删除文本,所有的方式包含一个或两个按键.

首先, `x` 按键会删除光标位置的一个字符.可以在 `x` 命令之前带上一个数字,来指明要删除的字符个数.
`d` 按键更通用一些.类似 `x`命令,`d` 命令之前可以带上一个数字,来指定要执行的删除次数.
另外, `d` 命令之后总是带上一个移动命令,用来控制删除的范围.这里有些实例:

***
表13-3: 文本删除命令
命令 删除的文本

+ `x` : 当前字符
+ `3x` : 当前字符及其后的两个字符.
+ `dd` : 当前行.
+ `5dd` : 当前行及随后的四行文本.
+ `dW` : 从光标位置开始到下一个单词的开头.
+ `d$` : 从光标位置开始到当前行的行尾.
+ `d0` : 从光标位置开始到当前行的行首.
+ `d^` : 从光标位置开始到文本行的第一个非空字符.
+ `dG` : 从当前行到文件的末尾.
+ `d20G`: 从当前行到文件的第20行.

把光标放到第一行单词`It`之上.重复按下 `x` 按键直到删除剩下的部分.下一步,重复按下 `u` 按键 直到恢复原貌.

注意:真正的 vi 只是支持单层面的 `undo` 命令.vim 则支持多个层面的.

我们再次执行删除命令,这次使用 `d` 命令.还是移动光标到单词`fox`之上,按下的 `dW` 来删除单词,
按下 `d$`删除从光标位置到行尾的文本.按下 `dG` 按键删除从当前行到文件末尾的所有行.

连续按下 `u` 按键三次,来恢复删除部分.

### 剪切,复制和粘贴文本

这个 `d` 命令不仅删除文本,它还`剪切`文本.每次我们使用 `d` 命令,删除的部分被复制到一个 粘贴缓冲区中(看作剪切板).
过后我们执行小 `p` 命令把剪切板中的文本粘贴到光标位置之后, 或者是大 `P` 命令把文本粘贴到光标之前.

`y` 命令用来`拉`(复制)文本,和 `d` 命令剪切文本的方式差不多.这里有些把 `y` 命令和各种移动命令结合起来使用的实例:

***
表13-4: 复制命令
命令 复制的内容

+ `yy` 当前行.
+ `5yy` 当前行及随后的四行文本.
+ `yw`从当前光标位置到下一个单词的开头.
+ `y$` 从当前光标位置到当前行的末尾.
+ `y0` 从当前光标位置到行首.
+ `y^` 从当前光标位置到文本行的第一个非空字符.
+ `yG` 从当前行到文件末尾.
+ `y20G` 从当前行到文件的第20行.

我们试着做些复制和粘贴工作.把光标放到文本第一行,输入 `yy` 来复制当前行.
下一步,把光标移到 最后一行(`G`),输入小写的 `p` 把复制的一行粘贴到当前行的下面:

和以前一样,`u` 命令会撤销我们的修改.光标仍然位于文件的最后一行,输入大写的 `P` 命令把 所复制的文本粘贴
到当前行之上

试着执行上表中一些其他的 `y` 命令,了解小写 `p` 和大写 `P` 命令的行为.当你完成练习之后,把文件 恢复原样.

#### 连接行 

`vi` 对于行的概念相当严格.通常,不可能把光标移到行尾,再删除行尾结束符(回车符)来连接当前行和它下面的一行.

由于这个原因,vi 提供了一个特定的命令,大写的 `J`(不要与小写的 `j` 混淆了, `j` 是用来移动光标的)把行与行之间连接起来.
如果我们把光标放到 `line 3`上,输入大写的 `J` 命令,看看发生什么情况:

```bash
The quick brown fox jumped over the lazy dog. It was cool.
Line 2
Line 3 Line 4
Line 5
```

### 查找和替换

vi 有能力把光标移到搜索到的匹配项上.vi 可以在单一行或整个文件中运用这个功能. 
它也可以在有或没有用户确认的情况下实现文本替换.

#### 查找一行

`f` 命令查找一行,移动光标到下一个所指定的字符上.例如,命令 `fa` 会把光标定位到同一行中下一个出现的`a`字符上.
在一行中执行了字符的查找命令之后,通过输入分号来重复这个查找.

#### 查找整个文件

移动光标到下一个出现的单词或短语上,使用 `/` 命令.这个命令和我们之前在 `less` 程序中学到 的一样.

当你输入`/`命令后,一个`/`字符会出现在屏幕底部.下一步,输入要查找的单词或短语后, 按下回车.
光标就会移动到下一个包含所查找字符串的位置.通过 `n` 命令来重复先前的查找. 这里有个例子:

```bash
The quick brown fox jumped over the lazy dog. It was cool.
Line 2
Line 3
Line 4
Line 5
```

把光标移动到文件的第一行.输入:`/Line`然后键入回车.光标会移动到第二行.

下一步,输入 `n`,光标移到第三行.重复这个 `n` 命令,光标会 继续向下移动直到遍历了所有的匹配项.

虽然目前,我们只是使用了单词和短语来作为我们的查找 模式,但是 vi 允许使用正则表达式,一种强大的用来表示复杂文本模式的方法.

我们将会在随后 的章节里面详尽地介绍正则表达式.

#### 全局查找和替代

vi 使用 `ex` 命令来执行查找和替代操作(vi 中叫做`替换`).

把整个文件中的单词`Line`更改为`line`,我们输入以下命令:

```bash
:%s/Line/line/g
```

我们把这个命令分解为几个单独的部分,看一下每部分的含义:

***
条目 含义

+ `:`: 冒号字符运行一个 `ex` 命令.指定要操作的行数.
+ `%` :是一个快捷方式,表示从第一行到最后一行.
另外,操作范围也 可以用 `1,5` 来代替(因为我们的文件只有`5`行文本),或者用 `1,$`来代替,意思是 从第一行到文件的最后一行.`如果省略了文本行的范围,那么操作只对当前行生效.
+ `s` :指定操作.在这种情况下是,替换(查找与替代).
+ `/Line/line` :查找类型与替代文本.
+ `g` :这是`全局`的意思,意味着对文本行中所有匹配的字符串执行查找和替换操作.如果省略 g,则 只替换每个文本行中第一个匹配的字符串.

执行完查找和替代命令之后,我们的文件看起来像这样:

```bash
The quick brown fox jumped over the lazy dog. It was cool.
line 2
line 3
line 4
line 5
```

我们也可以指定一个需要用户确认的替换命令.通过添加一个`c`字符到这个命令的末尾,来完成 这个替换命令.例如:

```bash
:%s/line/Line/gc
```

这个命令会把我们的文件恢复先前的模样;然而,在执行每个替换命令之前,vi 会停下来, 通过下面的信息,来要求我们确认这个替换:
`replace with Line (y/n/a/q/l/^E/^Y)?`

括号中的每个字符都是一个可能的选择,如下所示:

***
表13-5: 替换确认按键
按键 行为

+ `y` 执行替换操作
+ `n` 跳过这个匹配的实例
+ `a` 对这个及随后所有匹配的字符串执行替换操作.
+ `q` or `esc` 退出替换操作.
+ `l` 执行这次替换并退出.l 是 `last` 的简写.

`Ctrl-e`, `Ctrl-y `分别是向下滚动和向上滚动.用于查看建议替换的上下文.
如果你输入 `y`,则执行这个替换,输入 `n` 则会导致 `vi` 跳过这个实例,而移到下一个匹配项上.

### 编辑多个文件

同时能够编辑多个文件是很有用的.你可能需要更改多个文件或者从一个文件复制内容到 另一个文件.
通过 vi,我们可以打开多个文件来编辑,只要在命令行中指定要编辑的文件名.

```bash
vi file1 file2 file3...
```

我们先退出已经存在的 vi 会话,然后创建一个新文件来编辑.输入`:wq` 来退出 vi 并且保存了所做的修改.
下一步,我们将在家目录下创建一个额外的用来玩耍的文件.通过获取从 ls 命令的输出,来创建这个文件.

```bash
$ ls -l /usr/bin > ls-output.txt
```

用 vi 来编辑我们的原文件和新创建的文件:

```bash
$ vi foo.txt ls-output.txt
```

vi 启动,我们会看到第一个文件显示出来.

#### 文件之间转换

从这个文件转到下一个文件,使用这个 ex 命令:

```bash
:n
```

回到先前的文件使用:

```bash
:N
```

当我们从一个文件移到另一个文件时,如果当前文件没有保存修改,vi 会阻止我们转换文件, 这是 vi 强制执行的政策.
在命令之后添加感叹号,可以强迫 vi 放弃修改而转换文件.

另外,上面所描述的转换方法,vim(和一些版本的 vi)也提供了一些 ex 命令,这些命令使 多个文件更容易管理.

我们可以查看正在编辑的文件列表,使用`:buffers` 命令.运行这个 命令后,屏幕顶部就会显示出一个文件列表:

```bash
:buffers
1 # "foo.txt" line 1
2 %a "ls-output.txt" line 0
Press ENTER or type command to continue
```

注意:你不能通过`:n` 或`:N` 命令在由`:e` 命令加载的文件之间进行切换.
这时要使用`:buffer` 命令, 其后加上缓冲区号码,来转换文件.

从一个文件复制内容到另一个文件当我们编辑多个文件时,经常地要复制文件的一部分到另一个正在编辑的文件.
使用之前我们学到的 拉(`yank`)和粘贴命令,这很容易完成.说明如下.

以打开的两个文件为例,首先转换到缓冲区1(foo.txt) ,输入:

```bash
:buffer 1
```

我们应该得到以下输出:

```bash
The quick brown fox jumped over the lazy dog. It was cool.
Line 2
Line 3
Line 4
Line 5
```

下一步,把光标移到第一行,并且输入 `yy` 来复制这一行.
转换到第二个缓冲区,输入:

```bash
:buffer 2
```

现在屏幕会包含一些文件列表,移动光标到第一行,输入 `p` 命令把我们从前面文件中复制的一行粘贴到这个文件中.

### 插入整个文件到另一个文件

也有可能把整个文件插入到我们所编辑的文件中.
看一下实际操作,结束 vi 会话,重新 启动一个只打开一个文件的 vi 会话:

```bash
$ vi ls-output.txt
```

移动光标到第三行,然后输入以下 `ex` 命令:

```bash
:r foo.txt
```

这个`:r` 命令(是`read`的简称)把指定的文件插入到光标位置之前.

### 保存工作

像 vi 中的其它操作一样,有几种不同的方法来保存我们所修改的文件,我们已经研究了`:w` 这个 ex 命令, 但还有几种方法,可能我们也觉得有帮助.

在命令模式下,输入 `ZZ` 就会保存并退出当前文件.同样地,`ex` 命令`:wq` 把`:w` 和`:q` 命令结合到 一起,来完成保
存和退出任务.

这个`:w `命令也可以指定可选的文件名.这个的作用就如`Save As...`.

例如,如果我们 正在编辑 `foo.txt` 文件,想要保存一个副本,叫做 `foo1.txt`,那么我们可以执行以下命令:

```bash
:w foo1.txt
```

注意:当上面的命令以一个新名字保存文件时,但它并没有更改你正在编辑的文件的名字. 
如果你继续编辑的话,你还是在编辑文件 `foo.txt`,而不是 `foo1.txt`.

### 拓展阅读

即使把这章所学的内容都加起来,我们也只是学了 vi 和 vim 的一点儿皮毛而已.这里 有一些在线的资料,你可
以用来继续 vi 学习之旅.

+ [学习 vi 编辑器][]-一本来自于 Wikipedia 的 Wikibook,是一本关于 vi 的简要指南,并介绍了几个类似 vi 的程序,其中包括 vim.
+ [The Vim Book-vim 项目][], 一本570页的书籍,包含了(几乎)所有的 vim 特性.你能在下面链接中找到它:
+ Wikipedia 上关于 [Bill Joy][] 的文章,vi 的创始人.http://en.wikipedia.org/wiki/Bill_Joy
+ Wikipedia 上关于 [Bram Moolenaar][] 的文章,vim 的作者

[Bill Joy]: http://en.wikipedia.org/wiki/Bill_Joy
[Bram Moolenaar]: http://en.wikipedia.org/wiki/Bram_Moolenaar
[学习 vi 编辑器]: http://en.wikibooks.org/wiki/Vi

## 第十四章:自定制shell提示符

在这一章中,我们将会看一下表面上看来很琐碎的细节-shell 提示符.但这会揭示一些内部 shell 和 终端仿真器的工作方式.

和 Linux 内的许多程序一样,shell 提示符是可高度配置的,虽然我们大多时候把它看作是理所当然的, 但是我们一旦学会了怎样控制它,shell 提示符是一个真正有用的设备.

### 解剖一个提示符

我们默认的提示符看起来像这样:

```bash
$
```

注意它包含我们的用户名,主机名和当前工作目录,但是它又是怎样得到这些东西的呢? 结果证明非常简单.
提示符是由一个环境变量定义的,叫做 PS1(是`prompt string one` 的简写).

我们可以通过 `echo` 命令来查看 `PS1` 的内容.

```bash
$ echo $PS1
[\u@\h \W]\$
```

注意:如果你 shell 提示符的内容和上例不是一模一样,也不必担心.
每个 Linux 发行版 定义的提示符稍微有点不同,其中一些相当异乎寻常.

从输出结果中,我们看到那个 PS1 环境变量包含一些这样的字符,比方说`中括号`,`@`符号,和`$`符号, 但是剩余部分就是个谜.

我们中一些机敏的人会把这些看作是由反斜杠转义的特殊字符,就像我们在第八章中看到的一样.

这里是一部分字符列表,在shell中 会受到特殊对待:
***
表14-1: Shell 提示符中用到的转义字符
序列 显示值

+ `\a` 以 ASCII 格式编码的铃声 . 当遇到这个转义序列时,计算机会发出嗡嗡的响声.
+ `\d` 以日,月,天格式来表示当前日期.例如,`Mon May 26.`
+ `\h` 本地机的主机名,但不带末尾的域名.
+ `\H` 完整的主机名.
+ `\j` 运行在当前 shell 会话中的工作数.
+ `\l` 当前终端设备名.
+ `\n` 一个换行符.
+ `\r` 一个回车符.
+ `\s` shell 程序名.
+ `\t` 以24小时制,`hours:minutes:seconds`的格式表示当前时间.
+ `\T` 以12小时制表示当前时间.
+ `@ `以12小时制,`AM/PM` 格式来表示当前时间.
+ `\A` 以24小时制,`hours:minutes` 格式表示当前时间.
+ `\u` 当前用户名.
+ `\v` shell 程序的版本号.
+ `\V` Version and release numbers of theshell.
+ `\w` 当前工作目录名.
+ `\W` 当前工作目录名的最后部分.
+ `!` 当前命令的历史号.
+ `#` 当前 `shell` 会话中的命令数.
+ `\$` 这会显示一个`$`字符,除非你拥有超级用户权限.在那种情况下, 它会显示一个`#`字符.
+ `\[` 标志着一系列一个或多个非打印字符的开始.这被用来嵌入非打印 的控制字符,这些字符以某种方式来操作终端仿真器,比方说移动光标或者是更改文本颜色.
+ `\]` 标志着非打印字符序列结束.

### 试试一些可替代的提示符设计

参照这个特殊字符列表,我们可以更改提示符来看一下效果.首先, 我们把原来提示符字符串的内容备份一下,以备之后恢复原貌.

为了完成备份, 我们把已有的字符串复制到另一个 shell 变量中,这个变量是我们自己创造的.

```bash
$ ps1_old="$PS1"
```

我们新创建了一个叫做 `ps1_old` 的变量,并把变量 PS1的值赋 `ps1_old`.通过 `echo` 命令可以证明 我们的确复制了 PS1的值.

```bash
$ echo $ps1_old
[\u@\h \W]\$
```

在终端会话中,我们能在任一时间复原提示符,只要简单地反向操作就可以了.

```bash
$ PS1="$ps1_old"
```

现在,我们准备开始,让我们看看如果有一个空的字符串会发生什么:

```bash
$ PS1=
```

如果我们没有给提示字符串赋值,那么我们什么也得不到.
根本没有提示字符串!提示符仍然在那里, 但是什么也不显示,正如我们所要求的那样.我们将用一个最小的提示符来代替它:

```bash
PS1="\$ "
```

这样要好一些.至少能看到我们在做什么.注意双引号中末尾的空格.当提示符显示的时候, 这个空格把美元符号和光标分离开.
在提示符中添加一个响铃:

```bash
$ PS1="\a\$ "
```

现在每次提示符显示的时候,我们应该能听到嗡嗡声.这会变得很烦人,但是它可能会 很有用,特别是当一个需要运行很长时间的命令执行完后,我们要得到通知.

下一步,让我们试着创建一个信息丰富的提示符,包含主机名和当天时间的信息.

```bash
$ PS1="\A \h \$ "
17:33 linuxbox $
```

试试其他上表中列出的转义序列,看看你能否想出精彩的新提示符.

### 添加颜色

大多数终端仿真器程序支持一定的非打印字符序列来控制,比方说字符属性(像颜色,黑体和可怕的闪烁) 和光标位置.我们会更深入地讨论光标位置,但首先我们要看一下字体颜色.

#### 混乱的终端时代

回溯到终端连接到远端计算机的时代,有许多竞争的终端品牌,它们各自工作不同.它们有着不同的键盘,以不同的方式来解释控制信息.

Unix 和类 Unix 的系统有两个 相当复杂的子系统来处理终端控制领域的混乱局面(称为 termcap 和 terminfo).
如果你 查看一下终端仿真器最底层的属性设置,可能会找到一个关于终端仿真器类型的设置.

为了努力使所有的终端都讲某种通用语言,美国国家标准委员会(ANSI)制定了 一套标准的字符序列集合来控制视频终端.
原先 DOS 用户会记得 ANSI.SYS 文件, 这是一个用来使这些编码解释生效的文件.

字符颜色是由发送到终端仿真器的一个嵌入到了要显示的字符流中的 ANSI 转义编码来控制的. 
这个控制编码不会`打印`到屏幕上,而是被终端解释为一个指令.正如我们在上表看到的字符序列, 这个 [ 和 ] 序列被用来封装这些非打印字符.

一个 `ANSI` 转义编码以一个八进制`033`(这个编码是由`退出按键`产生的)开头,其后跟着一个可选的字符属性,在之后是一个指令.

例如,把文本颜色 设为正常(attribute = 0),黑色文本的编码如下:

```bash
\033[0;30m
```

这里是一个可用的文本颜色列表.
注意这些颜色被分为两组,由应用程序粗体字符属性(1) 分化开来,这个属性可以描绘出`浅`色文本.
***
表14-2: 用转义序列来设置文本颜色
序列 文本颜色 序列 文本颜色

+ `\033[0;30m` 黑色 `\033[1;30m` 深灰色
+ `\033[0;31m` 红色 `\033[1;31m` 浅红色
+ `\033[0;32m` 绿色 `\033[1;32m` 浅绿色
+ `\033[0;33m` 棕色 `\033[1;33m` 黄色
+ `\033[0;34m` 蓝色 `\033[1;34m` 浅蓝色
+ `\033[0;35m` 粉红 `\033[1;35m` 浅粉色
+ `\033[0;36m` 青色 `\033[1;36m` 浅青色
+ `\033[0;37m` 浅灰色 `\033[1;37m` 白色

让我们试着制作一个红色提示符.我们将在开头加入转义编码:

```bash
<me@linuxbox ~>$ PS1='\[\033[0;31m\]<\u@\h \W>\$'
<me@linuxbox ~>$
```

我们的提示符生效了,但是注意我们在提示符之后输入的文本也是红色的.
为了修改这个问题, 我们将添加另一个转义编码到这个提示符的末尾来告诉终端仿真器恢复到原来的颜色.

```bash
<me@linuxbox ~>$ PS1='\[\033[0;31m\]<\u@\h \W>\$\[\033[0m\]'
<me@linuxbox ~>$
```

这看起来要好些!

也有可能要设置文本的背景颜色,使用下面列出的转义编码.这个背景颜色不支持黑体属性.
***
表14-3: 用转义序列来设置背景颜色
序列 文本颜色 序列 文本颜色

+ `\033[0;40m` 蓝色 `\033[1;44m` 黑色
+ `\033[0;41m` 红色 `\033[1;45m` 粉红
+ `\033[0;42m` 绿色 `\033[1;46m` 青色
+ `\033[0;43m` 棕色 `\033[1;47m` 浅灰色
  
我们可以创建一个带有红色背景的提示符,只是对第一个转义编码做个简单的修改.

```bash
<me@linuxbox ~>$ PS1='\[\033[0;41m\]<\u@\h \W>\$\[\033[0m\] '
<me@linuxbox ~>$
```

试试这些颜色编码,看看你能定制出怎样的提示符!

注意:除了正常的 (0) 和黑体 (1) 字符属性之外,文本也可以具有下划线 (`4`),闪烁 (`5`), 和反向 (`7`) 属性.
为了拥有好品味,然而,许多终端仿真器拒绝使用这个闪烁属性.

### 移动光标

转义编码也可以用来定位光标.

这些编码被普遍地用来,每次当提示符出现的时候,会在屏幕的不同位置比如说上面一个角落,显示一个时钟或者其它一些信息.
这里是一系列用来定位光标的转义编码:
***
表14-4: 光标移动转义序列
转义编码 行动

+ `\033[l;cH`: 把光标移到第 `l` 行,第 `c` 列.
+ `\033[nA`: 把光标向上移动 `n` 行.
+ `\033[nB`: 把光标向下移动 `n` 行.
+ `\033[nC`: 把光标向前移动 `n` 个字符.
+ `\033[nD`: 把光标向后移动 `n` 个字符.
+ `\033[2J`: 清空屏幕,把光标移到左上角(第零行,第零列).
+ `\033[K`: 清空从光标位置到当前行末的内容.
+ `\033[s`: 存储当前光标位置.
+ `\033[u`: 唤醒之前存储的光标位置.

使用上面的编码,我们将构建一个提示符,每次当这个提示符出现的时候,会在屏幕的上方画出一个包含时钟(由黄色文本渲染)的红色长条.
提示符的编码就是这个看起来令人敬畏的字符串:

```bash
$ PS1='\[\033[s\033[0;0H\033[0;41m\033[K\033[1;33m\t\033[0m\033[u\]<\u@\h \W>\$ '
```

让我们分别看一下这个字符串的每一部分所表示的意思:
***
序列 行动

+ `\[` 开始一个非打印字符序列.其真正的目的是为了让 bash 能够正确地计算提示符的大小.
如果没有这个转义字符的话,命令行编辑 功能会弄错光标的位置.
+ `\033[s` 存储光标位置.这个用来使光标能回到原来提示符的位置, 当长条和时钟显示到屏幕上方之后.
当心一些终端仿真器不推崇这个编码.
+ `\033[0;0H` 把光标移到屏幕左上角,也就是第零行,第零列的位置.
+ `\033[0;41m` 把背景设置为红色.
+ `\033[K` 清空从当前光标位置到行末的内容.因为现在 背景颜色是红色,则被清空行背
景成为红色,以此来创建长条.注意虽然一直清空到行末, 但是不改变光标位置,它仍然在屏幕左上角.
+ `\033[1;33m` 把文本颜色设为黄色.
+ `\t` 显示当前时间.虽然这是一个可`打印`的元素,但我们仍把它包含在提示符的非打印部分, 
因为我们不想 bash在计算可见提示符的真正大小时包括这个时钟在内.
+ `\033[0m` 关闭颜色设置.这对文本和背景都起作用.
+ `\033[u` 恢复到之前保存过的光标位置处.
+ `\]` 结束非打印字符序列.
+ `\$` 提示符字符串.

### 保存提示符

显然地,我们不想总是敲入那个怪物,所以我们将要把这个提示符存储在某个地方.
通过把它 添加到我们的.bashrc 文件,可以使这个提示符永久存在.为了达到目的,把下面这两行添加到`.bashrc` 文件中.

```bash
PS1='\[\033[s\033[0;0H\033[0;41m\033[K\033[1;33m\t\033[0m\033[u\]<\u@\h \W>\$ '
export PS1
```

总结归纳

不管你信不信,还有许多事情可以由提示符来完成,涉及到我们在这里没有论及的 shell 函数和脚本, 但这是一个好的开始.

并不是每个人都会花心思来更改提示符,因为通常默认的提示符就很让人满意.
但是对于我们这些喜欢思考的人们来说,shell 却提供了许多制造琐碎乐趣的机会.

拓展阅读

The Bash Prompt HOWTO 来自于 Linux 文档工程,对 shell 提示符的用途进行了相当 完备的论述.可在以下链接中得到:
http://tldp.org/HOWTO/Bash-Prompt-HOWTO/

Wikipedia 上有一篇关于 ANSI Escape Codes 的好文章:
http://en.wikipedia.org/wiki/ANSI_escape_code

## 第十五章:软件包管理

如果我们花些时间在 Linux 社区里,我们会得知很多针对, 类如在众多 Linux 发行版中哪个是最好的(等问题的)看法. 
这些集中在像这些事情上的讨论,比方说最漂亮的桌面背景(一些人不使用 Ubuntu, 只是因为 Ubuntu默认主题颜色是棕色的!)和其它的琐碎东西,经常变得非常无聊.

Linux 发行版本质量最重要的决定因素是软件包管理系统和其支持社区的持久性.
随着我们 花更多的时间在Linux 上,我们会发现它的软件园地是非常动态的.软件不断变化.
大多数一线 Linux 发行版每隔六个月发布一个新版本,并且许多独立的程序每天都会更新.

为了能和这些 如暴风雪一般多的软件保持联系,我们需要一些好工具来进行软件包管理.
软件包管理是指系统中一种安装和维护软件的方法.今天,通过从 Linux 发行版中安装的软件包, 已能满足许多人所有需要的软件.
这不同于早期的 Linux,人们需要下载和编辑源码来安装软件.编辑源码没有任何问题,事实上,拥有对源码的访问权限是 Linux 的伟大奇迹.

它赋予我们( 其它每个人)才干来检测和提高系统性能.只是若有一个预先编译好的软件包处理起来要相对 容易快速些.

这章中,我们将查看一些用于包管理的命令行工具.
虽然所有主流 Linux 发行版都 提供了强大且精致的图形管理程序来维护系统,但是学习命令行程序也非常重要.
因为它们 可以完成许多让图形化管理程序处理起来困难(或者不可能)的任务.

### 打包系统

不同的 Linux 发行版使用不同的打包系统,
一般而言,大多数发行版分别属于两大包管理技术阵营: `Debian的``.deb`,和`Red Hat`的`.rpm`.
也有一些重要的例外,比方说 `Gentoo`, `Slackware`,和 `Foresight`,但大多数会使用这两个基本系统中的一个.
***
表15-1: 主要的包管理系统家族
包管理系统 发行版 (部分列表)

+ Debian Style (.deb) Debian, Ubuntu, Xandros, Linspire
+ Red Hat Style (.rpm) Fedora, CentOS, Red Hat Enterprise Linux, OpenSUSE, Mandriva, PCLinuxOS

### 软件包管理系统是怎样工作的

在专有软件产业中找到的软件发布方法通常需要买一张安装媒介,比方说`安装盘`,然后运行 `安装向导`,来在系统中安装新的应用程序.
Linux 不是这样.Linux 系统中几乎所有的软件都可以在互联网上找到.

其中大多数软件由发行商以 包文件的形式提供,剩下的则以源码形式存在,可以手动安装.
在后面章节里,我们将会谈谈怎样 通过编译源码来安装软件.

#### 包文件

在包管理系统中软件的基本单元是包文件.
包文件是一个构成软件包的文件压缩集合.一个软件包可能由大量程序以及支持这些程序的数据文件组成.
除了安装文件之外,软件包文件也包括 关于这个包的元数据,如软件包及其内容的文本说明.
另外,许多软件包还包括预安装和安装后脚本, 这些脚本用来在软件安装之前和之后执行配置任务.

软件包文件是由软件包维护者创建的,他通常是(但不总是)一名软件发行商的雇员.
软件维护者 从上游提供商(程序作者)那里得到软件源码,然后编辑源码,创建软件包元数据以及所需要的 安装脚本.
通常,软件包维护者要把所做的修改应用到最初的源码当中,来提高此软件与 Linux 发行版其它部分的融合性.

资源库虽然某些软件项目选择执行他们自己的打包和发布策略,但是现在大多数软件包是由发行商和感兴趣 的第三方创
建的.
系统发行版的用户可以在一个中心资源库中得到这些软件包,这个资源库可能 包含了成千上万个软件包,每一个软件包都是专门为这个系统发行版建立和维护的.

因软件开发生命周期不同阶段的需要,一个系统发行版可能维护着几个不同的资源库.
例如,通常会 有一个`测试`资源库,其中包含刚刚建立的软件包,它们想要勇敢的用户来使用, 在这些软件包正式发布之前,让用户查
找错误.
系统发行版经常会有一个`开发`资源库, 这个资源库中保存着注定要包含到下一个主要版本中的半成品软件包.

一个系统发行版可能也会拥有相关第三方的资源库.

这些资源库需要支持一些因法律原因, 比如说专利或者是DRM 反规避问题,而不能被包含到发行版中的软件.
可能最著名的案例就是 那个加密的 DVD 支持,在美国这是不合法的.

第三方资源库在这些软件专利和反规避法案不 生效的国家中起作用.这些资源库通常完全地独立于
它们所支持的资源库,要想使用它们, 你必须了解它们,手动地把它们包含到软件包管理系统的配置文件中.

### 依赖性

程序很少是`孤立的`,而是依赖于其它软件组件来完成它们的工作.
常见活动,以 输入/输出为例,就是由共享程序例程来处理的.这些程序例程存储在共享库中,共享库不只 为一个程序提供基本服务.

如果一个软件包需要共享资源,比如说共享库,据说就有一个依赖. 
现代的软件包管理系统都提供了一些依赖项解析方法,以此来确保当安装软件包时,也安装了 其所有的依赖程序.

### 上层和底层软件包工具

软件包管理系统通常由两种工具类型组成:底层工具用来处理这些任务,比方说安装和删除软件包文件, 和上层工具,完成元数据搜索和依赖解析.

在这一章中,我们将看一下由 Debian 风格的系统 (比如说 `Ubuntu`,还有许多其它系统)提供的工具,还有那些由 `Red Hat` 产品使用的工具.
虽然所有基于 `Red Hat` 风格的发行版都依赖于相同的底层程序(`rpm`), 但是它们却使用不同的上层工具.我们将研究上层程序 `yum` 供我们讨论,

Fedora, `Red Hat` 企业版,和 `CentOs` 都是使用 `yum`.其它基于 `Red Hat` 风格的发行版提供了带有可比较特性的上层工具.
***
表15-2: 包管理工具
发行版 底层工具 上层工具

+ `Debian-Style` : `dpkg apt-get`, `aptitude`
+ `Fedora`, `Red Hat Enterprise Linux`,` CentOS` : `rpm yum`

### 常见软件包管理任务

通过命令行软件包管理工具可以完成许多操作.我们将会看一下最常用的工具.
注意底层工具也 支持软件包文件的创建,这个话题超出了本书叙述的范围.
在以下的讨论中,`package_name` 这个术语是指软件包实际名称,而不是指`package_file`,它是包含在软件包中的文件名.

#### 查找资源库中的软件包

使用上层工具来搜索资源库元数据,可以根据软件包的名字和说明来定位它.
***
表15-3: 软件包查找工具
风格 命令

+ Debian : `apt-get update`; `apt-cache search search_string`
+ Red Hat : `yum search search_string`

例如:搜索一个 `yum` 资源库来查找 `emacs` 文本编辑器,使用以下命令:

```bash
yum search emacs
```

#### 从资源库中安装一个软件包

上层工具允许从一个资源库中下载一个软件包,并经过完全依赖解析来安装它.
***
表15-4: 软件包安装命令
风格 命令

+ `Debian` : `apt-get update`; `apt-get install package_name`
+ `Red Hat` : `yum install package_name`

例如:从一个 `apt` 资源库来安装 `emacs` 文本编辑器:

```bash
apt-get update; apt-get install emacs
```

#### 通过软件包文件来安装软件

如果从某处而不是从资源库中下载了一个软件包文件,可以使用底层工具来直接(没有经过依赖解析)安装它.
***
表15-5: 底层软件包安装命令
风格 命令

+ `Debian`: `dpkg --install package_file`
+ `Red Hat`: `rpm -i package_file`

例如:如果已经从一个并非资源库的网站下载了软件包文件 `emacs-22.1-7.fc7-i386.rpm`, 则可以通过这种方法来安装它:

```bash
rpm -i emacs-22.1-7.fc7-i386.rpm
```

注意:因为这项技术使用底层的 `rpm` 程序来执行安装任务,所以没有运行依赖解析. 如果 `rpm` 程序发现缺少了一个依赖,则会报错并退出.

#### 卸载软件

可以使用上层或者底层工具来卸载软件.下面是可用的上层工具.
***
表15-6: 软件包删除命令
风格 命令

+ `Debian`: `apt-get remove package_name`
+ `Red Hat`: `yum erase package_name`

例如:从 `Debian` 风格的系统中卸载 `emacs` 软件包:

```bash
apt-get remove emacs
```

#### 经过资源库来更新软件包

最常见的软件包管理任务是保持系统中的软件包都是最新的.上层工具仅需一步就能完成 这个至关重要的任务.
***
表15-7: 软件包更新命令
风格 命令

+ `Debian`: `apt-get update; apt-get upgrade`
+ `Red Hat`: `yum update`

例如:更新安装在 Debian 风格系统中的软件包:

```bash
apt-get update; apt-get upgrade
```

#### 经过软件包文件来升级软件

如果已经从一个非资源库网站下载了一个软件包的最新版本,可以安装这个版本,用它来 替代先前的版本:
***
表15-8: 底层软件包升级命令
风格 命令

+ `Debian`: `dpkg --install package_file`
+ `Red Hat`: `rpm -U package_file`

例如:`把 Red Hat` 系统中所安装的 `emacs` 的版本更新到软件包文件 `emacs-22.1-7.fc7-i386.rpmz` 所包含的 `emacs` 版本.

```bash
rpm -U emacs-22.1-7.fc7-i386.rpm
```

注意:`rpm` 程序安装一个软件包和升级一个软件包所用的选项是不同的,而 `dpkg` 程序所用的选项是相同的.

#### 列出所安装的软件包

下表中的命令可以用来显示安装到系统中的所有软件包列表:
***
表15-9: 列出所安装的软件包命令
风格 命令

+ `Debian`: `dpkg --list`
+ `Red Hat` : `rpm -qa`

#### 确定是否安装了一个软件包

这些底端工具可以用来显示是否安装了一个指定的软件包:
***
表15-10: 软件包状态命令
风格 命令

+ `Debian`: `dpkg --status package_name`
+ `Red Hat`: `rpm -q package_name`

例如:确定是否` Debian` 风格的系统中安装了这个 `emacs` 软件包:

```bash
dpkg --status emacs
```

#### 显示所安装软件包的信息

如果知道了所安装软件包的名字,使用以下命令可以显示这个软件包的说明信息:
***
表15-11: 查看软件包信息命令
风格 命令

+ `Debian`: `apt-cache show package_name`
+ `Red Hat`: `yum info package_name`

例如:查看 Debian 风格的系统中 `emacs` 软件包的说明信息:

```bash
apt-cache show emacs
```

#### 查找安装了某个文件的软件包

确定哪个软件包对所安装的某个特殊文件负责,使用下表中的命令:
***
表15-12: 包文件识别命令
风格 命令

+ `Debian`: `dpkg --search file_name`
+ `Red Hat`: `rpm -qf file_name`

例如:在 `Red Hat` 系统中,查看哪个软件包安装了`/usr/bin/vim` 这个文件

```bash
rpm -qf /usr/bin/vim
```

总结归纳

在随后的章节里面,我们将探讨许多不同的程序,这些程序涵盖了广泛的应用程序领域.

虽然 大多数程序一般是默认安装的,但是若所需程序没有安装在系统中,那么我们可能需要安装额外的软件包.
通过我们新学到的(和了解的)软件包管理知识,我们应该没有问题来安装和管理所需的程序.

### Linux 软件安装谣言

从其它平台迁移过来的用户有时会成为谣言的受害者,说是在 Linux 系统中,安装软件有些 困难,并且不同系统发行版所使用的各种各样的打包方案是一个障碍.

唉,它是一个障碍, 但只是针对于那些希望把他们的秘密软件只以二进制版本发行的专有软件供应商.
Linux 软件生态系统是基于开放源代码理念.
如果一个程序开发人员发布了一款产品的 源码,那么与系统发行版相关联的开发人员可能就会把这款产品打包,并把它包含在 他们的资源库中.
这种方法保证了这款产品能很好地与系统发行版整合在一起,同时为用户 `一站式采购`软件提供了方便,从而用户不必去搜索每个产品的网站.

设备驱动差不多也以同样的方式来处理,但它们不是系统发行版资源库中单独的项目, 它们本身是 Linux 系统内核的一部分.
一般来说,在 Linux 当中没有一个类似于`驱动盘`的东西. 要不内核支持一个设备,要不不支持,反正 Linux 内核支持很多设备,事实上,多于 Windows 所支持的设备数目.

当然,如果你需要的特定设备不被支持,这里也没有安慰.当那种情况 发生时,你需要查找一下原因.
缺少驱动程序支持通常是由以下三种情况之一导致:

1. 设备太新. 因为许多硬件供应商没有积极地支持 Linux 的发展,那么编写内核 驱动代码的任务就由一些
Linux 社区来承担,而这需要花费时间.
2. 设备太奇异. 不是所有的发行版都包含每个可能的设备驱动.每个发行版会建立 它们自己的内核,因为
内核是可以配置的(这使得从手表到主机的每台设备上运行 Linux 成为可能), 这样它们可能会忽略某
个特殊设备.通过定位和下载驱动程序的源码,可能需要你自己(是的,由你) 来编译和安装驱动.这
个过程不是很难,而是参与.我们将在随后的章节里来讨论编译软件.
3. 硬件供应商隐藏信息. 他们既不发布应用于 Linux 系统的驱动程序代码, 也不发布技术文档来让某人创
建它.这意味着硬件供应商试图保密此设备的程序接口.因为我们 不想在计算机中使用保密的设备,所
以我建议删除这令人厌恶的软件, 把它和其它无用的项目都仍到垃圾桶里.

拓展阅读

花些时间来了解你所用发行版中的软件包管理系统.每个发行版都提供了关于自带软件包管理工具的文档.
另外,这里有一些更普遍的资源:

Debian GNU/Linux FAQ 关于软件包管理一章对软件包管理进行了概述:
http://www.debian.org/doc/FAQ/ch-pkgtools.en.html

RPM 工程的主页:
http://www.rpm.org

杜克大学 YUM 工程的主页:
http://linux.duke.edu/projects/yum/

了解一点儿背景知识,Wikipedia 上有一篇关于 metadata 的文章:
http://en.wikipedia.org/wiki/Metadata

## 第十六章:存储媒介

在前面章节中,我们已经从文件级别看了操作数据.在这章里,我们将从设备级别来考虑数据. 
Linux 有着令人惊奇的能力来处理存储设备,
不管是物理设备,比如说硬盘,还是网络设备,或者是 虚拟存储设备,像RAID(独立磁盘冗余阵列)和 LVM(逻辑卷管理器).

然而,这不是一本关于系统管理的书籍,我们不会试图深入地覆盖整个主题.
我们将努力做的就是 介绍一些概念和用来管理存储设备的重要命令.
我们将会使用 `USB` 闪存,`CD-RW` 光盘(因为系统配备了 `CD-ROM` 烧写器)和一张软盘(若系统这样配备),来做这章的练习题.

我们将看看以下命令:

+ `mount` – 挂载一个文件系统
+ `umount` – 卸载一个文件系统
+ `fsck` – 检查和修复一个文件系统
+ `fdisk` – 分区表控制器
+ `mkfs` – 创建文件系统
+ `fdformat` – 格式化一张软盘
+ `dd` — 把面向块的数据直接写入设备
+ `genisoimage` (`mkisofs`) – 创建一个 `ISO 9660` 的映像文件
+ `wodim` (`cdrecord`) – 把数据写入光存储媒介
+ `md5sum` – 计算 `MD5` 检验码

### 挂载和卸载存储设备

Linux 桌面系统的最新进展已经使存储设备管理对于桌面用户来说极其容易.
大多数情况下,我们 只要把设备连接到系统中,它就能工作.在过去(比如说,2004年),这个工作必须手动完成.

在非桌面系统中(例如,服务器中),这仍然是一个主要地手动过程,因为服务器经常有极端的存储需求 和复杂的配置要求.
管理存储设备的第一步是把设备连接到文件系统树中.这个过程叫做挂载,允许设备参与到操作系统中. 

回想一下第三章,类 Unix 的操作系统,像 `Linux`,维护单一文件系统树,设备连接到各个结点上. 
这与其它操作系统形成对照,比如说 `MS-DOS` 和 `Windows` 系统中,每个设备(例如 `C:\`,`D:\`,等) 保持着单独的文件系统树.

有一个叫做`/etc/fstab` 的文件可以列出系统启动时要挂载的设备(典型地,硬盘分区).
下面是 来自于 Fedora7系统的`/etc/fstab` 文件实例:

```bash
LABEL=/12   /   ext3    defaults    1 1
LABEL=/home  /home   ext3    defaults    1 2
LABEL=/boot  /boot   ext3    defaults    1 2
...
```

在这个实例中所列出的大多数文件系统是虚拟的,并不适用于我们的讨论.就我们的目的而言, 前三个是我们感兴趣的:

```bash
LABEL=/12   /   ext3    defaults    1 1
LABEL=/home  /home   ext3    defaults    1 2
LABEL=/boot  /boot   ext3    defaults    1 2
```

这些是硬盘分区.每行由六个字段组成,如下所示:
***
表16-1: `/etc/fstab` 字段
字段 内容 说明

1. `设备名`: 
传统上,这个字段包含与物理设备相关联的设备文件的实际名字,比如说`/dev/hda1`(第一个IDE 通道上第一个主设备分区).
然而今天的计算机,有很多热插拔设备(像 USB 驱动设备),许多 现代的 Linux 发行版用一个文本标签和设备相关联.
当这个设备连接到系统中时, 这个标签(当储存媒介格式化时,这个标签会被添加到存储媒介中)会被操作系统读取. 
那样的话,不管赋给实际物理设备哪个设备文件,这个设备仍然能被系统正确地识别.
2. `挂载点`: 设备所连接到的文件系统树的目录.
3. `文件系统类型` : Linux 允许挂载许多文件系统类型.大多数本地的Linux 文件系统是 `ext3`,但是也支持很多其它的,比方说 `FAT16` (msdos),`FAT32` (vfat),`NTFS`(ntfs),`CD-ROM`(iso9660),等等.
4. `选项`:  文件系统可以通过各种各样的选项来挂载.例如,挂载只读的文件系统, 或者挂载阻止执行任何程序的文件系统(一个有用的安全特性,避免删除媒介.)
5. `频率`: 一位数字,指定是否和在什么时间用 `dump` 命令来备份一个文件系统.
6. `次序`: 一位数字,指定 `fsck` 命令按照什么次序来检查文件系统.

### 查看挂载的文件系统列表

这个 `mount` 命令被用来挂载文件系统.执行这个不带参数的命令,将会显示 一系列当前挂载的文件系统:

```bash
$ mount
/dev/sda2 on / type ext3 (rw)
...
```

这个列表的格式是:`设备 on 挂载点 type 文件系统类型(可选的)`.

例如,第一行所示设备`/dev/sda2` 作为根文件系统被挂载,文件系统类型是 `ext3`,并且可读可写(这个`rw`选项).

在这个列表的底部有两个有趣的条目.
倒数第二行显示了在读卡器中的一张`2G` 的 SD 内存卡,挂载到了`/media/disk` 上.
最后一行 是一个网络设备,挂载到了`/misc/musicbox` 上.

第一次实验,我们将使用一张 `CD-ROM`.首先,在插入 `CD-ROM` 之前,我们将看一下系统:

```bash
$ mount

/dev/mapper/VolGroup00-LogVol00 on / type ext3 (rw)
proc on /proc type proc (rw)
```

这个列表来自于 `CentOS 5`系统,使用 `LVM`(逻辑卷管理器)来创建它的根文件系统.
正如许多现在的 Linux 发行版一样,这个 系统试图自动挂载插入的 `CD-ROM`.当我们插入光盘后,我们看看下面的输出:

```bash
$ mount
/dev/mapper/VolGroup00-LogVol00 on / type ext3 (rw)
proc on /proc type proc (rw)
...
/dev/hdc on /media/live-1.0.10-8 type iso9660 (ro,noexec,nosuid,
nodev,uid=500)
```

当我们插入光盘后,除了额外的一行之外,我们看到和原来一样的列表.

在列表的末尾,我们 看到 CD-ROM 已经挂载到了`/media/live-1.0.10-8`上,它的文件类型是 `iso9660(CD-ROM)`.
就我们的实验目的而言,我们对这个设备的名字感兴趣.当你自己进行这个实验时,这个 设备名字是最有可能不同的.

警告:在随后的实例中,至关重要的是你要密切注意用在你系统中的实际设备名,并且 不要使用此文本中使用的名字!
还要注意音频 CD 和 CD-ROM 不一样.音频 CD 不包含文件系统,这样在通常意义上,它就不能被挂载了.

现在我们拥有 CD-ROM 光盘的设备名字,让我们卸载这张光盘,并把它重新挂载到文件系统树 的另一个位置.
我们需要超级用户身份(使用系统相应的命令)来进行操作,并且用 `umount`(注意这个命令的拼写)来卸载光盘:

```bash
$ su -
Password:
[root@linuxbox ~]# umount /dev/hdc
```

下一步是创建一个新的光盘挂载点.简单地说,一个挂载点就是文件系统树中的一个目录.它没有什么特殊的.
它甚至不必是一个空目录,即使你把设备挂载到了一个非空目录上,你也不能看到 这个目录中原来的内容,直到你卸载这个设备.
就我们的目的而言,我们将创建一个新目录:

```bash
[root@linuxbox ~]# mkdir /mnt/cdrom
```

最后,我们把这个 CD-ROM 挂载到一个新的挂载点上.这个`-t` 选项用来指定文件系统类型:

```bash
[root@linuxbox ~]# mount -t iso9660 /dev/hdc /mnt/cdrom
```

之后,我们可以通过这个新挂载点来查看 CD-ROM 的内容:

```bash
[root@linuxbox ~]# cd /mnt/cdrom
[root@linuxbox cdrom]# ls
```

注意当我们试图卸载这个 CD-ROM 时,发生了什么事情.

```bash
[root@linuxbox cdrom]# umount /dev/hdc
umount: /mnt/cdrom: device is busy
```

这是怎么回事呢?原因是我们不能卸载一个设备,如果某个用户或进程正在使用这个设备的话.
在这种 情况下,我们把工作目录更改到了 CD-ROM 的挂载点,这个挂载点导致设备忙碌.

我们可以很容易地修复这个问题 通过把工作目录改到其它目录而不是这个挂载点.

```bash
[root@linuxbox cdrom]# cd
[root@linuxbox ~]# umount /dev/hdc
```

现在这个设备成功卸载了.

#### 为什么卸载重要

如果你看一下 `free` 命令的输出结果,这个命令用来显示关于内存使用情况的统计信息,你会看到一个统计值叫做`buffers`.
计算机系统旨在尽可能快地运行.系统运行速度的 一个阻碍是缓慢的设备.
打印机是一个很好的例子.即使最快速的打印机相比于计算机标准也 极其地缓慢.
一台计算机确实会运行地非常慢,如果它要停下来等待一台打印机打印完一页. 
在早期的个人电脑时代(多任务之前),这真是个问题.

如果你正在编辑电子表格 或者是文本文档,每次你要打印文件时,计算机都会停下来而且变得不能使用. 
计算机能以打印机可接受的最快速度把数据发送给打印机,但由于打印机不能快速地打印, 这个发送速度会非常慢.
这个问题被解决了,由于打印机缓存的出现,一个包含一些 RAM 内存 的设备,位于计算机和打印机之间.

通过打印机缓存,计算机把要打印的结果发送到这个缓存区, 数据会迅速地存储到这个 RAM 中,这样计算机就能回去工作,而不用等待.
与此同时,打印机缓存将会 以打印机可接受的速度把缓存中的数据缓慢地输出给打印机.
缓存被广泛地应用于计算机中,使其运行地更快.别让偶尔地需要读取或写入慢设备阻碍了系统的运行速度.

在实际与慢设备交互之前,操作系统会尽可能多的读取或写入数据到内存中的 存储设备里.
以 Linux 操作系统为例,你会注意到系统看似填充了多于它所需要的内存.
 这不意味着 Linux 正在使用所有的内存,它意味着 Linux 正在利用所有可用的内存,来作为缓存区.

这个缓存区允许非常快速地写入存储设备,因为写入物理设备的操作被延迟到后面进行.
同时, 这些注定要传送到设备中的数据正在内存中堆积起来.时不时地,操作系统会把这些数据 写入物理设备.

卸载一个设备需要把所有剩余的数据写入这个设备,所以设备可以被安全地移除.
如果 没有卸载设备,就移除了它,就有可能没有把注定要发送到设备中的数据输送完毕.
在某些情况下, 这些数据可能包含重要的目录更新信息,这将导致文件系统损坏,这是发生在计算机中的最坏的事情之一.

### 确定设备名称

有时很难来确定设备名称.在以前,这并不是很难.一台设备总是在某个固定的位置,也不会 挪动它.类 Unix的系统喜欢设备那样安排.
之前在开发 Unix 系统的时候,`更改一个磁盘驱动器`要用一辆 叉车从机房中移除一台如洗衣机大小的设备.

最近几年,典型的桌面硬件配置已经变得相当动态,并且 Linux 已经发展地比其祖先更加灵活.
在以上事例中,我们利用现代 Linux 桌面系统的功能来`自动地`挂载 设备,然后再确定设备名称
.
但是如果我们正在管理一台服务器或者是其它一些(这种自动挂载功能)不会 发生的环境,我们又如何能查清设备名呢?
首先,让我们看一下系统怎样来命名设备.如果我们列出目录`/dev`(所有设备的住所)的内容,我们 会看到许许多多的设备:

```bash
$ ls /dev
```

这个列表的内容揭示了一些设备命名的模式.这里有几个:
***
表16-2: Linux 存储设备名称
模式 设备

+ `/dev/fd*` 软盘驱动器
+ `/dev/hd*`老系统中的`IDE(PATA)`磁盘.
典型的主板包含两个 IDE 连接器或者是通道,每个连接器 带有一根缆线,每根缆线上有两个硬盘驱动器连接点.
缆线上的第一个驱动器叫做主设备, 第二个叫做从设备.设备名称这样安排,`/dev/hdb` 是指第一通道上的主设备名;
`/dev/hdb`是第一通道上的从设备名;`/dev/hdc`是第二通道上的主设备名,等等.末尾的数字表示 硬盘驱动器上的分区.
例如,`/dev/hda1`是指系统中第一硬盘驱动器上的第一个分区,而 `/dev/hda` 则是指整个硬盘驱动器.
+ `/dev/lp*` 打印机
+ `/dev/sd*` `SCSI` 磁盘.在最近的 Linux 系统中,内核把所有类似于磁盘的设备
(包括`PATA/SATA` 硬盘, 闪存,和 `USB` 存储设备,比如说可移动的音乐播放器和数码相机)看作 `SCSI` 磁盘. 
剩下的命名系统类似于上述所描述的旧的`/dev/hd*`命名方案.
+ `/dev/sr*` 光盘(CD/DVD 读取器和烧写器)

另外,我们经常看到符号链接比如说`/dev/cdrom`,`/dev/dvd` 和`/dev/floppy`,它们指向实际的设备文件,提供这些链接是为了方便使用.

如果你工作的系统不能自动挂载可移动的设备,你可以使用下面的技巧来决定当可移动设备连接后,它是怎样被命名的.

首先,启动一个实时查看文件`/var/log/messages` (你可能需要超级用户权限):

```bash
$ sudo tail -f /var/log/messages
# or in ubuantu
$ sudo tail -f /var/log/kern.log
```

这个文件的最后几行会被显示,然后停止.下一步,插入这个可移动的设备.

在 这个例子里,我们将使用一个16MB 闪存.瞬间,内核就会发现这个设备, 并且探测它:

```bash
Jul 23 10:07:59 linuxbox kernel:
...
sd 3:0:0:0: [sdb] 31263 512-byte
sd 3:0:0:0: [sdb] Write Protect is
...
Jul 23 10:07:59 linuxbox kernel: sdb: sdb1
Jul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: [sdb] Attached SCSI
removable disk
```

显示再次停止之后,输入 `Ctrl-c`,重新得到提示符.

输出结果的有趣部分是一再提及`[sdb]`, 这正好符和我们期望的 `SCSI` 磁盘设备名称.
知道这一点后,有两行输出变得颇具启发性:

```bash
Jul 23 10:07:59 linuxbox kernel: sdb: sdb1
Jul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: [sdb] Attached SCSI
removable disk
```

这告诉我们这个设备名称是`/dev/sdb` 指整个设备,`/dev/sdb1`是这个设备的第一分区.
正如我们所看到的,使用 Linux 系统充满了有趣的监测工作.

小贴士:使用这个 `tail -f /var/log/messages` 技巧是一个很不错的方法,可以实时观察系统的一举一动.

既然知道了设备名称,我们就可以挂载这个闪存驱动器了:

```bash
$ sudo mkdir
$ sudo mount
$ df
```

这个设备名称会保持不变只要设备与计算机保持连接并且计算机不会重新启动.

### 创建新的文件系统

假若我们想要用 Linux 本地文件系统来重新格式化这个闪存驱动器,而不是它现用的 `FAT32`系统.这涉及到两个步骤:

1. (可选的)创建一个新的分区布局,若已存在的分区不是我们喜欢的.
2. 在这个闪存上创建一个新的空的文件系统.

注意!在下面的练习中,我们将要格式化一个闪存驱动器.拿一个不包含有用数据的驱动器 作为实验品,因为它将会被擦除!
再次,请确定你指定了正确的系统设备名称.未能注意此警告可能导致你格式化(即擦除)错误的驱动器!

### 用 fdisk 命令操作分区

这个 `fdisk` 程序允许我们直接在底层与类似磁盘的设备(比如说硬盘驱动器和闪存驱动器)进行交互. 

使用这个工具可以在设备上编辑,删除,和创建分区.以我们的闪存驱动器为例, 
首先我们必须卸载它(如果需要的话),然后调用 `fdisk` 程序,如下所示:

```bash
$ sudo umount /dev/sdb1
$ sudo fdisk /dev/sdb
```

注意我们必须指定设备名称,就整个设备而言,而不是通过分区号.这个程序启动后,我们 将看到以下提示:

```bash
Command (m for help):
输入`m`会显示程序菜单:
Command action
a toggle a bootable flag
....
```

我们想要做的第一件事情是检查已存在的分区布局.输入`p`会打印出这个设备的分区表:

```bash
Command (m for help): p
Disk /dev/sdb: 16 MB, 16006656 bytes
1 heads, 31 sectors/track, 1008 cylinders
Units = cylinders of 31 * 512 = 15872 bytes
...
```

在此例中,我们看到一个 `16MB` 的设备只有一个分区(1),此分区占用了可用的1008个柱面中的1006个, 并被标识为 Windows 95 FAT32分区.

有些程序会使用这个标志符来限制一些可以对磁盘所做的操作, 但大多数情况下更改这个标志符没有危害.
然而,为了叙述方便,我们将会更改它, 以此来表明是个 Linux 分区.在更改之前,首先我们必须找到被用来识别一个 Linux 分区的 ID 号码. 

在上面列表中,我们看到 ID 号码`b`被用来指定这个已存在的分区.
要查看可用的分区类型列表, 参考之前的程序菜单.我们会看到以下选项:

`l list known partition types`

如果我们在提示符下输入`l`,就会显示一个很长的可能类型列表.
在它们之中会看到`b`为已存在分区 类型的 ID 号,而`83`是针对 Linux 系统的 ID 号.
回到之前的菜单,看到这个选项来更改分区 ID 号:

`t change a partition's system id`

我们先输入`t`,再输入新的 ID 号:

```bash
Command (m for help): t
Selected partition 1
Hex code (type L to list codes): 83
Changed system type of partition 1 to 83 (Linux)
```

这就完成了我们需要做得所有修改.
到目前为止,还没有接触这个设备(所有修改都存储在内存中, 而不是在此物理设备中),所以我们将会把修改过的分区表写入此设备,再退出.
为此,我们输入 在提示符下输入`w`:

```bash
Command (m for help): w
The partition table has been altered!
Calling ioctl() to re-read partition table.
WARNING: If you have created or modified any DOS 6.x
partitions, please see the fdisk manual page for additional
information.
Syncing disks.
$
```

如果我们已经决定保持设备不变,可在提示符下输入`q`,这将退出程序而没有写更改.
我们 可以安全地忽略这些不祥的警告信息.

### 用`mkfs`命令创建一个新的文件系统

完成了分区编辑工作(它或许是轻量级的),是时候在我们的闪存驱动器上创建一个新的文件系统了. 

为此,我们会使用 mkfs(`make file system`的简写),它能创建各种格式的文件系统. 
在此设备上创建一个 `ext3`文件系统,我们使用`-t` 选项来指定这个`ext3`系统类型,随后是我们要格式化的设备分区名称:

```bash
$ sudo mkfs -t ext3 /dev/sdb1
mke2fs 1.40.2 (12-Jul-2007)
Filesystem label=
OS type: Linux
Block size=1024 (log=0)
...
```

当 `ext3` 被选为文件系统类型时,这个程序会显示许多信息.
若把这个设备重新格式化为它最初的 FAT32文件系统,指定`vfat`作为文件系统类型:

```bash
$ sudo mkfs -t vfat /dev/sdb1
```

任何时候添加额外的存储设备到系统中时,都可以使用这个分区和格式化的过程.

虽然我们只以一个小小的闪存驱动器为例,同样的操作可以被应用到内部硬盘和其它可移动的存储设备上像 USB 硬盘驱动器.

### 测试和修复文件系统

在之前讨论文件`/etc/fstab` 时,我们会在每行的末尾看到一些神秘的数字.
每次系统启动时, 在挂载系统之前,都会按照惯例检查文件系统的完整性.

这个任务由 fsck 程序(是`file system check`的简写)完成.每个 `fstab` 项中的最后一个数字指定了设备的检查顺序.
在上面的实例中,我们看到首先检查根文件系统,然后是 `home` 和 `boot` 文件系统. 若最后一个数字 是零则相应设备不会被检查.

除了检查文件系统的完整性之外,`fsck` 还能修复受损的文件系统,其成功度依赖于损坏的数量. 
在类 Unix 的文件系统中,文件恢复的部分被放置于 `lost+found` 目录里面,位于每个文件系统的根目录下面.

检查我们的闪存驱动器(首先应该卸载),我们能执行下面的操作:

```bash
$ sudo fsck /dev/sdb1
fsck 1.40.8 (13-Mar-2008)
e2fsck 1.40.8 (13-Mar-2008)
/dev/sdb1: clean, 11/3904 files, 1661/15608 blocks
```

以我的经验,文件系统损坏情况相当罕见,除非硬件存在问题,如磁盘驱动器故障. 
在大多数系统中,系统启动阶段若探测到文件系统已经损坏了,则会导致系统停止下来, 在系统继续执行之前,会指导你运行 `fsck` 程序.

#### 什么是 fsck?

在 Unix 文化中,`fsck`这个单词往往会被用来代替一个流行的词,`fsck`和这个词共享了三个字母.
尤其适用于,当你不得不使用 `fsck` 命令时,你可能会说出这个词汇.

### 格式化软盘

对于那些还在使用配备了软盘驱动器的计算机的用户,我们也能管理这些设备.

准备一 张可用的空白软盘要分两个步骤.首先,对这张软盘执行低级格式化,然后创建一个文件系统. 
为了完成格式化,我们使用 `fdformat` 程序,同时指定软盘设备名称(通常为`/dev/fd0`):

```bash
$ sudo fdformat /dev/fd0
Double-sided, 80 tracks, 18 sec/track. Total capacity 1440 kB.
Formatting ... done
Verifying ... done
```

接下来,通过 `mkfs` 命令,给这个软盘创建一个 `FAT` 文件系统:

```bash
$ sudo mkfs -t msdos /dev/fd0
```

注意我们使用这个`msdos`文件系统类型来得到旧(小的)风格的文件分配表.
当一个软磁盘被准备好之后,则可能像其它设备一样挂载它.

### 接把数据移入/出设备

虽然我们通常认为计算机中的数据以文件形式来组织数据,也可以`原始的`形式来考虑数据. 
如果我们看一下磁盘驱动器,例如, 我们看到它由大量的数据`块`组成,而操作系统却把这些数据块看作目录和文件.
然而,如果 把磁盘驱动器简单地看成一个数据块大集合,我们就能执行有用的任务,如克隆设备.

`dd` 程序能执行此任务.它可以把数据块从一个地方复制到另一个地方.它使用独特的语法(由于历史原因):

```bash
dd if=input_file of=output_file [bs=block_size [count=blocks]]
```

比方说我们有两个相同容量的 USB 闪存驱动器,并且要精确地把第一个驱动器(中的内容) 复制给第二个.
如果连接两个设备到计算机上,它们各自被分配到设备`/dev/sdb` 和 `/dev/sdc `上,
这样我们就能通过下面的命令把第一个驱动器中的所有数据复制到第二个 驱动器中.

```bash
dd if=/dev/sdb of=/dev/sdc
```

或者,如果只有第一个驱动器被连接到计算机上,我们可以把它的内容复制到一个普通文件中供以后恢复或复制数据:

```bash
dd if=/dev/sdb of=flash_drive.img
```

警告!这个 `dd` 命令非常强大.
虽然它的名字来自于`数据定义`,有时候也把它叫做`清除磁盘` 因为用户经常会误输入 `if` 或 `of` 的规范.
在按下回车键之前,要再三检查输入与输出规范!

### 创建 CD-ROM 映像

写入一个可记录的 CD-ROM(一个 CD-R 或者是 CD-RW)由两步组成:
首先,构建一个 iso 映像文件, 这就是一个 CD-ROM 的文件系统映像,
第二步,把这个映像文件写入到 CD-ROM 媒介中.

#### 创建一个 CD-ROM 的映像拷贝

如果想要制作一张现有 CD-ROM 的 iso 映像,我们可以使用 dd 命令来读取 CD-ROM 中的所有数据块, 并把它们复制到本地文件中.

比如说我们有一张 Ubuntu CD,用它来制作一个 iso 文件,以后我们可以用它来制作更多的拷贝.
插入这张 CD 之后,确定 它的设备名称(假定是`/dev/cdrom`),然后像这样来制作 iso 文件:

```bash
dd if=/dev/cdrom of=ubuntu.iso
```

这项技术也适用于 DVD 光盘,但是不能用于音频 CD,因为它们不使用文件系统来存储数据.
对于音频 CD,看一下 `cdrdao` 命令.

#### 从文件集合中创建一个映像

创建一个包含目录内容的 iso 映像文件,我们使用 `genisoimage` 程序.

为此,我们首先创建 一个目录,这个目录中包含了要包括到此映像中的所有文件,然后执行这个 `genisoimage` 命令 来创建映像文件.

例如,如果我们已经创建一个叫做`~/cd-rom-files` 的目录,
然后用文件 填充此目录,再通过下面的命令来创建一个叫做 `cd-rom.iso` 映像文件:

```bash
genisoimage -o cd-rom.iso -R -J ~/cd-rom-files
```

`-R`选项添加元数据为 Rock Ridge 扩展,这允许使用长文件名和 POSIX 风格的文件权限.
同样地,这个`-J`选项使 Joliet 扩展生效,这样 Windows 中就支持长文件名了.

#### 一个有着其它名字的程序...

如果你看一下关于创建和烧写光介质如 CD-ROMs 和 DVD 的在线文档,你会经常碰到两个程序 叫做 `mkisofs` 和 `cdrecord` .
这些程序是流行软件包`cdrtools`的一部分,`cdrtools`由 Jorg Schilling 编写成.

在2006年春天,Schilling 先生更改了部分 cdrtools 软件包的协议,Linux 社区许多人的看法是, 这创建了一个与 `GNU GPL` 不相兼容的协议.
结果,就 `fork` 了这个 `cdrtools` 项目, 目前新项目里面包含了 `cdrecord` 和 `mkisofs` 的替代程序,分别是 `wodim` 和 `genisoimage` .

### 写入 CD-ROM 镜像

有了一个映像文件之后,我们可以把它烧写到光盘中.下面讨论的大多数命令对可 记录的 CD-ROM 和 DVD 媒
介都适用.

#### 直接挂载一个 ISO 镜像

有一个诀窍,我们可以用它来挂载 `iso` 映像文件,虽然此文件仍然在我们的硬盘中,但我们当作它已经在光盘中了.

添加 `-o loop` 选项来挂载(同时带有必需的 `-t iso9660` 文件系统类型), 挂载这个映像文件就好像它是一台设备,把它连接到文件系统树上:

```bash
mkdir /mnt/iso_image
mount -t iso9660 -o loop image.iso /mnt/iso_image
```

上面的示例中,我们创建了一个挂载点叫做`/mnt/iso_image`,然后把此映像文件 `image.iso` 挂载到挂载点上.

映像文件被挂载之后,可以把它当作,就好像它是一张 真正的 CD-ROM 或者 DVD.当不再需要此映像文件后,记得卸载它.

#### 清除一张可重写入的 CD-ROM

可重写入的 CD-RW 媒介在被重使用之前需要擦除或清空.为此,我们可以用 `wodim` 命令,指定 设备名称和清空的类型.
`wodim` 程序提供了几种清空类型.最小(且最快)的是 `fast` 类型:

```bash
wodim dev=/dev/cdrw blank=fast
```

#### 写入镜像

写入一个映像文件,我们再次使用 `wodim` 命令,指定光盘设备名称和映像文件名:

```bash
wodim dev=/dev/cdrw image.iso
```

除了设备名称和映像文件之外,`wodim` 命令还支持非常多的选项.
常见的两个选项是,`-v` 可详细输出, 和`-dao` 以 `disk-at-once` 模式写入光盘.

如果你正在准备一张光盘为的是商业复制,那么应该使用这种模式.
`wodim` 命令的默认模式是 track-at-once,这对于录制音乐很有用.

拓展阅读

我们刚才谈到了很多方法,可以使用命令行管理存储介质.看看我们所讲过命令的手册页. 一些命令支持大量的选项和操作.
此外,寻找一些如何添加硬盘驱动器到 Linux 系统(有许多)的在线教程, 这些教程也要适用于光介质存储设备.

友情提示

通常验证一下我们已经下载的 iso 映像文件的完整性很有用处.
在大多数情况下,iso 映像文件的贡献者也会提供 一个 `checksum` 文件.
一个 `checksum` 是一个神奇的数学运算的计算结果,这个数学计算会产生一个能表示目标文件内容的数字.
如果目标文件的内容即使更改一个二进制位,`checksum` 的结果将会非常不一样. 

`生成checksum` 数字的最常见方法是使用 `md5sum` 程序.当你使用 `md5sum` 程序的时候, 它会产生一个独一无二的十六进制数字:

```bash
md5sum image.iso
34e354760f9bb7fbf85c96f6a3f94ece
image.iso
```

当你下载完映像文件之后,你应该对映像文件执行 `md5sum` 命令,然后把运行结果与发行商提供的 `md5sum` 数值作比较.

除了检查下载文件的完整性之外,我们也可以使用 `md5sum` 程序验证新写入的光学存储介质. 

为此,首先我们计算映像文件的 `checksum` 数值,然后计算此光学存储介质的 `checksum` 数值. 
这种验证光学介质的技巧是限定只对 光学存储介质中包含映像文件的部分计算 checksum 数值.
通过确定映像文件所包含的 2048 个字节块的数目(光学存储介质总是以 2048 个字节块的方式写入) 并从存储介质中读取那么多的字节块,我们就可以完成操作.

某些类型的存储介质,并不需要这样做.一个以 disk-at-once 模式写入的 CD-R,可以用下面的方式检验:

```bash
md5sum /dev/cdrom
34e354760f9bb7fbf85c96f6a3f94ece
/dev/cdrom
```

许多存储介质类型,如 DVD 需要精确地计算字节块的数目.

在下面的例子中,我们检验了映像文件 `dvd-image.iso `以及 DVD 光驱中磁盘 `/dev/dvd` 文件的完整性.
你能弄明白这是怎么回事吗?

```bash
md5sum dvd-image.iso
dd if=/dev/dvd bs=2048 count=$(( $(stat -c "%s" dvd-image.iso) / 2048 )) |  md5sum
```
