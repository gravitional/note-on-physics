# ubuntu-3

cmdline 第七章 重定向

## 重定向

+ `cat` --连接文件
+ `sort`--排序文本行
+ `uniq`--报道或忽略重复行
+ `grep`--打印匹配行
+ `wc`--打印文件中换行府，字，和字节个数
+ `head`--输出文件第一部分
+ `tail`--输出文件最后一部分

### 标准输入，输出和错误

Unix`一切皆文件`，程序，比如说`ls`，把它们的运行结果输送到一个叫做标准输出（`stdout`）的特殊文件，
把它们的状态信息送到另一个叫做标准错误（`stderr`）的文件。默认情况下，标准输出和标准错误都连接到屏幕，而不是保存到磁盘文件。

此外，许多程序从一个叫做标准输入（`stdin`）的设备得到输入。默认情况下，标准输入连接到键盘。

`I/O` 重定向允许我们可以更改输出走向和输入来向。
一般地,输出送到屏幕,输入来自键盘, 但是通过 `I/O` 重定向,我们可以改变输入输出方向。

### 重定向标准输出

`I/O` 重定向允许我们来重定义标准输出送到哪里。

重定向标准输出到另一个文件,我们使用 `>` 重定向符,其后跟着文件名。
把重定向结果追加到文件内容后面,而不是从开头重写文件, 我们使用`>>`重定向符,像这样:

```bash
ls -l /usr/bin >> ls-output.txt
```

### 重定向标准错误

重定向标准错误缺乏专用的重定向操作符。重定向标准错误,我们必须参考它的文件描述符。 
一个程序可以在几个编号的文件流中的任一个上产生输出。
然而我们必须把这些文件流的前三个看作标准输入,输出和错误, shell内部给它们的文件描述符分别为`0`,`1`和`2`。

可能有这种情况,我们希望捕捉一个命令的所有输出到一个文件。
为了完成这个,我们 必须同时重定向标准输出和标准错误。有两种方法。

第一个,传统的方法, 在旧版本 shell 中也有效:

```bash
ls -l /bin/usr > ls-output.txt 2>&1
```

使用这种方法,我们完成两个重定向。
首先重定向标准输出到文件 `ls-output.txt`,然后 重定向文件描述符`2`(标准错误)到文件描述符`1`(标准输出)使用表示法`2>&1`。注意重定向的顺序安排非常重要。标准错误的重定向必须总是出现在标准输出重定向之后,要不然它不起作用。

现在的 bash 版本提供了第二种方法,更精简合理的方法来执行这种联合的重定向。

```bash
ls -l /bin/usr &> ls-output.txt
```

在这个例子里面,我们使用单单一个表示法 `&>` 来重定向标准输出和错误到文件 ls-output.txt。

### 处理不需要的输出

有时候`沉默是金`,我们不想要一个命令的输出结果,只想把它们扔掉。

系统为我们提供了解决问题的方法,通过重定向输出结果 到一个特殊的叫做`/dev/null`的文件。
这个文件是系统设备,叫做位存储桶,它可以接受输入,并且对输入不做任何处理。
为了隐瞒命令错误信息,我们这样做:

```bash
ls -l /bin/usr 2> /dev/null
```

>Unix 文化中的/dev/null
>位存储桶是个古老的 Unix 概念,由于它的普遍性,它的身影出现在 Unix 文化的 许多部分。
>当有人说他/她正在发送你的评论到`/dev/null`,现在你应该知道那是 什么意思了。
>更多的例子,可以阅读 Wikipedia 关于`/dev/null`的文章。

### 重定向标准输入

`cat - 连接文件`

`cat `命令读取一个或多个文件,然后复制它们到标准输出,就像这样:`cat [file]`

`cat` 经常被用来显示简短的文本文件。因为 `cat` 可以 接受不只一个文件作为参数,所以它也可以用来把文件连接在一起。

比方说我们下载了一个大型文件,这个文件被分离成多个部分(`USENET` 中的多媒体文件经常以这种方式分离), 我们想把它们连起来。

```bash
cat movie.mpeg.0* > movie.mpeg
```

如果 `cat` 没有给出任何参数,它会从标准输入读入数据,因为标准输入,默认情况下,连接到键盘。
 它正在等待我们输入数据!试试这个:

```bash
cat
The quick brown fox jumped over the lazy dog.
```

下一步,输入 `Ctrl-d`(按住 `Ctrl` 键同时按下`d`),来告诉 `cat`,在标准输入中, 它已经到达文件末尾(EOF):
由于文件名参数的缺席,`cat` 复制标准输入到标准输出,所以我们看到文本行重复出现。 
我们可以使用这种行为来创建简短的文本文件。比方说,我们想创建一个叫做`lazy_dog.txt` 的文件,这个文件包含例子中的文本。
我们这样做:

```bash
cat > lazy_dog.txt
The quick brown fox jumped over the lazy dog.
```

输入命令,其后输入要放入文件中的文本。记住,最后输入`Ctrl-d`。通过使用这个命令,我们实现了世界上最低能的文字处理器!

现在我们知道怎讲接受标准输入:

```bash
cat < lazy_dog.txt
The quick brown fox jumped over the lazy dog.
```

使用`<`重定向操作符,我们把标准输入源从键盘改到文件 `lazy_dog.txt`。

`2.05b`版本以后，`bash`可以用下列语法重定向标准输入至字符串（称为here string）：

```bash
command <<< "string to be read as standard input"
```

如果字符串包括空格就需要用引号包裹字符串

### 管道线

命令可以从**标准输入**读取数据,然后再把数据输送到**标准输出**,
命令的这种能力被 一个 `shell` 特性所利用,这个特性叫做管道线。

使用管道操作符`|`(竖杠),一个命令的标准输出可以管道到另一个命令的标准输入:

```bash
command1 | command2
```

我们用 less 来一页一页地显示任何命令的输出,命令把它的运行结果输送到标准输出:

```bash
ls -l /usr/bin | less
```

这极其方便!使用这项技术,我们可以方便地检测会产生标准输出的任一命令的运行结果。

### 过滤器

管道线经常用来对数据完成复杂的操作。有可能会把几个命令放在一起组成一个管道线。 
通常,以这种方式使用的命令被称为过滤器。过滤器接受输入,以某种方式改变它,然后 输出它。

#### sort

第一个我们想试验的过滤器是 `sort`。

```bash
ls /bin /usr/bin | sort | less
```

因为我们指定了两个目录`(/bin` 和`/usr/bin`),`ls` 命令的输出结果由有序列表组成, 各自针对一个目录。
通过在管道线中包含 `sort`,我们改变输出数据,从而产生一个 有序列表。

### uniq - 报道或忽略重复行

`uniq` 命令经常和 `sort` 命令结合在一起使用。
`uniq` 从标准输入或单个文件名参数接受数据有序列表(详情查看`uniq`手册页),默认情况下,从数据列表中删除任何重复行。

```bash
ls /bin /usr/bin | sort | uniq | less
```

在这个例子中,我们使用 `uniq` 从 `sort` 命令的输出结果中,来删除任何重复行。

如果我们想看到 重复的数据列表,让 uniq 命令带上`-d`选项,就像这样:

```bash
ls /bin /usr/bin | sort | uniq -d | less
```

### wc - 打印行,字和字节数

`wc`(字计数)命令是用来显示文件所包含的行,字和字节数。例如:

```bash
wc ls-output.txt
7902 64566 503634 ls-output.txt
```

`wc` 打印出来三个数字:包含在文件 `ls-output.txt` 中的行数,单词数和字节数,.
正如我们先前的命令,如果 `wc` 不带命令行参数,它接受标准输入。
`-l`选项限制命令输出只能报道行数。

添加 `wc` 到管道线来统计数据,是个很便利的方法。

```bash
ls /bin /usr/bin | sort | uniq | wc -l
2728
```

### grep - 打印匹配行

grep 是个很强大的程序,用来找到文件中的匹配文本。这样使用 `grep` 命令:

```bash
grep pattern [file...]
```

当 grep 遇到一个文件中的匹配`模式`,它会打印出包含这个类型的行。
grep 能够匹配的模式可以很复杂(正则表达式),但是现在我们把注意力集中在简单文本匹配上面。

比如说,我们想在我们的程序列表中,找到文件名中包含单词`zip`的所有文件。
这样一个搜索, 可能让我们了解系统中的一些程序与文件压缩有关系。这样做:

```bash
ls /bin /usr/bin | sort | uniq | grep zip
```

grep 有一对方便的选项:
`-i`导致 `grep` 忽略大小写当执行搜索时(通常,搜索是大小写 敏感的),
`-v`选项会告诉 `grep` 只打印不匹配的行。

### head/tail - 打印文件开头部分/结尾部分

有时候你不需要一个命令的所有输出。可能你只想要前几行或者后几行的输出内容。
`head` 命令打印文件的前十行,而 `tail` 命令打印文件的后十行。
默认情况下,两个命令 都打印十行文本,但是可以通过`-n`选项来调整命令打印的行数。

```bash
head -n 5 ls-output.txt
tail -n 5 ls-output.txt
```

它们也能用在管道线中:

```bash
ls /usr/bin | tail -n 5
```

`tail` 有一个选项允许你实时的浏览文件。当观察日志文件的进展时,这很有用,因为它们同时在被写入。

在以下的例子里,我们要查看目录`/var/log`里面的信息文件。
在 一些 Linux 发行版中,要求有超级用户权限才能阅读这些文件,因为文件`/var/log/messages`可能包含安全信息。

```bash
tail -f /var/log/messages
Feb 8 13:40:05 twin4 dhclient: DHCPACK from 192.168.1.1
```

使用`-f`选项,`tail`命令继续监测这个文件,当新的内容添加到文件后,它们会立即出现在屏幕上。
这会一直继续下去直到你输入`Ctrl-c`。

### tee - 从 Stdin 读取数据,并同时输出到 Stdout 和文件

为了和我们的管道隐喻保持一致,Linux 提供了一个叫做 `tee` 的命令,这个命令制造了 一个`tee`,安装到我们的管道上。

`tee` 程序从标准输入读入数据,并且同时复制数据到**标准输出**(相当于允许数据继续随着管道线流动)和一个或多个文件。
当在某个中间处理阶段来捕捉一个管道线的内容时,这很有帮助。

这里,我们重复执行一个先前的例子, 这次包含 `tee` 命令,在 `grep` 过滤管道线的内容之前,来捕捉整个目录列表到文件 ls.txt:

```bash
ls /usr/bin | tee ls.txt | grep zip
bunzip2
bzip2
....
```

## 从shell眼中看世界

### 字符展开

传递到 echo 命令的任一个参数都会在(屏幕上)显示出来。 让我们试一个例子:

```bash
echo *
Desktop Documents ls-output.txt Music Pictures Public Templates Videos
```

为什么 `echo` 不打印` * `呢?答案就是在 `echo` 命令被执行前, shell 把` * `展开成了另外的东西(在这种情况下,就是在当前工作目录下的文件名字)。

当回车键被按下时,`shell` 在命令被执行前在命令行上自动展开任何符合条件的字符, 所以 `echo` 命令从不会发现` * `,只把它展开成结果。
知道了这个以后,我们能看到 `echo` 执行的结果和我们想象的一样。

### 路径名展开

这种通配符工作机制叫做路径名展开。我们能够执行以下参数展开模式:

```bash
echo D*
Desktop Documents
```

和:

```bash
echo *s
Documents Pictures Templates Videos
```

```bash
甚至是:
echo [[:upper:]]*
Desktop Documents Music Pictures Public Templates Videos
```

查看家目录之外的目录:

```bash
echo /usr/*/share
/usr/kerberos/share /usr/local/share
```

### 隐藏文件路径名展开

正如我们知道的,以圆点字符开头的文件名是隐藏文件。路径名展开也尊重这种 行为。像这样的展开:

```bash
echo *
```

不会显示隐藏文件。要是展开模式以一个圆点开头,我们就能够在展开模式中包含隐藏文件, 
而且隐藏文件可能会出现在第一位置,就像这样:

```bash
echo .*
```

然而,如果我们仔细检查一下输出结果,我们会看到名字`.` 和`..`也出现在结果中。
因为这些名字是指当前工作目录和它的父目录,使用这种 模式可能会产生不正确的结果。
我们能看到这样的结果,如果我们试一下这个命令:
`ls -d .* | less`
为了在这种情况下正确地完成路径名展开,我们应该使用一个更精确些的模式。 这个模式会正确地工作:
`ls -d .[!.]?*`
这种模式展开成为文件名,每个文件名以圆点开头,第二个字符不包含圆点,再包含至少一个字符, 并且这
个字符之后紧接着任意多个字符。

这将列出大多数的隐藏文件 (但仍将不能包含以多个圆点开头的文件名)

这个带有 `-A` 选项(`几乎所有`)的`ls`命令能够提供一份正确的隐藏文件清单:

```bash
ls -A
```

### 波浪线展开

可能你从我们对 cd 命令的介绍中回想起来,波浪线字符(` ~ `)有特殊的意思。
当它用在 一个单词的开头时,它会展开成指定用户的家目录名,如果没有指定用户名,则是当前用户的家目录:

```bash
echo ~
/home/me
```

如果有用户`foo`这个帐号,然后:

```bash
echo ~foo
/home/foo
```

### 算术表达式展开

`shell` 允许算术表达式通过展开来执行。这允许我们把 `shell` 提示当作计算器来使用:

```bash
echo $((2 + 2))
4
```

算术表达式展开使用这种格式:`$((expression))`

算术表达式只支持整数(全部是数字,不带小数点),但是能执行很多不同的操作。
这里是 一些它支持的操作符:

***
操作符 说明

+ `+` 加
+ `-` 减
+ `*` 乘
+ `/` 除(但是记住,因为展开只是支持整数除法,所以结果是整数。)
+ `%` 取余,只是简单的意味着,`余数`
+ `**` 取幂

在算术表达式中空格并不重要,并且表达式可以嵌套。例如,5的平方乘以3:

```
echo $(($((5**2)) * 3))
```

一对括号可以用来把多个子表达式括起来。通过这个技术,我们可以重写上面的例子:

```bash
echo $(((5**2) * 3))
```

这是一个使用除法和取余操作符的例子。注意整数除法的结果:

```bash
echo Five divided by two equals $((5/2))
Five divided by two equals 2
echo with $((5%2)) left over.
with 1 left over.
```

在35章会更深入的讨论算术表达式的内容。

### 花括号展开

可能最奇怪的展开是花括号展开。通过它,你可以从一个包含花括号的模式中创建多个文本字符串。例:

```bash
echo Front-{A,B,C}-Back
Front-A-Back Front-B-Back Front-C-Back
```

花括号展开模式可能包含一个开头部分叫做报头,一个结尾部分叫做附言。
花括号表达式本身可能包含一个由逗号分开的字符串列表,或者一系列整数,或者单个的字符串。
这种模式不能嵌入空白字符。这个例题使用了一系列整数:

```bash
echo Number_{1..5}
```

一系列以倒序排列的字母:

```bash
echo {Z..A}
```

花括号展开可以嵌套(会自动展平):

```bash
echo a{A{1,2},B{3,4}}b
```

那么这对什么有好处呢?最普遍的应用是,创建一系列的文件或目录列表。

```bash
mkdir {2007..2009}-0{1..9} {2007..2009}-{10..12}
```

### 参数展开

在这一章我们将会简单地介绍参数展开,只是皮毛而已。这个特性在shell 脚本中比直接在命令行中更有用。它的许多性能和系统存储小块数据,并给每块数据命名的能力有关系。

许多像这样的小块数据, 更适当些应叫做变量,可以方便地检查它们。
例如,叫做`USER`的变量包含你的用户名。唤醒参数展开,揭示 `USER` 中的内容,可以这样做:

```bash
echo $USER
me
```

查看有效的变量列表,试试这个:

```bash
printenv | less
```

你可能注意到其它展开类型,如果你误输入一个模式,展开就不会发生。
这时 `echo` 命令只简单地显示误键入的模式。通过参数展开,如果你拼写错了一个变量名, 展开仍然会进行,只是展成一个空字符串:

```bash
echo $SUER
```

### 命令替换

命令替换允许我们把一个命令的输出作为一个展开模式来使用:

```bash
echo $(ls)
```

我最喜欢用的一行命令是像这样的:

```bash
ls -l $(which cp)
-rwxr-xr-x 1 root root 71516 2007-12-05 08:58 /bin/cp
```

这里我们把 `which cp` 的执行结果作为一个参数传递给 `ls` 命令,因此要想得到 `cp` 程序的输出列表,
不必知道它完整的路径名。

我们不只限制于简单命令。也可以使用整个管道线 (只展示部分输出):

```bash
file $(ls /usr/bin/* | grep zip)
....
```

在这个例子中,管道线的输出结果成为 `file` 命令的参数列表。

在旧版 shell 程序中,有另一种语法也支持命令替换,可与刚提到的语法换使用。
`bash` 也支持这种语法。它使用倒引号来代替美元符号和括号:

```bash
ls -l `which cp`
```

### 引用

我们已经知道 shell 有许多方式可以完成展开,现在是时候学习怎样来控制展开了。 

#### 双引号

我们将要看一下引用的第一种类型,双引号。如果你把文本放在双引号中, `shell` 使用的特殊字符,
除了`\`(反斜杠),`$` ,和 `` ` ``(倒引号)之外, 则失去它们的特殊含义,被当作普通字符来看待。

这意味着

+ 单词分割,(空格)
+ 路径名展开, （`*``?`）
+ 波浪线展开,(`~`)
+ 和花括号展开(`{}`)

都被禁止,然而

+ 参数展开(`$USER`)
+ 算术展开(`(())`)
+ 命令替换`$()`

仍然执行。使用双引号,我们可以处理包含空格的文件名。
比方说我们是不幸的名为 `two words.txt` 文件的受害者。
如果我们试图在命令行中使用这个 文件,**单词分割机制**会导致这个文件名被看作两个独自的参数,而不是所期望的单个参数:

```bash
ls -l two words.txt
ls: cannot access two: No such file or directory
ls: cannot access words.txt: No such file or directory
```

使用双引号,我们可以阻止单词分割,得到期望的结果;进一步,我们甚至可以修复 破损的文件名。

```bash
ls -l `two words.txt`
mv `two words.txt` two_words.txt
```

记住,在双引号中,**参数展开**,**算术表达式展开**,和**命令替换**仍然有效:

```bash
echo `${USER} $((2+2)) $(cal)`
me 4
```

在默认情况下,单词分割机制会在单词中寻找**空格**,**制表符**,和**换行符**,并把它们看作单词之间的界定符。它们只作为分隔符使用。

如果我们加上双引号,单词分割被禁止,内嵌的空格也不会被当作界定符,它们成为参数的一部分。 
一旦加上双引号,我们的命令行就包含一个带有一个参数的命令。

考虑下面的例子:

```bash
echo $(cal)
echo `$(cal)`
```

在第一个实例中,没有引用的命令替换导致命令行包含`38`个参数。
在第二个例子中, 命令行只有一个参数,参数中包括嵌入的**空格**和**换行符**。

### 单引号

如果需要禁止所有的展开,我们使用单引号。以下例子是无引用,双引号,和单引号的比较结果:

```bash
echo text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER
echo `text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER`
echo 'text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER'
```

正如我们所看到的,随着引用程度加强,越来越多的展开被禁止。

### 转义字符

有时候我们只想引用单个字符。我们可以在字符之前加上一个反斜杠,在这个上下文中叫做转义字符。
经常在双引号中使用转义字符,来有选择地阻止展开。

```bash
echo `The balance for user $USER is: \$5.00`
The balance for user me is: $5.00
```

使用转义字符来消除文件名中一个字符的特殊含义,是很普遍的。例如,在文件名中可能使用一些对于 `shell` 来说,有特殊含义的字符。
这些字符包括`$`, `!`, `空格`等字符。
注意在单引号中,反斜杠失去它的特殊含义,它 被看作普通字符。

### 反斜杠转义字符序列

反斜杠除了作为转义字符外,反斜杠也是一种表示法的一部分,这种表示法代表某种特殊字符,叫做控制码。
`ASCII`编码表中前`32`个字符被用来把命令转输到像电报机一样的设备。

一些编码是众所周知的(制表符,退格符,换行符,和回车符),其它一些编码就不熟悉了(空值,传输结束码,和确认)。

***
转义序列 含义

+ `\a` : 响铃(`警告`-导致计算机嘟嘟响)
+ `\b` : 退格符
+ `\n` : 新的一行。在类 Unix 系统中,产生换行。
+ `\r` : 回车符
+ `\t` : 制表符

上表列出了一些常见的反斜杠转义字符。
反斜杠表示法背后的思想来源于 C 编程语言, 许多其它语言也采用了这种表示方法,包括 shell。

`echo` 命令带上 `-e` 选项,能够解释转义序列。你可以把转义序列放在`$' '`里面。 

以下例子,使用 `sleep` 命令,一个简单的程序,它会等待指定的秒数,然后退出。
我们可以创建一个简单的倒数计数器:

```bash
sleep 2; echo -e `Time's up\a`
```

我们也可以这样做:

```bash
sleep 2; echo `Time's up` /span>\a'
```

## 键盘高级操作技巧

以下命令将会露面：

+ `clear`
+ `history`

### 命令行编辑

Bash使用了一个名为`Readline`的库（共享的线程集合，可以被不同的程序使用），来实现命令行编辑。

利用历史命令

```bash
history | grep /usr/bin
```

可以通过类似`!88`的形式，引用历史命令。

## 权限

Unix 传统中的操作系统不同于那些 MS-DOS 传统中的系统,区别在于它们不仅是多任务系统,而且也是多用户系统。
这到底意味着什么?它意味着多个用户可以在同一时间使用同一台计算机。

例如,如果一台 计算机连接到一个网络或者因特网,那么远程用户通过`ssh`(安全 shell)可以登录并操纵这台电脑。
事实上,远程用户也能运行图形界面应用程序,并且图形化的输出结果会出现在远端的显示器上。 
`X`窗口系统把这个作为基本设计理念的一部分,并支持这种功能。

在这一章中,我们将看看这一系统安全的本质部分,会介绍以下命令:

+ `id` – 显示用户身份号
+ `chmod` – 更改文件模式
+ `umask` – 设置默认的文件权限
+ `su` – 以另一个用户的身份来运行 shell
+ `sudo` – 以另一个用户的身份来执行命令
+ `chown` – 更改文件所有者
+ `chgrp` – 更改文件组所有权
+ `passwd` – 更改用户密码

### 拥有者,组成员,和其他人

在第四章探究文件系统时,当我们试图查看一个像`/etc/shadow`那样的文件的时候,我们会遇到一个问题。

```bash
file /etc/shadow
/etc/shadow: regular file, no read permission
less /etc/shadow
/etc/shadow: Permission denied
```

产生这种错误信息的原因是,作为一个普通用户,我们没有权限来读取这个文件。

在 Unix 安全模型中,一个用户可能拥有文件和目录。
当一个用户拥有一个文件或目录时, 用户可以设置这个文件或目录的访问权限。
用户,反过来又属于用户组（由一个或多个用户组成），文件和目录的owner 可以对用户组成员授予对这些文件和目录的访问权限。
除了对一个用户组授予权限之外,owner 还能给其他人授予一些权限。在 Unix 术语中,每个人 是指整个世界。

可以用 `id` 命令,来找到关于你自己身份的信息:

```bash
id
uid=500(me) gid=500(me) groups=500(me)
```

让我们看一下输出结果。
当用户创建帐户之后,系统会给用户分配一个号码,叫做用户 `ID` 或者 `uid`,然后,为了符合人类的习惯,这个 `ID` 映射到一个用户名。

系统又会给这个用户分配一个原始的组 `ID` 或者是 `gid`,这个 `gid` 可能属于另外的组。

上面的例子来自于 `Fedora` 系统, 比方说 `Ubuntu` 的输出结果可能看起来有点儿不同:

```bash
id
uid=1000(me) gid=1000(me)
groups=4(adm),20(dialout),24(cdrom),25(floppy),29(audio),30(dip),44(v
ideo),46(plugdev),108(lpadmin),114(admin),1000(me)
```

正如我们能看到的,两个系统中用户的 `uid` 和 `gid` 号码是不同的。
原因很简单,因为 `Fedora` 系统 从500开始进行普通用户帐户的编号,而 `Ubuntu` 从1000开始。
我们也能看到 `Ubuntu` 的用户属于 更多的用户组。这和`Ubuntu` 管理系统设备和服务权限的方式有关系。

那么这些信息来源于哪里呢?像 `Linux` 系统中的许多东西一样,来自一系列的文本文件。

用户帐户定义在 `/etc/passwd` 文件里面,用户组定义在` /etc/group` 文件里面。

当用户帐户和用户组创建以后, 这些文件随着文件 `/etc/shadow` 的变动而修改,文件 /`etc/shadow` 包含了关于用户密码的信息。 

对于每个用户帐号,文件`/etc/passwd` 定义了用户(登录)名,`uid`,`gid`,帐号的真实姓名,家目录, 和登录 `shell`。如果你查看一下文件`/etc/passwd` 和文件`/etc/group` 的内容,你会注意到除了普通 用户帐号之外,还有超级用户(`uid 0`)帐
号,和各种各样的系统用户。

在下一章中,当我们讨论进程时,你会知道这些其他的`用户`是谁,实际上,他们相当忙碌。

然而许多像 Unix 的系统会把普通用户分配到一个公共的用户组中,例如`users`,
现在的 Linux 会创建一个独一无二的,只有一个成员的用户组,这个用户组与用户同名。
这样使某种类型的 权限分配更容易些。

### 读取,写入,和执行

对于文件和目录的访问权力是根据读访问,写访问,和执行访问来定义的。
如果我们看一下 `ls` 命令的输出结果,我们能得到一些线索,这是怎样实现的:

```bash
> foo.txt
ls -l foo.txt
-rw-rw-r-- 1 me me 0 2008-03-06 14:52 foo.txt
```

列表的前十个字符是文件的属性。这十个字符的第一个字符表明文件类型。
下表是你可能经常看到 的文件类型(还有其它的,不常见类型):

***
属性 文件类型

+ `-` 一个普通文件
+ `d` 一个目录
+ `l` 一个符号链接。注意对于符号链接文件,剩余的文件属性总是`rwxrwxrwx`,而且都是 虚拟值。
真正的文件属性是指符号链接所指向的文件的属性。
+ `c` 一个字符设备文件。这种文件类型是指按照字节流,来处理数据的设备。 比如说终端机,或者调制解调器
+ `b` 一个块设备文件。这种文件类型是指按照数据块,来处理数据的设备,例如一个硬盘,或者 CD-ROM 盘。
  
剩下的九个字符,叫做文件模式,代表着**文件所有者**,**文件组所有者**,和**其他人**的**读**,**写**,**执行**权限。

### chmod - 更改文件模式

更改文件或目录的模式(权限),可以利用 `chmod` 命令。
注意只有文件的所有者或者超级用户才能更改文件或目录的模式。
`chmod` 命令支持两种不同的方法来改变文件模式:八进制数字表示法,或 符号表示法。

首先我们讨论一下八进制数字表示法。

虽然我们能知道二进制的意义(因为计算机只有一个手指),但是八进制和十六进制对什么 好处呢? 
答案是为了人类的便利。许多时候,在计算机中,一小部分数据以二进制的形式表示。 
以 RGB 颜色为例来说明。大多数的计算机显示器,每个像素由三种颜色组成:`8`位红色,`8`位绿色, `8`位蓝色。
这样,一种可爱的中蓝色就由24位数字来表示:`010000110110111111001101`

我不认为你每天都喜欢读写这类数字。另一种数字系统对我们更有帮助。
每个十六进制 数字代表四个二进制。在八进制中,每个数字代表三个二进制数字。
那么代表中蓝色的`24`位 二进制能够压缩成`6`位十六进制数:`436FCD`

因为十六进制中的两个数字对应二进制的`8`位数字,我们可以看到`43`代表红色,`6F`代表绿色,`CD`代表蓝色。

现在,十六进制表示法(经常叫做`hex`)比八进制更普遍,但是我们很快会看到,
用八进制 来表示`3`个二进制数非常有用处...

通过八进制表示法,我们使用八进制数字来设置所期望的权限模式。
因为每个八进制数字代表了`3`个二进制数字,这种对应关系,正好映射到用来存储文件模式所使用的方案上。
下表展示了 我们所要表达的意思:

Octal Binary File Mode

+ `0` `000` `---`
+ `1` `001` `--x`
+ `2` `010` `-w-`
+ `3` `011` `-wx`
+ `4` `100` `r--`
+ `5` `101` `r-x`
+ `6` `110` `rw-`
+ `7` `111` `rwx`

+ `r`:`4`
+ `w`:`2`
+ `x`:`1`

通过使用`3`个八进制数字,我们能够设置**文件所有者**,**文件的用户组**,和**其他人**的权限:

```bash
> foo.txt
ls -l foo.txt
chmod 600 foo.txt
```

通过传递参数 `600`,我们能够设置文件所有者的权限为读写权限,而删除**用户组**和**其他人**的所有权限。
虽然八进制到二进制的映射看起来不方便,但通常只会用到一些常见的映射关系: 

+ `7`: `rwx`
+ `6` :`rw-`
+ `5`: `r-x`
+ `4`:`r--`
+ `0`:`---`
  
`chmod` 命令支持一种符号表示法,来指定文件模式。

符号表示法分为三部分:更改会影响谁, 要执行哪个操作,要设置哪种权限。
通过字符 `u`,`g`,`o`,和 `a`的组合来指定 要影响的对象,如下所示:

+ `u` `user`的简写,意思是文件或目录的所有者。
+ `g` 用户组
+ `o` `others`的简写,意思是其他所有的人
+ `a` `all`的简写,是`u`, `g`和`o`三者的联合

如果没有指定字符,则假定使用`all`。

执行的操作可能是一个`+`字符,表示加上一个权限, 
一个`-`,表示删掉一个权限,
或者是一个`=`,表示只有指定的权限可用,其它所有的权限被删除。
权限由 `r`,`w`,和 `x` 来指定。

这里是一些符号表示法的实例:

+ `u+x` 为文件所有者添加可执行权限。
+ `u-x` 删除文件所有者的可执行权限。
+ `+x` 为文件所有者,用户组,和其他所有人添加可执行权限。 等价于 `a+x`。
+ `o-rw` 除了文件所有者和用户组,删除其他人的读权限和写权限。
+ `go=rw` 给群组的主人和任意文件拥有者的人读写权限。如果群组的主人或全局之前已
经有了执行的权限,他们将被移除。
+ `u+x,go=rw` 给文件拥有者执行权限并给组和其他人读和执行的权限。多种设定可以用逗号分开。
  
一些人喜欢使用八进制表示法,而另些人真正地喜欢符号表示法。
符号表示法的优点是, 允许你设置文件模式的单个组成部分的属性,而没有影响其他的部分。

要注意`chmod`的`--recursive`选项: 它可以同时作用于文件和目录,所以它并不是如我们期望的那么有用处,
因为我们很少希望文件和目录拥有同样的权限。

### umask - 设置默认权限

当创建一个文件时,`umask` 命令控制着文件的默认权限。
`umask` 命令使用八进制表示法来表达从文件模式属性中删除一个位掩码。大家看下面的例子:

```bash
rm -f foo.txt
umask
:0002
>foo.txt
ls -l foo.txt
:-rw-rw-r-- 1 me me 0 2008-03-06 14:53 foo.txt
```

首先,删除文件`foo.txt`,确保我们从新开始。下一步,运行不带参数的 `umask` 命令, 看一下当前的掩码值。
`umask`的数值是`0002`(`0022`是另一个常用值),这个数值是掩码的八进制表示形式。
下一步,我们创建文件`foo.txt`,并且保留它的权限。

我们可以看到文件所有者和用户组都得到读权限和写权限,而其他人只是得到读权限。
其他人没有得到写权限的原因是由掩码值决定的。重复我们的实验,这次自己设置掩码值:

```bash
rm foo.txt
umask 0000
> foo.txt
ls -l foo.txt
-rw-rw-rw- me me 0 2008-03-06 14:58 foo.txt
```

当掩码设置为`0000`(实质上是关掉它)之后,我们看到其他人能够读写文件。
为了弄明白这是 怎么回事,我们需要看一下掩码的八进制形式。把掩码展开成二进制形式,然后与文件属性相比较,看看有什么区别:

| | |
|---|---|
| Original file mode | `--- rw- rw- rw-` |
| Mask | `000 000 000 010` |
| Result | `--- rw- rw- r--` |

此刻先忽略掉开头的三个零(我们一会儿再讨论),注意掩码中若出现一个数字`1`,
则 删除文件模式中和这个`1`在相同位置的属性,在这是指其他人的写权限。这就是掩码要完成的任务。
掩码的二进制形式中,出现数字`1`的位置,相应地关掉一个文件模式属性。

看一下掩码0022的作用:

| | |
|---|---|
| Original file mode | `--- rw- rw- rw-` |
| Mask| `000 000 010 010`|
| Result | `--- rw- r-- r--` |

又一次,二进制中数字`1`出现的位置,相对应的属性被删除。
再试一下其它的掩码值(一些带数字7的) ,习惯于掩码的工作原理。当你实验完成之后,要记得清理现场:

```bash
rm foo.txt; umask 0002
```

大多数情况下,你不必修改掩码值,系统提供的默认掩码值就很好了。
然而,在一些高安全级别下,你要能控制掩码值。

### 一些特殊权限

虽然我们通常看到一个八进制的权限掩码用三位数字来表示,但是从技术层面上来讲, 用四位数字来表示它更确切些。
为什么呢?因为,除了读取,写入,和执行权限之外,还有其它的,较少用到的权限设置。

其中之一是 `setuid` 位(八进制`4000`)。
当一个普通用户运行一个程序,这个程序由根用户(`root`) 所有,并且设置了 `setuid` 位,
那么这个程序运行时就具有超级用户的特权,这样程序就可以访问普通用户禁止访问的文件和目录。

第二个是 `setgid` 位(八进制`2000`),这个类似 `setuid` 位.
如果设置了一个**目录**的`setgid`位,则目录中新创建的文件的用户组继承自`父目录`。

第三个是 `sticky` 位(八进制`1000`)。这个继承于Unix,在 Unix 中,它可能把一个可执行文件 标志为`不可交换的`。
在 Linux 中,会忽略文件的 `sticky` 位,但是如果一个目录设置了 `sticky` 位, 那么它能阻止用户删除或重命名文件,
除非用户是这个目录(文件)的所有者，或是超级用户。这个经常用来控制访问共享目录,比方说`/tmp`。

这里有一些例子,使用`chmod`命令和符号表示法,来设置这些特殊的权限。
首先, 授予一个程序 `setuid` 权限。

```bash
chmod u+s program
```

下一步,授予一个目录 `setgid` 权限:

```bash
chmod g+s dir
```

最后,授予一个目录 `sticky` 权限:

```bash
chmod +t dir
```

当浏览 `ls` 命令的输出结果时,你可以确认这些特殊权限。

+ 具有 `setuid`属性的程序:`-rwsr-xr-x`
+ 具有 `setgid`属性的目录:`drwxrwsr-x`
+ 具有 `sticky` 属性的目录:`drwxrwxrwt`

### 更改身份

在不同的时候,我们会发现很有必要具有另一个用户的身份。
经常地,我们想要得到超级 用户特权,来执行一些管理任务,但是也有可能变为另一个普通用户,比如说测试一个帐号。
有三种方式,可以拥有多重身份:

1. 注销系统并以其他用户身份重新登录系统。
2. 使用 `su` 命令。
3. 使用 `sudo` 命令。
   
我们将跳过第一种方法,因为我们知道怎样使用它,并且它缺乏其它两种方法的方便性。 
在我们自己的 `shell` 会话中, `su` 命令允许你,
假定为另一个用户的身份,以这个用户的 `ID` 启动一个新的 `shell` 会话,或者是以这个用户的身份来发布一个命令。

`sudo` 命令允许管理员设置一个叫做`/etc/sudoers`的配置文件,并且定义了一些具体命令,特殊用户可以执行这些命令。
选择使用哪个命令,很大程度上是由你使用的 `Linux` 发行版来决定的。 
你的发行版可能这两个命令都包含,但系统配置可能会偏袒其中之一。我们先介绍 `su` 命令。

#### su - 以其他用户身份和组ID运行一个shell

su 命令用来以另一个用户的身份来启动 shell。这个命令语法看起来像这样:

```bash
su [-[l]] [user]
```

如果包含`-l`选项,那么会为指定用户启动一个需要登录的 `shell` 。
这意味着会加载此用户的 `shell` 环境, 并且工作目录会更改到这个用户的家目录。这通常是我们所需要的。
如果不指定用户,那么就假定是超级用户。
注意,选项`-l`可以缩写为`-`,这是经常用到的形式。启动超级用户的 shell, 我们可以这样做:

```bash
su -
Password:
[root@linuxbox ~]#
```

按下回车符之后,`shell` 提示我们输入超级用户的密码。
如果密码输入正确,出现一个新的 `shell` 提示符, 这表明这个 `shell` 具有超级用户特权(提示符的末尾字符是`#`而不是`$`),
并且当前工作目录是超级用户的家目录 (通常是`/root`)。
一旦进入一个新的 `shell`,我们能执行超级用户所使用的命令。当工作完成后, 输入`exit`,则返回到原来的 `shell`:

```bash
[root@linuxbox ~]# exit
[me@linuxbox ~]$
```

以这样的方式使用 `su` 命令,也可以只执行单个命令,而不是启动一个新的可交互的 shell:

```bash
su -c 'command'
```

使用这种模式,命令传递到一个新 `shell` 中执行。
把命令用单引号引起来很重要,因为我们不想命令在我们的 `shell` 中展开,但需要在新 `shell` 中展开。

```bash
su -c 'ls -l /root/*'
```

#### sudo - 以另一个用户身份执行命令

`sudo` 命令在很多方面都相似于 `su` 命令,但是 `sudo` 还有一些非常重要的功能。

管理员能够配置 `sudo` 命令,从而允许一个普通用户以不同的身份(通常是超级用户),通过一种非常可控的方式来执行命令。
尤其是,只有一个用户可以执行一个或多个特殊命令时,(更体现了 `sudo` 命令的方便性)。

另一个重要差异是 `sudo` 命令不要求超级用户的密码。使用 `sudo` 命令时,用户使用他/她自己的密码 来认证。
比如说,例如,`sudo` 命令经过配置,允许我们运行一个虚构的备份程序,叫做`backup_script`, 这个程序要求超级用户权限。
通过 `sudo` 命令,这个程序会像这样运行:

```bash
sudo backup_script
Password:
System Backup Starting...
```

按下回车键之后,`shell` 提示我们输入我们的密码(不是超级用户的)。一旦认证完成,则执行 具体的命令。

`su` 和 `sudo` 之间的一个重要区别是 `sudo` 不会重新启动一个 `shell`,也不会加载另一个 用户的 `shell` 运行环境。
这意味者命令不必用单引号引起来。注意通过指定各种各样的选项,这 种行为可以被推翻。
详细信息,阅读 `sudo` 手册页。

想知道 `sudo` 命令可以授予哪些权限,使用`-l`选项,列出所有权限:

```bash
sudo -l
User me may run the following commands on this host:
(ALL) ALL
```

> Ubuntu 与 sudo

`Unix` 采取的方法是只有在需要的时候,才授予普通用户超级用户权限。这样,普遍会 用到 `su` 和 `sudo` 命令。

几年前,大多数的 Linux 发行版都依赖于 `su` 命令,来达到目的。`su` 命令不需要 `sudo` 命令 所要求的配置, `su` 命令拥有一个 `root` 帐号,是 Unix 中的传统。

但这会引起问题。所有用户会企图以 `root` 用户帐号来操纵系统。
事实上,一些用户专门以 `root` 用户帐号来操作系统, 因为这样做,的确消除了所有那些讨厌的权限
被拒绝的消息。相比于 `Windows` 系统安全性而言, 这样做,你就削弱了 `Linux` 系统安全性能。

当引进 `Ubuntu` 的时候,它的创作者们采取了不同的策略。
默认情况下,`Ubuntu` 不允许用户登录到 `root`帐号(因为不能为 `root` 帐号设置密码),而是使用 `sudo` 命令授予普通用户超级用户权限。 

通过 `sudo` 命令,最初的用户可以拥有超级用户权限,也可以授予随后的用户帐号相似的权力。

### chown - 更改文件所有者和用户组

`chown` 命令被用来更改文件或目录的所有者和用户组。使用这个命令需要超级用户权限。
`chown` 命令 的语法看起来像这样:

```bash
chown [owner][:[group]] file...
```

`chown `命令可以更改文件所有者和/或文件用户组,依据于这个命令的第一个参数。这里有 一些例子:

***
参数 结果

+ `bob` 把文件所有者从当前属主更改为用户`bob`
+ `bob:users` 把文件所有者改为用户 `bob`,文件用户组改为用户组 `users`。
+ `:admins` 把文件用户组改为组 `admins`,文件所有者不变。
+ `bob:` 文件所有者改为用户 `bob`,文件用户组改为`bob` 登录系统时所属的用户组。
  
比方说,我们有两个用户: `janet`(拥有超级用户访问权限),`tony`(没有)。

用户`janet`想要从 她的家目录复制一个文件到用户 `tony` 的家目录。
因为用户 `janet` 想要 `tony`能够编辑这个文件, `janet` 把这个文件的所有者更改为`tony`:

```bash
[janet@linuxbox ~]$ sudo cp myfile.txt ~tony
[janet@linuxbox ~]$ sudo ls -l ~tony/myfile.txt
-rw-r--r-- 1 root root 8031 2008-03-20 14:30 /home/tony/myfile.txt
[janet@linuxbox ~]$ sudo chown tony: ~tony/myfile.txt
[janet@linuxbox ~]$ sudo ls -l ~tony/myfile.txt
-rw-r--r-- 1 tony tony 8031 2008-03-20 14:30 /home/tony/myfile.txt
```

这里,我们看到用户 `janet` 把文件从她的目录复制到 `tony` 的家目录。
下一步,`janet` 把文件所有者 从 `root`(因为使用了`sudo` 命令)改到 `tony`。
通过在第一个参数中使用末尾的`:`字符,`janet` 同时把文件用户组改为`tony` 登录系统时所属的用户组(也叫`tony`)。

注意,第一次使用 `sudo` 命令之后,为什么(`shell`)没有提示 `janet` 输入她的密码?
这是因为在 大多数的配置中,`sudo` 命令会相信你几分钟,直到计时结束。

### chgrp - 更改用户组所有权

在旧版 Unix 系统中,`chown` 命令只能更改文件所有权,而不是用户组所有权。
为了达到目的, 使用一个独立的命令,`chgrp` 来完成。除了限制多一点之外,`chgrp` 命令与 `chown` 命令使用起来很相似。

### 练习使用权限

我们将展示一个常见问题的解决方案,这个问题是如何设置一个共享目录。
假想我们有两个用户, 他们分别是 `bill` 和 `karen`。他们都有音乐 CD 收藏品,也愿意设置一个共享目录。
在这个共享目录中,他们分别以 `Ogg Vorbis` 或 `MP3` 的格式来存储他们的音乐文件。
通过 `sudo` 命令, 用户 `bill` 具有超级用户访问权限。

我们需要做的第一件事,是创建一个以 `bill` 和 `karen` 为成员的用户组。
下一步,`bill` 创建了存储音乐文件的目录:`sudo mkdir /usr/local/share/Music`

因为 `bill` 正在他的家目录之外操作文件,所以需要超级用户权限。这个目录创建之后,它具有以下所有权和权限:

```bash
ls -ld /usr/local/share/Music
drwxr-xr-x 2 root root 4096 2008-03-21 18:05 /usr/local/share/Music
```

正如我们所见到的,这个目录由 `root` 用户拥有,并且具有权限`755`。
为了使这个目录共享,允许(用户 `karen`)写入,`bill` 需要更改目录用户组所有权和权限:

```bash
[bill@linuxbox ~]$ sudo chown :music /usr/local/share/Music
[bill@linuxbox ~]$ sudo chmod 775 /usr/local/share/Music
[bill@linuxbox ~]$ ls -ld /usr/local/share/Music
drwxrwxr-x 2 root music 4096 2008-03-21 18:05 /usr/local/share/Music
```

那么这是什么意思呢? 它的意思是,现在我们拥有一个目录,`/usr/local/share/Music`,
这个目录由 `root` 用户拥有,并且允许用户组 `music` 读取和写入。

用户组 `music` 有两个成员 `bill` 和 `karen`,这样 `bill` 和 `karen` 能够在目录 `/usr/local/share/Music` 中创建文件。其他用户能够列出目录中的内容,但是不能在其中创建文件。

但是我们仍然会遇到问题。
通过我们目前所拥有的权限,在 `Music` 目录中创建的文件,只具有用户 `bill` 和 `karen` 的普通权限:

```bash
[bill@linuxbox ~]$ > /usr/local/share/Music/test_file
[bill@linuxbox ~]$ ls -l /usr/local/share/Music
-rw-r--r-- 1 bill bill 0 2008-03-24 20:03 test_file
```

实际上,存在两个问题。
第一个,系统中默认的掩码值是`0022`,这会禁止用户组成员编辑属于同组成员的文件。
如果共享目录中只包含文件,这就不是个问题,但是因为这个目录将会存储音乐, 通常音乐会按照艺术家和唱片的层次结构来组织分类。
所以用户组成员需要在同组其他成员创建的目录中创建文件和目录。
我们将把用户 `bill` 和 `karen` 使用的掩码值改为`0002`。

第二个问题是,`bill`创建的文件（或目录）的用户组会被设置为`bill`,而不是`music`用户组 。 
通过设置此目录的 `setgid` 位来解决这个问题:

```bash
[bill@linuxbox ~]$ sudo chmod g+s /usr/local/share/Music
[bill@linuxbox ~]$ ls -ld /usr/local/share/Music
drwxrwsr-x 2 root music 4096 2008-03-24 20:03 /usr/local/share/Music
```

现在测试一下,看看是否新的权限解决了这个问题。
`bill` 把他的掩码值设为`0002`,删除 先前的测试文件,并创建了一个新的测试文件和目录:

```bash
[bill@linuxbox ~]$ umask 0002
[bill@linuxbox ~]$ rm /usr/local/share/Music/test_file
[bill@linuxbox ~]$ > /usr/local/share/Music/test_file
[bill@linuxbox ~]$ mkdir /usr/local/share/Music/test_dir
[bill@linuxbox ~]$ ls -l /usr/local/share/Music
drwxrwsr-x 2 bill music 4096 2008-03-24 20:24 test_dir
-rw-rw-r-- 1 bill music 0 2008-03-24 20:22 test_file
```

现在,创建的文件和目录都具有正确的权限,允许用户组 `music` 的所有成员在目录 `Music` 中创建文件和目录。

剩下一个问题是关于 `umask` 命令的。
`umask` 命令设置的掩码值只能在当前 `shell` 会话中生效,若当前 `shell` 会
话结束后,则必须重新设置。在这本书的第三部分,我们将看一下,怎样使掩码值永久生效。

### 更改用户密码

这一章最后一个话题,我们将讨论自己帐号的密码(和其他人的密码,如果你具有超级用户权限)。 
使用 `passwd` 命令,来设置或更改用户密码。命令语法如下所示:

```bash
passwd [user]
```

只要输入 `passwd` 命令,就能更改你的密码。`shell` 会提示你输入你的旧密码和你的新密码:

```bash
passwd
(current) UNIX password:
New UNIX password:
```

passwd 命令将会试着强迫你使用`强`密码。
这意味着,它会拒绝接受太短的密码,与先前相似的密码, 字典中的单词作为密码,或者是太容易猜到的密码:

如果你具有超级用户权限,你可以指定一个用户名作为 `passwd` 命令的参数,这样可以设置另一个用户的密码。

还有其它的 `passwd` 命令选项对超级用户有效,允许帐号锁定,密码失效,等等。 
详细内容,参考 passwd 命令的手册页。

## Linux 用户和用户组管理

[Linux 用户和用户组管理][]

[Linux 用户和用户组管理]: https://www.runoob.com/linux/linux-user-manage.html

Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，
都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。

用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；
另一方面也可以帮助用户组织文件，并为用户提供安全性保护。
每个用户账号都拥有一个唯一的用户名和各自的口令。用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。

实现用户账号的管理，要完成的工作主要有如下几个方面：

+ 用户账号的添加、删除与修改。
+ 用户口令的管理。
+ 用户组的管理。 

### Linux系统用户账号的管理

用户账号的管理工作主要涉及到用户账号的添加、修改和删除。

添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录Shell等资源。
刚添加的账号是被锁定的，无法使用。

***
添加新的用户账号使用useradd命令，其语法如下：

```bash
useradd 选项 用户名
```

选项:

+ `-c comment`  指定一段注释性描述。
+ `-d 目录`  指定用户主目录，如果此目录不存在，则同时使用`-m`选项，可以创建主目录。
+ `-g 用户组`  指定用户所属的用户组。
+ `-G用户组，用户组` 指定用户所属的附加组。
+ `-s Shell文件`  指定用户的登录Shell。
+ `-u 用户号`  指定用户的用户号，如果同时有`-o`选项，则可以重复使用其他用户的标识号。

用户名:   指定新账号的登录名。

***
实例1

```bash
useradd –d  /home/sam -m sam
```

此命令创建了一个用户`sam`，其中`-d`和`-m`选项用来为登录名`sam`产生一个主目录 `/home/sam`
(`/home`为默认的用户主目录所在的父目录)

***
实例2

```bash
useradd -s /bin/sh -g group –G adm,root gem
```

此命令新建了一个用户`gem`，该用户的登录`Shell`是` /bin/sh`，
它属于`group`用户组，同时又属于`adm`和`root`用户组，其中`group`用户组是其主组。

这里可能新建组：`groupadd group`及`groupadd adm`

增加用户账号就是在`/etc/passwd`文件中为新用户增加一条记录，同时更新其他系统文件如`/etc/shadow`, `/etc/group`等。

Linux提供了集成的系统管理工具`userconf`，它可以用来对用户账号进行统一管理。

### 删除帐号

如果一个用户的账号不再使用，可以从系统中删除。
删除用户账号就是要将`/etc/passwd`等系统文件中的该用户记录删除，必要时还删除用户的主目录。

删除一个已有的用户账号使用`userdel`命令，其格式如下：

```
userdel 选项 用户名
```

常用的选项是 `-r`，它的作用是把用户的主目录一起删除。例如：

```bash
userdel -r sam
```

此命令删除用户`sam`在系统文件中（主要是`/etcpasswd/`, `/etc/shadow`, `/etc/group`等）的记录，同时删除用户的主目录。

## 修改帐号

修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。

修改已有用户的信息使用`usermod`命令，其格式如下：

```bash
usermod 选项 用户名
```

常用的选项包括`-c,` `-d`, `-m`,` -g`,` -G`,` -s`,`-u`以及`-o`等，这些选项的意义与`useradd`命令中的选项一样，可以为用户指定新的资源值。

另外，有些系统可以使用选项：`-l 新用户名`
这个选项指定一个新的账号，即将原来的用户名改为新的用户名。

例如：

```bash
usermod -s /bin/ksh -d /home/z –g developer sam
```

此命令将用户`sam`的登录`Shell`修改为`ksh`，主目录改为`/home/z`，用户组改为`developer`。

### 用户口令的管理

用户管理的一项重要内容是用户口令的管理。
用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。

指定和修改用户口令的Shell命令是`passwd`。
超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。命令的格式为：

```bash
passwd 选项 用户名
```

可使用的选项：

+ `-l` 锁定口令，即禁用账号。
+ `-u` 口令解锁。
+ `-d` 使账号无口令。
+ `-f` 强迫用户下次登录时修改口令。

如果默认用户名，则修改当前用户的口令。

例如，假设当前用户是`sam`，则下面的命令修改该用户自己的口令：

```bash
$ passwd 
Old password:****** 
New password:******* 
Re-enter new password:*******
```

如果是超级用户，可以用下列形式指定任何用户的口令：

```bash
passwd sam 
New password:******* 
Re-enter new password:*******
```

普通用户修改自己的口令时，`passwd`命令会先询问原口令，验证后再要求用户输入两遍新口令，
如果两次输入的口令一致，则将这个口令指定给用户；而超级用户为用户指定口令时，就不需要知道原口令。

为了系统安全起见，用户应该选择比较复杂的口令，例如最好使用`8`位长的口令，口令中包含有大写、小写字母和数字，并且应该与姓名、生日等不相同。

为用户指定空口令时，执行下列形式的命令：

```bash
passwd -d sam
```

此命令将用户 `sam` 的口令删除，这样用户 `sam` 下一次登录时，系统就不再允许该用户登录了。

`passwd` 命令还可以用 `-l(lock)` 选项锁定某一用户，使其不能登录，例如：

```bash
passwd -l sam
```

### Linux系统用户组的管理

每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。
不同Linux 系统对用户组的规定有所不同，如 ubuntu 下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。

用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对`/etc/group`文件的更新。

***
增加一个新的用户组使用`groupadd`命令。其格式如下：

```bash
groupadd 选项 用户组
```

可以使用的选项有：

+ `-g` `GID` 指定新用户组的组标识号（GID）。
+ `-o` 一般与`-g`选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。

***
实例1：

```bash
groupadd group1
```

此命令向系统中增加了一个新组`group1`，新组的组标识号是在当前已有的最大组标识号的基础上加`1`。

实例2：

```bash
groupadd -g 101 group2
```

此命令向系统中增加了一个新组`group2`，同时指定新组的组标识号是`101`。

***
如果要删除一个已有的用户组，使用`groupdel`命令，其格式如下：

```bash
groupdel 用户组
```

例如：

```bash
groupdel group1
```

此命令从系统中删除组`group1`。

***
修改用户组的属性使用`groupmod`命令。其语法如下：

```bash
groupmod 选项 用户组
```

常用的选项有：

+ `-g GID` 为用户组指定新的组标识号。
+ `-o`  与`-g`选项同时使用，用户组的新`GID`可以与系统已有用户组的`GID`相同。
+ `-n 新用户组`  将用户组的名字改为新名字

实例1：

```bash
groupmod -g 102 group2
```

此命令将组`group2`的组标识号修改为102。

实例2：

```bash
groupmod –g 10000 -n group3 group2
```

此命令将组`group2`的标识号改为`10000`，组名修改为`group3`。

***
如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。
用户可以在登录后，使用命令`newgrp`切换到其他用户组，这个命令的参数就是目的用户组。例如：

```bash
$ newgrp root
```

这条命令将当前用户切换到`root`用户组，前提条件是`root`用户组确实是该用户的主组或附加组。
类似于用户账号的管理，用户组的管理也可以通过集成的系统管理工具来完成。

### 与用户账号有关的系统文件

完成用户管理的工作有许多种方法，但是每一种方法实际上都是对有关的系统文件进行修改。

与用户和用户组相关的信息都存放在一些系统文件中，这些文件包括`/etc/passwd`, `/etc/shadow`, `/etc/group`等。

下面分别介绍这些文件的内容。

#### /etc/passwd文件

`/etc/passwd`文件是用户管理工作涉及的最重要的一个文件

Linux系统中的每个用户都在`/etc/passwd`文件中有一个对应的记录行，它记录了这个用户的一些基本属性。

这个文件对所有用户都是可读的。它的内容类似下面的例子：

```bash
＃ cat /etc/passwd
root:x:0:0:Superuser:/:
daemon:x:1:1:System daemons:/etc:
bin:x:2:2:Owner of system commands:/bin:
sys:x:3:3:Owner of system files:/usr/sys:
adm:x:4:4:System accounting:/usr/adm:
uucp:x:5:5:UUCP administrator:/usr/lib/uucp:
auth:x:7:21:Authentication administrator:/tcb/files/auth:
cron:x:9:16:Cron daemon:/usr/spool/cron:
listen:x:37:4:Network daemon:/usr/net/nls:
lp:x:71:18:Printer administrator:/usr/spool/lp:
sam:x:200:50:Sam san:/home/sam:/bin/sh
```

从上面的例子我们可以看到，`/etc/passwd`中一行记录对应着一个用户，
每行记录又被冒号(`:`)分隔为7个字段，其格式和具体含义如下：

`用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell`

1. `用户名`是代表用户账号的字符串。

通常长度不超过`8`个字符，并且由大小写字母或数字组成。登录名中不能有冒号(`:`)，因为冒号在这里是分隔符。
为了兼容起见，登录名中最好不要包含点字符(`.`)，并且不使用连字符(`-`)和加号(`+`)打头。

1. `口令`一些系统中，存放着加密后的用户口令字。

虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于`/etc/passwd`文件对所有用户都可读，所以这仍是一个安全隐患。
因此，现在许多Linux 系统（如`SVR4`）都使用了 `shadow` 技术，把真正的加密后的用户口令字存放到`/etc/shadow`文件中，而在`/etc/passwd`文件的口令字段中只存放一个特殊的字符，例如`x`或者`*`。

3. `用户标识号`是一个整数，系统内部用它来标识用户。
一般情况下它与用户名是一一对应的。
如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等。

通常用户标识号的取值范围是`0`~`65 535`。`0`是超级用户`root`的标识号，`1`~`99`由系统保留，作为管理账号，普通用户的标识号从`100`开始。在Linux系统中，这个界限是`500`。

4. `组标识号`字段记录的是用户所属的用户组。

它对应着`/etc/group`文件中的一条记录。

5. `注释性描述`字段记录着用户的一些个人情况。

例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux 系统中，这个字段的格式并没有统一。
在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用做`finger`命令的输出。

6. `主目录`，也就是用户的起始工作目录。

它是用户在登录到系统之后所处的目录。
在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。
各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。

7. 用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即`Shell`。

`Shell`是用户与Linux系统之间的接口。Linux的`Shell`有许多种，每种都有不同的特点。
常用的有`sh`(Bourne Shell), `csh`(C Shell), `ksh`(Korn Shell), `tcsh`(TENEX/TOPS-20 type C Shell), `bash`(Bourne Again Shell)等。

系统管理员可以根据系统情况和用户习惯为用户指定某个`Shell`。
如果不指定`Shell`，那么系统使用`sh`为默认的登录`Shell`，即这个字段的值为`/bin/sh`。

用户的登录`Shell`也可以指定为某个特定的程序（此程序不是一个命令解释器）。
利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。
有些`Linux`系统要求只有那些在系统中登记了的程序才能出现在这个字段中。

8. 系统中有一类用户称为伪用户（pseudo users）。

这些用户在`/etc/passwd`文件中也占有一条记录，但是不能登录，因为它们的登录`Shell`为空。
它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。

常见的伪用户如下所示：

+ `bin`:  拥有可执行的用户命令文件 
+ `sys`:  拥有系统文件 
+ `adm`:  拥有帐户文件 
+ `uucp`:  `UUCP`使用 
+ `lp`:  `lp`或`lpd`子系统使用 
+ `nobody`:  `NFS`使用

#### 拥有帐户文件

+ 除了上面列出的伪用户外，还有许多标准的伪用户，例如：`audit`, `cron`, `mail`, `usenet`等，它们也都各自为相关的进程和文件所需要。

由于`/etc/passwd`文件是所有用户都可读的，如果用户的密码太简单或规律比较明显的话，一台普通的计算机就能够很容易地将它破解。
因此对安全性要求较高的Linux系统都把加密后的口令字分离出来，单独存放在一个文件中，这个文件是`/etc/shadow`文件。 有超级用户才拥有该文件读权限，这就保证了用户密码的安全性。

+ `/etc/shadow`中的记录行与`/etc/passwd`中的一一对应，它由`pwconv`命令根据`/etc/passwd`中的数据自动产生，
它的文件格式与`/etc/passwd`类似，由若干个字段组成，字段之间用`:`隔开。这些字段是：
`登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志`

1. `登录名`是与`/etc/passwd`文件中的登录名相一致的用户账号
2. `口令`字段存放的是加密后的用户口令字，长度为`13`个字符。如果为空，则对应用户没有口令，登录时不需要口令；
如果含有不属于集合` { ./0-9A-Za-z }`中的字符，则对应的用户不能登录。
3. `最后一次修改时间`表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。
例如在`SCO Linux `中，这个时间起点是`1970年1月1日`。
4. `最小时间间隔`指的是两次修改口令之间所需的最小天数。
5. `最大时间间隔`指的是口令保持有效的最大天数。
6. `警告时间`字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。
7. `不活动时间`表示的是用户没有登录活动但账号仍能保持有效的最大天数。
8. `失效时间`字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。

下面是`/etc/shadow`的一个例子：

```bash
＃ cat /etc/shadow

root:Dnakfw28zf38w:8764:0:168:7:::
daemon:*::0:0::::
bin:*::0:0::::
sys:*::0:0::::
adm:*::0:0::::
uucp:*::0:0::::
nuucp:*::0:0::::
auth:*::0:0::::
cron:*::0:0::::
listen:*::0:0::::
lp:*::0:0::::
sam:EkdiSECLWPdSa:9740:0:0::::
```

+ 用户组的所有信息都存放在`/etc/group`文件中。

将用户分组是 Linux 系统中对用户进行管理及控制访问权限的一种手段。
每个用户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不同的组。
当一个用户同时是多个组中的成员时，在`/etc/passwd`文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。

用户要访问属于附加组的文件时，必须首先使用`newgrp`命令使自己成为所要访问的组中的成员。
用户组的所有信息都存放在`/etc/group`文件中。此文件的格式也类似于`/etc/passwd`文件，由冒号(`:`)隔开若干个字段，这些字段有：

`组名:口令:组标识号:组内用户列表`

+ `组名`是用户组的名称，由字母或数字构成。与`/etc/passwd`中的登录名一样，组名不应重复。
+ `口令`字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为`空`，或者是`*`。
+ `组标识号`与用户标识号类似，也是一个整数，被系统内部用来标识组。
+ `组内用户列表`是属于这个组的所有用户的列表，不同用户之间用逗号(`,`)分隔。这个用户组可能是用户的主组，也可能是附加组。

`/etc/group`文件的一个例子如下：

```bash
root::0:root
bin::2:root,bin
sys::3:root,uucp
adm::4:root,adm
daemon::5:root,daemon
lp::7:root,lp
users::20:root,sam
```

### 添加批量用户

添加和删除用户对每位Linux系统管理员都是轻而易举的事，比较棘手的是如果要添加几十个、上百个甚至上千个用户时，我们不太可能还使用useradd一个一个地添加，必然要找一种简便的创建大量用户的方法。
Linux系统提供了创建大量用户的工具，可以让您立即创建大量用户，方法如下：

1. 先编辑一个文本用户文件。

每一列按照`/etc/passwd`密码文件的格式书写，要注意每个用户的用户名、`UID`、宿主目录都不可以相同，其中密码栏可以留做空白或输入`x`号。一个范例文件`user.txt`内容如下：

```bash
user001::600:100:user:/home/user001:/bin/bash
user002::601:100:user:/home/user002:/bin/bash
user003::602:100:user:/home/user003:/bin/bash
...
```

2. 以root身份执行命令 `/usr/sbin/newusers`，从刚创建的用户文件`user.txt`中导入数据，创建用户：

```bash
newusers < user.txt
```

然后可以执行命令 `vipw` 或 `vi /etc/passwd` 检查`/etc/passwd` 文件是否已经出现这些用户的数据，并且用户的宿主目录是否已经创建。

3. 执行命令`/usr/sbin/pwunconv`。

将 `/etc/shadow` 产生的 `shadow` 密码解码，然后回写到` /etc/passwd` 中，并将`/etc/shadow`的`shadow`密码栏删掉。
这是为了方便下一步的密码转换工作，即先取消 `shadow password` 功能。

```bash
pwunconv
```

4. 编辑每个用户的密码对照文件。

格式为：`用户名:密码`

实例文件 `passwd.txt` 内容如下：

```bash
user001:123456
user002:123456
user003:123456
user004:123456
user005:123456
user006:123456
```

5. 以 `root` 身份执行命令 `/usr/sbin/chpasswd`。

创建用户密码，`chpasswd` 会将经过 `/usr/bin/passwd` 命令编码过的密码写入 `/etc/passwd` 的密码栏。

```bash
chpasswd < passwd.txt
```

6. 确定密码经编码写入`/etc/passwd`的密码栏后。

执行命令 `/usr/sbin/pwconv` 将密码编码为 `shadow password`，并将结果写入 `/etc/shadow`。

```bash
pwconv
```

这样就完成了大量用户的创建了，之后您可以到`/home`下检查这些用户宿主目录的权限设置是否都正确，并登录验证用户密码是否正确。
